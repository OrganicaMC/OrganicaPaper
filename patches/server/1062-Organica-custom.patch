From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: DiaLight <light_01@rambler.ru>
Date: Mon, 8 Jan 2024 02:19:08 +0300
Subject: [PATCH] Organica custom


diff --git a/src/main/java/com/chocohead/mm/api/ClassTinkerers.java b/src/main/java/com/chocohead/mm/api/ClassTinkerers.java
new file mode 100644
index 0000000000000000000000000000000000000000..4643e3ca82d641f2b23a1c4ef5dd88d7e20de55e
--- /dev/null
+++ b/src/main/java/com/chocohead/mm/api/ClassTinkerers.java
@@ -0,0 +1,276 @@
+/*
+ * Copyright 2019 Chocohead
+ *
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+package com.chocohead.mm.api;
+
+import java.net.URL;
+import java.net.URLClassLoader;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+import java.util.function.Consumer;
+import java.util.function.Predicate;
+
+import org.apache.commons.lang3.ArrayUtils;
+
+import org.objectweb.asm.Type;
+import org.objectweb.asm.tree.ClassNode;
+
+/**
+ * A collection of helper methods to allow adding and changing the definition of classes.
+ *
+ * <p>Class transformations via {@link #addTransformation(String, Consumer)} and additional enum entries via
+ * {@link #enumBuilder(String, Class...)} should be done via an Early Riser.
+ * Additional class definitions via {@link #define(String, byte[])} can be done at any time.
+ *
+ * <p><b>Non-static methods are to be treated as non-API and thus should be left alone.</b>
+ *
+ * @author Chocohead
+ */
+public enum ClassTinkerers {
+    INSTANCE;
+
+//    private Predicate<URL> urlers = url -> false;
+//    private Map<String, byte[]> clazzes = new HashMap<>();
+//    private Map<String, Consumer<ClassNode>> replacers = new HashMap<>();
+//    private Map<String, Set<Consumer<ClassNode>>> tinkerers = new HashMap<>();
+//    private Set<EnumAdder> enumExtensions = new HashSet<>();
+//    public void hookUp(Consumer<URL> liveURL, Map<String, byte[]> liveClassMap, Map<String, Consumer<ClassNode>> liveReplacers, Map<String, Set<Consumer<ClassNode>>> liveTinkerers, Set<EnumAdder> liveEnums) {
+//        urlers = url -> {
+//            liveURL.accept(url);
+//            return true;
+//        };
+//
+//        liveClassMap.putAll(clazzes);
+//        clazzes = liveClassMap;
+//
+//        liveReplacers.putAll(replacers);
+//        replacers = liveReplacers;
+//
+//        liveTinkerers.putAll(tinkerers);
+//        tinkerers = liveTinkerers;
+//
+//        liveEnums.addAll(enumExtensions);
+//        enumExtensions = liveEnums;
+//    }
+//
+//    /**
+//     * Adds the given {@link URL} to the mod {@link URLClassLoader}'s list used to search for mod classes and resources
+//     *
+//     * <p>A {@code false} return value means this has been invoked too early in the loading process and the addition failed
+//     * <p>If the given {@link URL} is {@code null} or is already in the list, this will have no effect
+//     * but will still return {@link true} if it would have otherwise succeeded.
+//     *
+//     * @param url The URL to be added to the search path of URLs
+//     * @return Whether the URL has been given to the classloader
+//     *
+//     * @since 1.6
+//     */
+//    public static boolean addURL(URL url) {
+//        return INSTANCE.urlers.test(url);
+//    }
+//
+//    /**
+//     * Define a class with the given {@link name} by the given {@link contents} if it doesn't already exist
+//     * <p><b>Behaviour is undefined if the target class name is already class loaded</b>
+//     *
+//     * @param name The name of the class to define
+//     * @param contents The bytecode for the class
+//     * @return Whether the definition was successful (ie another definition with the same name is not already present)
+//     *
+//     * @throws NullPointerException If name is {@code null}
+//     * @throws IllegalArgumentException If contents is {@code null}
+//     */
+//    public static boolean define(String name, byte[] contents) {
+//        name = '/' + name.replace('.', '/') + ".class";
+//        if (INSTANCE.clazzes.containsKey(name)) return false;
+//
+//        if (contents == null) throw new IllegalArgumentException("Tried to define null class named " + name);
+//        INSTANCE.clazzes.put(name, contents);
+//
+//        return true;
+//    }
+//
+//    /**
+//     * Add a class replacer for the given class {@link target} to allow totally replacing bytecode during definition.
+//     * <p><b>Does nothing if the target class is already defined</b>
+//     *
+//     * <p>This method is designed when the bulk or entirety of the target class is going to be replaced by the
+//     * {@code replacer}. For more modest changes {@link #addTransformation(String, Consumer)} is strongly recommended.
+//     *
+//     * <p>No Mixins or {@link #addTransformation(String, Consumer) transformations} will have applied when the
+//     * {@code replacer} is given the {@link ClassNode}. Subsequently only one replacement for a given class can be registered,
+//     * attempting to register more will result in an {@link IllegalStateException}.
+//     *
+//     * @param target The name of the class to be replaced
+//     * @param transformer A {@link Consumer} to take the target class's unmodified {@link ClassNode} replace the contents
+//     *
+//     * @throws NullPointerException If target is {@code null}
+//     * @throws IllegalArgumentException If replacer is {@code null}
+//     * @throws IllegalStateException If replacement for the target has already been registered
+//     *
+//     * @since 1.9
+//     */
+//    public static void addReplacement(String target, Consumer<ClassNode> replacer) {
+//        if (replacer == null) throw new IllegalArgumentException("Tried to set null replacer for " + target);
+//        String name = target.replace('.', '/');
+//
+//        Consumer<ClassNode> existing = INSTANCE.replacers.get(name);
+//        if (existing != null) {
+//            throw new IllegalStateException("Multiple attempts to replace " + name + ": " + existing + " and " + replacer);
+//        }
+//
+//        INSTANCE.replacers.put(name, replacer);
+//    }
+//
+//    /**
+//     * Add a class transformer for the given class {@link target} to allow modifying the bytecode during definition.
+//     * <p><b>Does nothing if the target class is already defined</b>
+//     *
+//     * <p>This method is designed when certain elements of the target class are changed by the {@code transformer}.
+//     * For more drastic changes {@link #addReplacement(String, Consumer)} might prove beneficial.
+//     *
+//     * <p>Any {@link #addReplacement(String, Consumer) replacement} will have applied before the {@code transformer}
+//     * is given the {@link ClassNode}. Any number of other Mixins or transformations could have applied also so care
+//     * should be taken that the target of the transformation is as expected.
+//     *
+//     * @param target The name of the class to be transformed
+//     * @param transformer A {@link Consumer} to take the target class's {@link ClassNode} to be tinkered with
+//     *
+//     * @throws NullPointerException If target is {@code null}
+//     * @throws IllegalArgumentException If transformer is {@code null}
+//     */
+//    public static void addTransformation(String target, Consumer<ClassNode> transformer) {
+//        if (transformer == null) throw new IllegalArgumentException("Tried to add null transformer for " + target);
+//        INSTANCE.tinkerers.computeIfAbsent(target.replace('.', '/'), k -> new HashSet<>()).add(transformer);
+//    }
+//
+//    /**
+//     * Create a new {@link EnumAdder} in order to add additional Enum entries to the given type name.
+//     * <p>Nothing will be done if the given Enum type has already been loaded.</p>
+//     *
+//     * @param type The name of the enum to be extended
+//     * @return A builder for which additional entries can be defined
+//     *
+//     * @throws NullPointerException If type is {@code null}
+//     *
+//     * @since 2.2
+//     */
+//    public static EnumAdder enumBuilder(String type) {
+//        if (type == null) throw new NullPointerException("Tried to add onto a null type!");
+//
+//        return new EnumAdder(type.replace('.', '/'), ArrayUtils.EMPTY_CLASS_ARRAY);
+//    }
+//
+//    /**
+//     * Create a new {@link EnumAdder} in order to add additional Enum entries to the given type name.
+//     * <p>Nothing will be done if the given Enum type has already been loaded.</p>
+//     * <p><b>Will crash if any of the parameter types are from Minecraft to avoid early class loading</b>
+//     *
+//     * @param type The name of the enum to be extended
+//     * @param parameterTypes The type of parameters the constructor to be used takes
+//     * @return A builder for which additional entries can be defined
+//     *
+//     * @throws NullPointerException If type is null
+//     * @throws IllegalArgumentException If parameterTypes is or contains null, or is a Minecraft class
+//     */
+//    public static EnumAdder enumBuilder(String type, Class<?>... parameterTypes) {
+//        if (type == null) throw new NullPointerException("Tried to add onto a null type!");
+//        if (parameterTypes == null || ArrayUtils.contains(parameterTypes, null))
+//            throw new IllegalArgumentException("Invalid parameter array: " + Arrays.toString(parameterTypes));
+//
+//        for (Class<?> param : parameterTypes) {
+//            if (param.getName().startsWith("net.minecraft.")) {
+//                throw new IllegalArgumentException("Early loaded " + param.getName());
+//            }
+//        }
+//
+//        return new EnumAdder(type.replace('.', '/'), parameterTypes);
+//    }
+//
+//    /**
+//     * Create a new {@link EnumAdder} in order to add additional Enum entries to the given type name.
+//     * <p>Nothing will be done if the given Enum type has already been loaded.</p>
+//     *
+//     * @param type The name of the enum to be extended
+//     * @param parameterTypes The <b>internal names</b> of the parameter types the constructor to be used takes
+//     * @return A builder for which additional entries can be defined
+//     *
+//     * @throws NullPointerException If type is {@code null}
+//     * @throws IllegalArgumentException If parameterTypes is or contains {@code null}, or is invalidly specified
+//     */
+//    public static EnumAdder enumBuilder(String type, String... parameterTypes) {
+//        if (type == null) throw new NullPointerException("Tried to add onto a null type!");
+//        if (parameterTypes == null || ArrayUtils.contains(parameterTypes, null))
+//            throw new IllegalArgumentException("Invalid parameter array: " + Arrays.toString(parameterTypes));
+//
+//        return new EnumAdder(type.replace('.', '/'), Arrays.stream(parameterTypes).map(param -> param.replace('.', '/')).toArray(String[]::new));
+//    }
+//
+//    /**
+//     * Create a new {@link EnumAdder} in order to add additional Enum entries to the given type name
+//     *
+//     * <p>The given parameter types can be any mix of
+//     * 	<ul>
+//     * 		<li>{@link Class} - <b>Will crash if a Minecraft class to avoid early class loading</b>
+//     * 		<li>{@link String} - Given as <b>internal names</b> (ie <code>Lmy/package/class;</code> or <code>I</code>)
+//     * 		<li>{@link Type} - Any {@link Type#getSort() sorts} aside from {@link Type#METHOD} or {@link Type#VOID}
+//     * 	</ul>
+//     * 	So that it matches the constructor that is wanted to be used.</p>
+//     *
+//     * <p>Nothing will be done if the given Enum type has already been loaded.</p>
+//     *
+//     * @param type The name of the enum to be extended
+//     * @param parameterTypes The type or internal names of the parameter types the constructor to be used takes
+//     * @return A builder for which additional entries can be defined
+//     *
+//     * @throws NullPointerException If type is {@code null}
+//     * @throws IllegalArgumentException If parameterTypes is or contains {@code null}, or is invalidly specified
+//     */
+//    public static EnumAdder enumBuilder(String type, Object... parameterTypes) {
+//        if (type == null) throw new NullPointerException("Tried to add onto a null type!");
+//        if (parameterTypes == null || ArrayUtils.contains(parameterTypes, null))
+//            throw new IllegalArgumentException("Invalid parameter array: " + Arrays.toString(parameterTypes));
+//
+//        return new EnumAdder(type.replace('.', '/'), parameterTypes);
+//    }
+//
+//    /**
+//     * Register the given {@link EnumAdder} as finished and ready to be used
+//     *
+//     * @param builder The finished EnumAdder to store
+//     */
+//    static void addEnum(EnumAdder builder) {
+//        if (ArrayUtils.contains(builder.parameterTypes, null)) //Individual array entries could be swapped out naughtily, guard against it
+//            throw new IllegalArgumentException("Builder for " + builder.type + " has an invalid parameter array: " + Arrays.toString(builder.parameterTypes));
+//
+//        //Only bother adding it if changes are actually made
+//        if (!builder.getAdditions().isEmpty()) INSTANCE.enumExtensions.add(builder);
+//    }
+
+    /**
+     * Gets the Enum entry with the given name from the given enum type
+     *
+     * @param type The type of Enum for which to search in
+     * @param name The name of the entry to return
+     * @return The entry within type that has {@link Enum#name()} equal to name
+     *
+     * @throws NullPointerException If type is {@code null}
+     * @throws IllegalArgumentException If no entry with the given name can be found in type
+     */
+    public static <E extends Enum<E>> E getEnum(Class<E> type, String name) {
+        for (E constant : type.getEnumConstants()) {
+            if (constant.name().equals(name)) {
+                return constant;
+            }
+        }
+
+        throw new IllegalArgumentException("Unable to find " + name + " in " + type);
+    }
+}
diff --git a/src/main/java/eu/pb4/polymer/common/api/events/BooleanEvent.java b/src/main/java/eu/pb4/polymer/common/api/events/BooleanEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..0fd6a8bb7ab4ba081cd0d262cd075e16623506bf
--- /dev/null
+++ b/src/main/java/eu/pb4/polymer/common/api/events/BooleanEvent.java
@@ -0,0 +1,33 @@
+package eu.pb4.polymer.common.api.events;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.function.Predicate;
+
+public final class BooleanEvent<T> {
+    private List<T> handlers = new ArrayList<>();
+
+    public void register(T listener) {
+        this.handlers.add(listener);
+    }
+
+    public T registerRet(T listener) {
+        this.handlers.add(listener);
+        return listener;
+    }
+
+    public void unregister(T listener) {
+        this.handlers.remove(listener);
+    }
+
+    public boolean invoke(Predicate<T> invoker) {
+        for (var handler : handlers) {
+            var bool = invoker.test(handler);
+
+            if (bool == true) {
+                return true;
+            }
+        }
+        return false;
+    }
+}
diff --git a/src/main/java/eu/pb4/polymer/common/api/events/FunctionEvent.java b/src/main/java/eu/pb4/polymer/common/api/events/FunctionEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..d875553cd691a5c76091f9c3b957d0e43bcd3cb9
--- /dev/null
+++ b/src/main/java/eu/pb4/polymer/common/api/events/FunctionEvent.java
@@ -0,0 +1,28 @@
+package eu.pb4.polymer.common.api.events;
+
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+import java.util.function.Function;
+
+public final class FunctionEvent<T, R> {
+    private List<T> handlers = new ArrayList<>();
+
+    public void register(T listener) {
+        this.handlers.add(listener);
+    }
+
+    public T registerRet(T listener) {
+        this.handlers.add(listener);
+        return listener;
+    }
+
+    public void unregister(T listener) {
+        this.handlers.remove(listener);
+    }
+
+    public R invoke(Function<Collection<T>, R> invoker) {
+        return invoker.apply(handlers);
+    }
+}
diff --git a/src/main/java/eu/pb4/polymer/common/api/events/SimpleEvent.java b/src/main/java/eu/pb4/polymer/common/api/events/SimpleEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..2991c574c3e7fa3371cc08dcea9745a16fd068bb
--- /dev/null
+++ b/src/main/java/eu/pb4/polymer/common/api/events/SimpleEvent.java
@@ -0,0 +1,33 @@
+package eu.pb4.polymer.common.api.events;
+
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.function.Consumer;
+
+public final class SimpleEvent<T> {
+    private List<T> handlers = new ArrayList<>();
+
+    public void register(T listener) {
+        this.handlers.add(listener);
+    }
+
+    public T registerRet(T listener) {
+        this.handlers.add(listener);
+        return listener;
+    }
+
+    public void unregister(T listener) {
+        this.handlers.remove(listener);
+    }
+
+    public void invoke(Consumer<T> invoker) {
+        for (var handler : handlers) {
+            invoker.accept(handler);
+        }
+    }
+
+    public boolean isEmpty() {
+        return this.handlers.isEmpty();
+    }
+}
diff --git a/src/main/java/eu/pb4/polymer/common/impl/CommonImpl.java b/src/main/java/eu/pb4/polymer/common/impl/CommonImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..6fb3e1bd097d21ff9b3ab82041497fa4b159f421
--- /dev/null
+++ b/src/main/java/eu/pb4/polymer/common/impl/CommonImpl.java
@@ -0,0 +1,233 @@
+package eu.pb4.polymer.common.impl;
+
+import com.google.gson.Gson;
+import com.google.gson.GsonBuilder;
+import org.apache.commons.io.IOUtils;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.io.FileInputStream;
+import java.io.InputStreamReader;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.StandardOpenOption;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+public final class CommonImpl {
+    public static final Logger LOGGER = LoggerFactory.getLogger("Polymer");
+    public static final Gson GSON = new GsonBuilder().disableHtmlEscaping().create();
+    public static final Gson GSON_PRETTY = new GsonBuilder().disableHtmlEscaping().setPrettyPrinting().create();
+    public static final int CORE_COMMAND_MINIMAL_OP;
+    public static final boolean DEVELOPER_MODE;
+    public static final boolean MINIMAL_ABOUT;
+    public static final String DESCRIPTION = "Library for creating better server side content!";
+    public static final boolean DEV_ENV = false;
+    public static final boolean IS_CLIENT = false;
+    public static final boolean LOG_MORE_ERRORS;
+    public static final boolean ENABLE_TEMPLATE_ENTITY_WARNINGS;
+    public static final boolean FORCE_RESOURCEPACK_ENABLED_STATE;
+
+//    private static final ModContainer CONTAINER = FabricLoader.getInstance().getModContainer("polymer-common").get();
+    public static final List<String> CONTRIBUTORS = new ArrayList<>();
+    public static final String VERSION = "0"; // CONTAINER.getMetadata().getVersion().getFriendlyString().split("\\+")[0];
+    public static final String GITHUB_URL = "0"; // CONTAINER.getMetadata().getContact().get("sources").orElse("https://pb4.eu");
+
+    public static final Map<String, DisabledMixinReason> DISABLED_MIXINS = new HashMap<>();
+    private static boolean devWarn;
+
+    public static DisabledMixinReason getDisabledMixin(String source, String mixin) {
+        return DISABLED_MIXINS.get(source + ":" + mixin);
+    }
+
+//    public static void addContributor(Person person) {
+//        if (!CONTRIBUTORS.contains(person.getName())) {
+//            CONTRIBUTORS.add(person.getName());
+//        }
+//    }
+
+    static {
+        new CompatStatus();
+
+//        if (CompatStatus.FORGE_CONNECTOR) {
+//            LOGGER.warn("==================================================================================");
+//            LOGGER.warn("Polymer (" + VERSION + ") support for Connector/Forge is highly experimental!");
+//            LOGGER.warn("Things might not work correctly if at all, so you are on your own!");
+//            LOGGER.warn("=================================================================================");
+//        }
+
+//        var config = loadConfig("common", CommonConfig.class);
+        CORE_COMMAND_MINIMAL_OP = 0; //  config.coreCommandOperatorLevel;
+        DEVELOPER_MODE = false; // config.enableDevTools || DEV_ENV;
+        MINIMAL_ABOUT = false; // config.minimalisticAbout;
+        LOG_MORE_ERRORS = false; // config.logAllExceptions || DEV_ENV;
+        ENABLE_TEMPLATE_ENTITY_WARNINGS = false; // config.enableTemplateEntityWarnings;
+        FORCE_RESOURCEPACK_ENABLED_STATE = false; // config.forceResourcePackEnabled;
+
+//        CONTAINER.getMetadata().getAuthors().forEach(CommonImpl::addContributor);
+//        CONTAINER.getMetadata().getContributors().forEach(CommonImpl::addContributor);
+
+//        if (configDir().resolve("mixins.json").toFile().isFile()) {
+//            for (var mixin : loadConfig("mixins", MixinOverrideConfig.class).disabledMixins) {
+//                if (!mixin.contains(":")) {
+//                    mixin = "polymer-core:" + mixin;
+//                }
+//                DISABLED_MIXINS.put(mixin, new DisabledMixinReason("Config file (polymer/mixins.json)", "User/config specified, unknown reason"));
+//            }
+//        }
+
+//        for (var mods : LOADER.getAllMods()) {
+//            var meta = mods.getMetadata();
+//            var customValue = meta.getCustomValue("polymer:disable_mixin");
+//
+//            if (customValue instanceof CustomValue.CvArray cvArray) {
+//                for (var value : cvArray) {
+//                    var key = value.getAsString();
+//                    if (!key.contains(":")) {
+//                        key = "polymer-core:" + key;
+//                    }
+//
+//                    DISABLED_MIXINS.put(key,
+//                            new DisabledMixinReason(meta.getName() + " (" + meta.getId() + ")", "Unknown reason! I hope author knew what they were doing.."));
+//                }
+//            } else if (customValue instanceof CustomValue.CvObject cvObject) {
+//                for (var value : cvObject) {
+//                    var key = value.getKey();
+//                    if (!key.contains(":")) {
+//                        key = "polymer-core:" + key;
+//                    }
+//
+//                    DISABLED_MIXINS.put(key,
+//                            new DisabledMixinReason(meta.getName() + " (" + meta.getId() + ")", value.getValue().getAsString()));
+//                }
+//            }
+//        }
+    }
+
+    public static boolean isModLoaded(String modId) {
+        return true; //  LOADER.isModLoaded(modId);
+    }
+
+    public static Path configDir() {
+        return Path.of(".").resolve("polymer"); // LOADER.getConfigDir().resolve("polymer");
+    }
+
+    public static <T> T loadConfig(String name, Class<T> clazz) {
+        try {
+            var folder = configDir();
+            if (!Files.isDirectory(folder)) {
+                if (Files.exists(folder)) {
+                    Files.deleteIfExists(folder);
+                }
+                Files.createDirectories(folder);
+            }
+            var path = folder.resolve(name + ".json");
+
+            if (path.toFile().isFile()) {
+                String json = IOUtils.toString(new InputStreamReader(new FileInputStream(path.toFile()), StandardCharsets.UTF_8));
+                var obj = GSON.fromJson(json, clazz);
+
+                if (obj != null) {
+                    saveConfig(name, obj);
+                    return obj;
+                }
+            }
+        } catch (Exception e) {
+            LOGGER.warn("Couldn't load config! " + clazz.toString());
+            LOGGER.warn(e.toString());
+        }
+
+        try {
+            var obj = clazz.getConstructor().newInstance();
+            saveConfig(name, obj);
+            return obj;
+        } catch (Exception e) {
+            LOGGER.error("Invalid config class! " + clazz.toString());
+            throw new RuntimeException(e);
+        }
+    }
+
+    public static void saveConfig(String name, Object obj) {
+        try {
+            var folder = configDir();
+            if (!Files.isDirectory(folder)) {
+                if (Files.exists(folder)) {
+                    Files.deleteIfExists(folder);
+                }
+                Files.createDirectories(folder);
+            }
+            var path = folder.resolve(name + ".json");
+
+            Files.writeString(path, GSON_PRETTY.toJson(obj), StandardCharsets.UTF_8, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);
+        } catch (Exception e) {
+            LOGGER.warn("Couldn't save config! " + obj.getClass());
+        }
+    }
+
+
+//    public static Path getJarPath(String path) {
+//        return CONTAINER.getPath(path);
+//    }
+
+    public static Path getGameDir() {
+        return Path.of(".");
+    }
+
+
+    public static boolean shouldApplyMixin(String source, String mixinClassName) {
+        return shouldApplyMixin(source, mixinClassName, false);
+    }
+    public static boolean shouldApplyMixin(String source, String mixinClassName, boolean armor) {
+        var disabledReason = getDisabledMixin(source, mixinClassName);
+        if (disabledReason != null) {
+            CommonImpl.LOGGER.warn("Mixin '" + mixinClassName + "' from '" + source + "' was disabled by "
+                    + disabledReason.source() + ". Reason: " + disabledReason.reason() + ". This might cause issues and isn't generally supported!");
+
+            if (CommonImpl.DEV_ENV && !devWarn) {
+                devWarn = true;
+                CommonImpl.LOGGER.error(
+                        "Ok... I see you are disabling my mixins. It's generally not good idea to do that, since most "
+                                + "likely this will break polymer. Only do it if you make sure everything will work fine (for example by replicating "
+                                + "logic in your own mod). If you need to do more things, it might be better to just ask me to add api for that. "
+                                + "I'm open for these if they allow better usage/integration with polymer... Make a github issue or ask on discord!"
+                );
+            }
+
+            return false;
+        }
+
+        var name = mixinClassName;
+
+        name = name.replace("client.", "");
+        if (name.startsWith("compat.")) {
+            var tmp = name.split("\\.");
+
+            var type = tmp[tmp.length - 1].split("_")[0];
+
+            return switch (type) {
+                case "fabricSync" -> CompatStatus.FABRIC_SYNC;
+                case "fabricSH" -> CompatStatus.FABRIC_SCREEN_HANDLER;
+                case "fabricItemGroup" -> CompatStatus.FABRIC_ITEM_GROUP;
+                case "fabricNetworking" -> CompatStatus.FABRIC_NETWORKING;
+                case "polymc" -> CompatStatus.POLYMC;
+                case "wthit" -> CompatStatus.WTHIT;
+                case "rei" -> CompatStatus.REI;
+                case "emi" -> CompatStatus.EMI;
+                case "lithium" -> CompatStatus.LITHIUM;
+                case "jei" -> CompatStatus.JEI;
+                case "armor" -> CompatStatus.REQUIRE_ALT_ARMOR_HANDLER || armor;
+                case "ip" -> CompatStatus.IMMERSIVE_PORTALS;
+                case "quiltReg" -> CompatStatus.QUILT_REGISTRY;
+                default -> true;
+            };
+        }
+
+        return true;
+    }
+
+
+    public record DisabledMixinReason(String source, String reason) {};
+}
diff --git a/src/main/java/eu/pb4/polymer/common/impl/CompatStatus.java b/src/main/java/eu/pb4/polymer/common/impl/CompatStatus.java
new file mode 100644
index 0000000000000000000000000000000000000000..d73278f270828566ea552bd59e4879165df16648
--- /dev/null
+++ b/src/main/java/eu/pb4/polymer/common/impl/CompatStatus.java
@@ -0,0 +1,61 @@
+package eu.pb4.polymer.common.impl;
+
+import org.jetbrains.annotations.ApiStatus;
+
+@ApiStatus.Internal
+public final class CompatStatus {
+    public static final boolean POLYMER_BLOCKS = false; // LOADER.isModLoaded("polymer-blocks");
+    public static final boolean POLYMER_CORE = false; // LOADER.isModLoaded("polymer-core");
+    public static final boolean POLYMER_AUTOHOST = false; // LOADER.isModLoaded("polymer-autohost");
+    public static final boolean POLYMER_VIRTUAL_ENTITY = false; // LOADER.isModLoaded("polymer-virtual-entity");
+
+
+    public static final boolean POLYMER_RESOURCE_PACK = false; // LOADER.isModLoaded("polymer-resource-pack");
+    @Deprecated
+    public static final boolean POLYMER_RESOURCE_PACKS = POLYMER_RESOURCE_PACK;
+
+    public static final boolean FABRIC_SYNC = false; // LOADER.isModLoaded("fabric-registry-sync-v0");
+    public static final boolean FABRIC_NETWORKING = false; // LOADER.isModLoaded("fabric-networking-api-v1");
+    public static final boolean FABRIC_FLUID_RENDERING = false; // LOADER.isModLoaded("fabric-rendering-fluids-v1");
+    @Deprecated
+    public static final boolean FABRIC_FLUID_RENDERERING = FABRIC_FLUID_RENDERING;
+    public static final boolean FABRIC_ITEM_GROUP = false; // LOADER.isModLoaded("fabric-item-group-api-v1");
+    public static final boolean FABRIC_SCREEN_HANDLER = false; // LOADER.isModLoaded("fabric-screen-handler-api-v1");
+    public static final boolean FABRIC_RECIPE_API = false; // LOADER.isModLoaded("fabric-recipe-api-v1");
+    public static final boolean FABRIC_PERMISSION_API_V0 = false; // LOADER.isModLoaded("fabric-permissions-api-v0");
+
+    public static final boolean QUILT_ITEM_GROUP = false; // LOADER.isModLoaded("quilt_item_group");
+    public static final boolean QUILT_REGISTRY = false; // LOADER.isModLoaded("quilt_registry");
+
+    public static final boolean FORGE_CONNECTOR = false; // LOADER.isModLoaded("connectormod");
+
+    public static final boolean POLYMC = false; // LOADER.isModLoaded("polymc");
+    public static final boolean LITHIUM = false; // LOADER.isModLoaded("lithium");
+    public static final boolean DISGUISELIB = false; // LOADER.isModLoaded("disguiselib");
+
+    public static final boolean WTHIT = false; // LOADER.isModLoaded("wthit");
+    public static final boolean JADE = false; // LOADER.isModLoaded("jade");
+    public static final boolean REI = false; // LOADER.isModLoaded("roughlyenoughitems");
+    public static final boolean JEI = false; // LOADER.isModLoaded("jei");
+    public static final boolean EMI = false; // LOADER.isModLoaded("emi");
+
+    public static final boolean FABRIC_PROXY_LITE = false; // LOADER.isModLoaded("fabricproxy-lite");
+    public static final boolean FABRIC_PROXY = false; // LOADER.isModLoaded("fabricproxy");
+    public static final boolean QFORWARD = false; // LOADER.isModLoaded("qforward");
+    public static final boolean FAPROXY = false; // LOADER.isModLoaded("fabroxy");
+
+    public static final boolean PROXY_MODS = FABRIC_PROXY || FABRIC_PROXY_LITE || QFORWARD || FAPROXY;
+
+    public static final boolean E4MC = false; // LOADER.isModLoaded("e4mc_minecraft");
+
+    public static final boolean FLOODGATE = false; // LOADER.isModLoaded("floodgate");
+
+    public static final boolean IRIS = false; // LOADER.isModLoaded("iris");
+    public static final boolean CANVAS = false; // LOADER.isModLoaded("canvas");
+    public static final boolean OPTIBAD = false; // LOADER.isModLoaded("optifabric");
+
+    public static final boolean REQUIRE_ALT_ARMOR_HANDLER = IRIS || CANVAS || OPTIBAD;
+
+    public static final boolean IMMERSIVE_PORTALS = false; // LOADER.isModLoaded("imm_ptl_core");
+
+}
diff --git a/src/main/java/eu/pb4/polymer/core/api/block/PolymerBlockUtils.java b/src/main/java/eu/pb4/polymer/core/api/block/PolymerBlockUtils.java
new file mode 100644
index 0000000000000000000000000000000000000000..3c81812754bfb0e13ba9c274661dc6fc2bd500a7
--- /dev/null
+++ b/src/main/java/eu/pb4/polymer/core/api/block/PolymerBlockUtils.java
@@ -0,0 +1,265 @@
+package eu.pb4.polymer.core.api.block;
+
+import eu.pb4.polymer.common.api.events.BooleanEvent;
+import eu.pb4.polymer.common.api.events.SimpleEvent;
+import it.unimi.dsi.fastutil.objects.ObjectOpenCustomHashSet;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.registries.Registries;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.entity.BlockEntityType;
+import net.minecraft.world.level.block.state.BlockState;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.Arrays;
+import java.util.Set;
+import java.util.function.BiPredicate;
+import java.util.function.Predicate;
+
+public final class PolymerBlockUtils {
+    private PolymerBlockUtils() {
+    }
+
+    public static final int NESTED_DEFAULT_DISTANCE = 32;
+
+//    public static final Predicate<BlockState> IS_POLYMER_BLOCK_STATE_PREDICATE = state -> state.getBlock() instanceof PolymerBlock;
+
+    /**
+     * This event allows you to force server side mining for any block/item
+     */
+    public static final BooleanEvent<MineEventListener> SERVER_SIDE_MINING_CHECK = new BooleanEvent<>();
+
+    public static final SimpleEvent<BreakingProgressListener> BREAKING_PROGRESS_UPDATE = new SimpleEvent<>();
+
+//    /**
+//     * This event allows you to force syncing of light updates between server and clinet
+//     */
+//    public static final BooleanEvent<BiPredicate<ServerLevel, ChunkSectionPos>> SEND_LIGHT_UPDATE_PACKET = new BooleanEvent<>();
+//    private static final Set<BlockEntityType<?>> BLOCK_ENTITY_TYPES = new ObjectOpenCustomHashSet<>(Util.identityHashStrategy());
+
+    private static boolean requireStrictBlockUpdates = false;
+
+//    /**
+//     * Marks BlockEntity type as server-side only
+//     *
+//     * @param types BlockEntityTypes
+//     */
+//    public static void registerBlockEntity(BlockEntityType<?>... types) {
+//        BLOCK_ENTITY_TYPES.addAll(Arrays.asList(types));
+//
+//        for (var type : types) {
+//            RegistrySyncUtils.setServerEntry(Registries.BLOCK_ENTITY_TYPE, type);
+//        }
+//    }
+//
+//    /**
+//     * Checks if BlockEntity is server-side only
+//     *
+//     * @param type BlockEntities type
+//     */
+//    public static boolean isPolymerBlockEntityType(BlockEntityType<?> type) {
+//        return BLOCK_ENTITY_TYPES.contains(type);
+//    }
+//
+//    /**
+//     * This method is used to check if BlockState should force sending of light updates to client
+//     *
+//     * @param blockState
+//     * @return
+//     */
+//    public static boolean forceLightUpdates(BlockState blockState) {
+//        if (blockState.getBlock() instanceof PolymerBlock virtualBlock) {
+//            if (virtualBlock.forceLightUpdates(blockState)) {
+//                return true;
+//            }
+//
+//            return ((BlockStateExtra) blockState).polymer$isPolymerLightSource();
+//        }
+//        return false;
+//    }
+//
+//    /**
+//     * Gets BlockState used on client side
+//     *
+//     * @param state server side BlockState
+//     * @return Client side BlockState
+//     */
+//    public static BlockState getPolymerBlockState(BlockState state) {
+//        return getPolymerBlockState(state, null);
+//    }
+//
+//    /**
+//     * Gets BlockState used on client side
+//     *
+//     * @param state server side BlockState
+//     * @param player      Possible target player
+//     * @return Client side BlockState
+//     */
+//    public static BlockState getPolymerBlockState(BlockState state, @Nullable ServerPlayer player) {
+//        return BlockMapper.getFrom(player).toClientSideState(state, player);
+//    }
+//
+//    public static Block getPolymerBlock(Block block, @Nullable ServerPlayer player) {
+//        return BlockMapper.getFrom(player).toClientSideBlock(block, player);
+//    }
+//
+//    /**
+//     * This method is minimal wrapper around {@link PolymerBlock#getPolymerBlockState(BlockState)} )} to make sure
+//     * It gets replaced if it represents other PolymerBlock
+//     *
+//     * @param block       PolymerBlock
+//     * @param blockState  Server side BlockState
+//     * @param maxDistance Maximum number of checks for nested virtual blocks
+//     * @return Client side BlockState
+//     */
+//    public static BlockState getBlockStateSafely(PolymerBlock block, BlockState blockState, int maxDistance) {
+//        BlockState out = block.getPolymerBlockState(blockState);
+//
+//        int req = 0;
+//        while (out.getBlock() instanceof PolymerBlock newBlock && newBlock != block && req < maxDistance) {
+//            out = newBlock.getPolymerBlockState(out);
+//            req++;
+//        }
+//        return out;
+//    }
+//
+//    /**
+//     * This method is minimal wrapper around {@link PolymerBlock#getPolymerBlockState(BlockState)} )} to make sure
+//     * It gets replaced if it represents other PolymerBlock
+//     *
+//     * @param block       PolymerBlock
+//     * @param blockState  Server side BlockState
+//     * @param maxDistance Maximum number of checks for nested virtual blocks
+//     * @param player      Possible target player
+//     * @return Client side BlockState
+//     */
+//    public static BlockState getBlockStateSafely(PolymerBlock block, BlockState blockState, int maxDistance, @Nullable ServerPlayer player) {
+//        if (player == null) {
+//            return getBlockStateSafely(block, blockState, maxDistance);
+//        }
+//
+//        BlockState out = block.getPolymerBlockState(blockState, player);
+//
+//        int req = 0;
+//        while (out.getBlock() instanceof PolymerBlock newBlock && newBlock != block && req < maxDistance) {
+//            out = newBlock.getPolymerBlockState(blockState, player);
+//            req++;
+//        }
+//        return out;
+//    }
+//
+//    /**
+//     * This method is minimal wrapper around {@link PolymerBlock#getPolymerBlockState(BlockState)} )} to make sure
+//     * It gets replaced if it represents other PolymerBlock
+//     *
+//     * @param block       PolymerBlock
+//     * @param blockState  Server side BlockState
+//     * @param player      Possible target player
+//     * @return Client side BlockState
+//     */
+//    public static BlockState getBlockStateSafely(PolymerBlock block, BlockState blockState, @Nullable ServerPlayer player) {
+//        return getBlockStateSafely(block, blockState, NESTED_DEFAULT_DISTANCE, player);
+//    }
+//
+//    /**
+//     * This method is minimal wrapper around {@link PolymerBlock#getPolymerBlockState(BlockState)} to make sure
+//     * It gets replaced if it represents other PolymerBlock
+//     *
+//     * @param block      PolymerBlock
+//     * @param blockState Server side BlockState
+//     * @return Client side BlockState
+//     */
+//    public static BlockState getBlockStateSafely(PolymerBlock block, BlockState blockState) {
+//        return getBlockStateSafely(block, blockState, NESTED_DEFAULT_DISTANCE);
+//    }
+//
+//    /**
+//     * This method is minimal wrapper around {@link PolymerBlock#getPolymerBlock(BlockState)} to make sure
+//     * It gets replaced if it represents other PolymerBlock
+//     *
+//     * @param block       PolymerBlock
+//     * @param state       BlockState
+//     * @param maxDistance Maximum number of checks for nested virtual blocks
+//     * @param player      Possible target player
+//     * @return Client side BlockState
+//     */
+//    public static Block getBlockSafely(PolymerBlock block, BlockState state, int maxDistance, @Nullable ServerPlayer player) {
+//        int req = 0;
+//        Block out = player != null
+//                ? block.getPolymerBlock(state, player)
+//                : block.getPolymerBlock(state);
+//
+//        while (out instanceof PolymerBlock newBlock && newBlock != block && req < maxDistance) {
+//            out = player != null
+//                    ? newBlock.getPolymerBlock(out.getDefaultState(), player)
+//                    : newBlock.getPolymerBlock(state);
+//            req++;
+//        }
+//        return out;
+//    }
+//
+//    /**
+//     * This method is minimal wrapper around {@link PolymerBlock#getPolymerBlock(BlockState)} to make sure
+//     * It gets replaced if it represents other PolymerBlock
+//     *
+//     * @param block       PolymerBlock
+//     * @param state       BlockState
+//     * @param player      Possible target player
+//     * @return Client side BlockState
+//     */
+//    public static Block getBlockSafely(PolymerBlock block, BlockState state, @Nullable ServerPlayer player) {
+//        return getBlockSafely(block, state, NESTED_DEFAULT_DISTANCE, player);
+//    }
+//
+//    /**
+//     * This method is minimal wrapper around {@link PolymerBlock#getPolymerBlock(BlockState)} to make sure
+//     * It gets replaced if it represents other PolymerBlock
+//     *
+//     * @param block       PolymerBlock
+//     * @param state       BlockState
+//     * @param maxDistance Maximum number of checks for nested virtual blocks
+//     * @return Client side BlockState
+//     */
+//    public static Block getBlockSafely(PolymerBlock block, BlockState state, int maxDistance) {
+//        return getBlockSafely(block, state, maxDistance, null);
+//    }
+//
+//
+//    /**
+//     * This method is minimal wrapper around {@link PolymerBlock#getPolymerBlock(BlockState)} to make sure
+//     * It gets replaced if it represents other PolymerBlock
+//     *
+//     * @param block PolymerBlock
+//     * @param state BlockState
+//     * @return Client side BlockState
+//     */
+//    public static Block getBlockSafely(PolymerBlock block, BlockState state) {
+//        return getBlockSafely(block, state, NESTED_DEFAULT_DISTANCE);
+//    }
+//
+//    public static BlockEntityUpdateS2CPacket createBlockEntityPacket(BlockPos pos, BlockEntityType<?> type, CompoundTag nbtCompound) {
+//        return BlockEntityUpdateS2CPacketAccessor.createBlockEntityUpdateS2CPacket(pos.toImmutable(), type, nbtCompound);
+//    }
+
+    @ApiStatus.Experimental
+    public static void requireStrictBlockUpdates() {
+        requireStrictBlockUpdates = true;
+    }
+
+    public static boolean isStrictBlockUpdateRequired() {
+        return requireStrictBlockUpdates;
+    }
+
+    @FunctionalInterface
+    public interface MineEventListener {
+        boolean onBlockMine(BlockState state, BlockPos pos, ServerPlayer player);
+    }
+
+    @FunctionalInterface
+    public interface BreakingProgressListener {
+        boolean onBreakingProgressUpdate(ServerPlayer player, BlockPos pos, BlockState finalState, int i);
+    }
+}
diff --git a/src/main/java/eu/pb4/polymer/core/api/item/PolymerItem.java b/src/main/java/eu/pb4/polymer/core/api/item/PolymerItem.java
new file mode 100644
index 0000000000000000000000000000000000000000..adcd386222f206591508bd79d410b66ac06fe5db
--- /dev/null
+++ b/src/main/java/eu/pb4/polymer/core/api/item/PolymerItem.java
@@ -0,0 +1,88 @@
+package eu.pb4.polymer.core.api.item;
+
+import eu.pb4.polymer.core.api.utils.PolymerSyncedObject;
+import net.minecraft.network.chat.Component;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.TooltipFlag;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.List;
+
+/**
+ * Interface used for creation of server-side items
+ */
+public interface PolymerItem extends PolymerSyncedObject<Item> {
+    /**
+     * Returns main/default item used on client for specific player
+     *
+     * @param itemStack ItemStack of virtual item
+     * @param player    Player for which it's send
+     * @return Vanilla (or other) Item instance
+     */
+    Item getPolymerItem(ItemStack itemStack, @Nullable ServerPlayer player);
+
+    /**
+     * Method used for creation of client-side ItemStack
+     *
+     * @param itemStack Server-side ItemStack
+     * @param player    Player for which it's send
+     * @return Client-side ItemStack
+     */
+    default ItemStack getPolymerItemStack(ItemStack itemStack, TooltipFlag context, @Nullable ServerPlayer player) {
+        return PolymerItemUtils.createItemStack(itemStack, context, player);
+    }
+
+
+    /**
+     * Method used for getting custom model data of items
+     *
+     * @param itemStack Server-side ItemStack
+     * @param player    Player for which it's send
+     * @return Custom model data or -1 if not present
+     */
+    default int getPolymerCustomModelData(ItemStack itemStack, @Nullable ServerPlayer player) {
+        return -1;
+    }
+
+    /**
+     * Method used for getting custom armor color of items
+     * It's designed to be used alongside {@link eu.pb4.polymer.resourcepack.api.PolymerResourcePackUtils#requestArmor(Identifier)}
+     * Make sure colors isn't even so it won't get wrong texture
+     *
+     * @param itemStack Server-side ItemStack
+     * @param player    Player for which it's send
+     * @return Custom color or -1 if not present
+     */
+    default int getPolymerArmorColor(ItemStack itemStack, @Nullable ServerPlayer player) {
+        return -1;
+    }
+
+    /**
+     * This method allows to modify tooltip text
+     * If you just want to add your own one, use {@link Item#appendTooltip(ItemStack, World, List, TooltipFlag)}
+     *
+     * @param tooltip Current tooltip text
+     * @param stack   Server-side ItemStack
+     * @param player  Target player
+     */
+    default void modifyClientTooltip(List<Component> tooltip, ItemStack stack, @Nullable ServerPlayer player) {
+    }
+
+    /**
+     * Allows to disable showing of name in item frames
+     */
+    default boolean showDefaultNameInItemFrames() {
+        return false;
+    }
+
+    @Override
+    default Item getPolymerReplacement(ServerPlayer player) {
+        return this.getPolymerItem(((Item) this).getDefaultInstance(), player);
+    }
+
+//    default boolean handleMiningOnServer(ItemStack tool, BlockState targetBlock, BlockPos pos, ServerPlayer player) {
+//        return true;
+//    }
+}
\ No newline at end of file
diff --git a/src/main/java/eu/pb4/polymer/core/api/item/PolymerItemUtils.java b/src/main/java/eu/pb4/polymer/core/api/item/PolymerItemUtils.java
new file mode 100644
index 0000000000000000000000000000000000000000..d214a2c34252aeb472df2529b389c9885e0d0cd7
--- /dev/null
+++ b/src/main/java/eu/pb4/polymer/core/api/item/PolymerItemUtils.java
@@ -0,0 +1,573 @@
+package eu.pb4.polymer.core.api.item;
+
+import com.google.common.collect.Multimap;
+import eu.pb4.polymer.common.api.events.BooleanEvent;
+import eu.pb4.polymer.common.api.events.FunctionEvent;
+import eu.pb4.polymer.common.impl.CompatStatus;
+import eu.pb4.polymer.core.api.block.PolymerBlockUtils;
+import eu.pb4.polymer.core.api.utils.PolymerObject;
+import eu.pb4.polymer.core.api.utils.PolymerSyncedObject;
+import eu.pb4.polymer.core.api.utils.PolymerUtils;
+import eu.pb4.polymer.core.impl.PolymerImpl;
+import eu.pb4.polymer.resourcepack.api.PolymerResourcePackUtils;
+import net.minecraft.ChatFormatting;
+import net.minecraft.core.registries.BuiltInRegistries;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.ListTag;
+import net.minecraft.nbt.StringTag;
+import net.minecraft.nbt.Tag;
+import net.minecraft.network.chat.Component;
+import net.minecraft.network.chat.MutableComponent;
+import net.minecraft.network.chat.Style;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.util.Mth;
+import net.minecraft.world.effect.MobEffectInstance;
+import net.minecraft.world.entity.EquipmentSlot;
+import net.minecraft.world.entity.ai.attributes.Attribute;
+import net.minecraft.world.entity.ai.attributes.AttributeModifier;
+import net.minecraft.world.item.*;
+import net.minecraft.world.item.alchemy.PotionUtils;
+import net.minecraft.world.item.armortrim.ArmorTrim;
+import net.minecraft.world.item.enchantment.Enchantment;
+import net.minecraft.world.item.enchantment.EnchantmentHelper;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.List;
+import java.util.Map;
+import java.util.function.Predicate;
+
+public final class PolymerItemUtils {
+    public static final String POLYMER_ITEM_ID = "Polymer$itemId";
+    public static final String REAL_TAG = "Polymer$itemTag";
+    public static final String ITEM_FRAME_NAME_TAG = "Polymer$itemName";
+
+    public static final Style CLEAN_STYLE = Style.EMPTY.withItalic(false).withColor(ChatFormatting.WHITE);
+    public static final Style NON_ITALIC_STYLE = Style.EMPTY.withItalic(false);
+
+    /**
+     * Allows to force rendering of some items as polymer one (for example vanilla ones)
+     */
+    public static final BooleanEvent<Predicate<ItemStack>> ITEM_CHECK = new BooleanEvent<>();
+    /**
+     * Allows to modify how virtual items looks before being send to client (only if using build in methods!)
+     * It can modify virtual version directly, as long as it's returned at the end.
+     * You can also return new ItemStack, however please keep previous nbt so other modifications aren't removed if not needed!
+     */
+    public static final FunctionEvent<ItemModificationEventHandler, ItemStack> ITEM_MODIFICATION_EVENT = new FunctionEvent<>();
+    private static final String[] NBT_TO_COPY = { "CanDestroy", "CanPlaceOn", BlockItem.BLOCK_ENTITY_TAG, ArmorTrim.TAG_TRIM_ID,
+            CompassItem.TAG_LODESTONE_DIMENSION, CompassItem.TAG_LODESTONE_POS, CompassItem.TAG_LODESTONE_TRACKED,
+    };
+
+    private PolymerItemUtils() {
+    }
+
+    /**
+     * This methods creates a client side ItemStack representation
+     *
+     * @param itemStack Server side ItemStack
+     * @param player    Player being send to
+     * @return Client side ItemStack
+     */
+    public static ItemStack getPolymerItemStack(ItemStack itemStack, @Nullable ServerPlayer player) {
+        return getPolymerItemStack(itemStack, PolymerUtils.getTooltipContext(player), player);
+    }
+
+    /**
+     * This methods creates a client side ItemStack representation
+     *
+     * @param itemStack      Server side ItemStack
+     * @param tooltipContext Tooltip Context
+     * @param player         Player being send to
+     * @return Client side ItemStack
+     */
+    public static ItemStack getPolymerItemStack(ItemStack itemStack, TooltipFlag tooltipContext, @Nullable ServerPlayer player) {
+        if (getPolymerIdentifier(itemStack) != null) {
+            return itemStack;
+        } else if (itemStack.getItem() instanceof PolymerItem item) {
+            return item.getPolymerItemStack(itemStack, tooltipContext, player);
+        } else if (shouldPolymerConvert(itemStack, player)) {
+            return createItemStack(itemStack, tooltipContext, player);
+        }
+
+        if (ITEM_CHECK.invoke((x) -> x.test(itemStack))) {
+            return createItemStack(itemStack, player);
+        }
+
+        return itemStack;
+    }
+
+    /**
+     * This method gets real ItemStack from Virtual/Client side one
+     *
+     * @param itemStack Client side ItemStack
+     * @return Server side ItemStack
+     */
+    public static ItemStack getRealItemStack(ItemStack itemStack) {
+        ItemStack out = itemStack;
+
+        if (itemStack.hasTag()) {
+            String id = itemStack.getTag().getString(POLYMER_ITEM_ID);
+            if (id != null && !id.isEmpty()) {
+                try {
+                    ResourceLocation identifier = ResourceLocation.tryParse(id);
+                    Item item = BuiltInRegistries.ITEM.get(identifier);
+                    if (item != Items.AIR) {
+                        out = new ItemStack(item, itemStack.getCount());
+                        CompoundTag tag = itemStack.getTagElement(REAL_TAG);
+                        if (tag != null) {
+                            out.setTag(tag);
+                        }
+                    }
+                } catch (Exception e) {
+                    e.printStackTrace();
+                }
+            }
+        }
+
+        return out;
+    }
+
+    /**
+     * Returns stored identifier of Polymer ItemStack. If it's invalid, null is returned instead.
+     */
+    @Nullable
+    public static ResourceLocation getPolymerIdentifier(ItemStack itemStack) {
+        if (itemStack.hasTag()) {
+            return getIdentifierFrom(itemStack.getTag(), POLYMER_ITEM_ID);
+        }
+
+        return null;
+    }
+
+    /**
+     * Returns stored identifier of Polymer/other supported server mod ItemStack. If it's invalid, null is returned instead.
+     */
+    @Nullable
+    public static ResourceLocation getServerIdentifier(ItemStack itemStack) {
+        if (itemStack.hasTag()) {
+            var id = getIdentifierFrom(itemStack.getTag(), POLYMER_ITEM_ID);
+
+            if (id == null) {
+                id = getIdentifierFrom(itemStack.getTag(), "PolyMcId");
+            }
+
+            return id;
+        }
+
+        return null;
+    }
+
+    @Nullable
+    private static ResourceLocation getIdentifierFrom(CompoundTag compound, String nbtKey) {
+        String id = compound.getString(nbtKey);
+        if (id != null && !id.isEmpty()) {
+            return ResourceLocation.tryParse(id);
+        }
+        return null;
+    }
+
+    @Nullable
+    public static CompoundTag getPolymerNbt(ItemStack itemStack) {
+        if (getPolymerIdentifier(itemStack) != null) {
+            if (itemStack.getTag().contains(REAL_TAG, Tag.TAG_COMPOUND)) {
+                return itemStack.getTag().getCompound(REAL_TAG);
+            }
+        }
+
+        return null;
+    }
+
+    public static boolean isPolymerServerItem(ItemStack itemStack) {
+        return shouldPolymerConvert(itemStack, null);
+    }
+
+    private static boolean shouldPolymerConvert(ItemStack itemStack, @Nullable ServerPlayer player) {
+        if (getPolymerIdentifier(itemStack) != null) {
+            return false;
+        }
+        if (itemStack.getItem() instanceof PolymerItem) {
+            return true;
+        } else if (itemStack.hasTag()) {
+            if (itemStack.isEnchanted()) {
+                for (Tag enchantment : itemStack.getEnchantmentTags()) {
+                    String id = ((CompoundTag) enchantment).getString("id");
+
+                    Enchantment ench = BuiltInRegistries.ENCHANTMENT.get(ResourceLocation.tryParse(id));
+
+                    if (ench instanceof PolymerObject) {
+                        if (ench instanceof PolymerSyncedObject polymerEnchantment && polymerEnchantment.getPolymerReplacement(player) == ench) {
+                            continue;
+                        }
+
+                        return true;
+                    }
+                }
+            } else if (itemStack.getTag().contains(EnchantedBookItem.TAG_STORED_ENCHANTMENTS, Tag.TAG_LIST)) {
+                for (Tag enchantment : itemStack.getTag().getList(EnchantedBookItem.TAG_STORED_ENCHANTMENTS, Tag.TAG_COMPOUND)) {
+                    String id = ((CompoundTag) enchantment).getString("id");
+
+                    Enchantment ench = BuiltInRegistries.ENCHANTMENT.get(ResourceLocation.tryParse(id));
+
+                    if (ench instanceof PolymerObject) {
+                        if (ench instanceof PolymerSyncedObject polymerEnchantment && polymerEnchantment.getPolymerReplacement(player) == ench) {
+                            continue;
+                        }
+
+                        return true;
+                    }
+                }
+            } else if (itemStack.getItem() instanceof PotionItem || itemStack.getItem() instanceof TippedArrowItem) {
+                if (PotionUtils.getPotion(itemStack) instanceof PolymerObject) {
+                    return true;
+                }
+
+                for (MobEffectInstance statusEffectInstance : PotionUtils.getMobEffects(itemStack)) {
+                    if (statusEffectInstance.getEffect() instanceof PolymerObject) {
+                        return true;
+                    }
+                }
+            }
+
+            if (itemStack.getTag().contains("ChargedProjectiles", Tag.TAG_LIST)) {
+                for (var itemNbt : itemStack.getTag().getList("ChargedProjectiles", Tag.TAG_COMPOUND)) {
+                    if (shouldPolymerConvert(ItemStack.of((CompoundTag) itemNbt), player)) {
+                        return true;
+                    }
+                }
+            }
+
+            if (itemStack.getTag().contains("Items", Tag.TAG_LIST)) {
+                for (var itemNbt : itemStack.getTag().getList("Items", Tag.TAG_COMPOUND)) {
+                    if (shouldPolymerConvert(ItemStack.of((CompoundTag) itemNbt), player)) {
+                        return true;
+                    }
+                }
+            }
+
+            if (CompatStatus.POLYMER_RESOURCE_PACK) {
+                var display = itemStack.getTagElement("display");
+                if (display != null && display.contains("color", Tag.TAG_INT)) {
+                    var color = display.getInt("color");
+                    return PolymerResourcePackUtils.isColorTaken(color);
+                }
+            }
+        }
+
+
+        return false;
+    }
+
+    /**
+     * This method creates minimal representation of ItemStack
+     *
+     * @param itemStack Server side ItemStack
+     * @param player    Player seeing it
+     * @return Client side ItemStack
+     */
+    public static ItemStack createMinimalItemStack(ItemStack itemStack, @Nullable ServerPlayer player) {
+        Item item = itemStack.getItem();
+        int cmd = -1;
+        if (itemStack.getItem() instanceof PolymerItem virtualItem) {
+            var data = PolymerItemUtils.getItemSafely(virtualItem, itemStack, player);
+            item = data.item();
+            cmd = data.customModelData();
+        }
+
+        ItemStack out = new ItemStack(item, itemStack.getCount());
+
+        if (itemStack.getTag() != null) {
+            out.getOrCreateTag().put(PolymerItemUtils.REAL_TAG, itemStack.getTag());
+        }
+        out.getOrCreateTag().putString(PolymerItemUtils.POLYMER_ITEM_ID, BuiltInRegistries.ITEM.getKey(itemStack.getItem()).toString());
+
+        if (cmd != -1) {
+            out.getOrCreateTag().putInt("CustomModelData", cmd);
+        }
+
+        return out;
+    }
+
+    public static int getSafeColor(int inputColor) {
+        if (inputColor % 2 == 1) {
+            return Math.max(0, inputColor - 1);
+        }
+        return inputColor;
+    }
+
+    /**
+     * This method creates full (vanilla like) representation of ItemStack
+     *
+     * @param itemStack Server side ItemStack
+     * @param player    Player seeing it
+     * @return Client side ItemStack
+     */
+    public static ItemStack createItemStack(ItemStack itemStack, @Nullable ServerPlayer player) {
+        return createItemStack(itemStack, PolymerUtils.getTooltipContext(player), player);
+    }
+
+    /**
+     * This method creates full (vanilla like) representation of ItemStack
+     *
+     * @param itemStack      Server side ItemStack
+     * @param tooltipContext TooltipFlag
+     * @param player         Player seeing it
+     * @return Client side ItemStack
+     */
+    public static ItemStack createItemStack(ItemStack itemStack, TooltipFlag tooltipContext, @Nullable ServerPlayer player) {
+        Item item = itemStack.getItem();
+        int cmd = -1;
+        int color = -1;
+        if (itemStack.getItem() instanceof PolymerItem virtualItem) {
+            var data = PolymerItemUtils.getItemSafely(virtualItem, itemStack, player);
+            item = data.item();
+            cmd = data.customModelData();
+            color = data.color();
+        }
+
+        ItemStack out = new ItemStack(item, itemStack.getCount());
+
+        out.getOrCreateTag().putString(PolymerItemUtils.POLYMER_ITEM_ID, BuiltInRegistries.ITEM.getKey(itemStack.getItem()).toString());
+        out.getTag().putInt("HideFlags", 255);
+
+        ListTag lore = new ListTag();
+
+        if (itemStack.getTag() != null) {
+            out.getTag().put(PolymerItemUtils.REAL_TAG, itemStack.getTag());
+            assert out.getTag() != null;
+            cmd = cmd == -1 && itemStack.getTag().contains("CustomModelData") ? itemStack.getTag().getInt("CustomModelData") : cmd;
+
+            if (color == -1 && itemStack.getTag().contains("display", Tag.TAG_COMPOUND)) {
+                var display = itemStack.getTagElement("display");
+                if (display.contains("color", Tag.TAG_INT)) {
+                    color = display.getInt("color");
+
+                    if (color % 2 == 1) {
+                        color = Math.max(0, color - 1);
+                    }
+                }
+            }
+
+            int dmg = itemStack.getDamageValue();
+            if (dmg != 0) {
+                CompoundTag tag = out.getTag();
+
+                // Organica start - max_damage
+                ItemStack clientItemStack = out;
+                ItemStack serverItemStack = itemStack;
+                // При установке прочности клиентского предмета нужно учитывать,
+                // что она могла быть изменена на серверном уровне вне Polymer.
+                int clientMaxDamage = clientItemStack.getItem().getMaxDamage();
+                var value = clientItemStack.getItem().clientMaxDamage();
+                if (value != null) clientMaxDamage = value;
+                var serverMaxDamage = serverItemStack.getItem().getMaxDamage();
+                var serverDamage = serverItemStack.getDamageValue();
+                var clientDamage = clientMaxDamage * (double) serverDamage / serverMaxDamage;
+
+                clientItemStack.setDamageValue(Mth.ceil(clientDamage));
+                tag = new CompoundTag();  // ignore original putInt("Damage"
+                // Organica end
+
+                tag.putInt("Damage", (int) ((((double) dmg) / itemStack.getItem().getMaxDamage()) * item.getMaxDamage()));
+            }
+
+            if (itemStack.isEnchanted()) {
+                var list = new ListTag();
+                for (var enchNbt : itemStack.getEnchantmentTags()) {
+                    var ench = BuiltInRegistries.ENCHANTMENT.get(EnchantmentHelper.getEnchantmentId((CompoundTag) enchNbt));
+
+                    if (ench instanceof PolymerSyncedObject polyEnch) {
+                        var possible = (Enchantment) polyEnch.getPolymerReplacement(player);
+
+                        if (possible != null) {
+                            list.add(EnchantmentHelper.storeEnchantment(BuiltInRegistries.ENCHANTMENT.getKey(possible), EnchantmentHelper.getEnchantmentLevel((CompoundTag) enchNbt)));
+                        }
+                    } else if (!(ench instanceof PolymerObject)) {
+                        list.add(enchNbt.copy());
+                    }
+                }
+
+                if (list.isEmpty()) {
+                    list.add(new CompoundTag());
+                }
+
+                out.getTag().put(ItemStack.TAG_ENCH, list);
+            } else if (itemStack.hasFoil()) {
+                var list = new ListTag();
+                list.add(new CompoundTag());
+                out.getTag().put(ItemStack.TAG_ENCH, list);
+            }
+
+            if (itemStack.getItem() instanceof PotionItem || itemStack.getItem() instanceof TippedArrowItem) {
+                out.getOrCreateTag().putInt("CustomPotionColor", PotionUtils.getColor(itemStack));
+            }
+
+            for (var i = 0; i < NBT_TO_COPY.length; i++) {
+                var key = NBT_TO_COPY[i];
+                var tag = itemStack.getTag().get(key);
+
+                if (tag != null) {
+                    out.getTag().put(key, tag);
+                }
+            }
+
+            if (CrossbowItem.isCharged(itemStack)) {
+                CrossbowItem.setCharged(out, true);
+            }
+
+            try {
+                if (itemStack.getTag().contains("ChargedProjectiles", Tag.TAG_LIST)) {
+                    var outList = new ListTag();
+
+                    for (var itemNbt : itemStack.getTag().getList("ChargedProjectiles", Tag.TAG_COMPOUND)) {
+                        outList.add(getPolymerItemStack(ItemStack.of((CompoundTag) itemNbt), tooltipContext, player).save(new CompoundTag()));
+                    }
+
+                    out.getTag().put("ChargedProjectiles", outList);
+                }
+            } catch (Throwable e) {
+                if (PolymerImpl.LOG_MORE_ERRORS) {
+                    e.printStackTrace();
+                }
+            }
+
+            try {
+                if (itemStack.getTag().contains("Items", Tag.TAG_LIST)) {
+                    var outList = new ListTag();
+
+                    for (var itemNbt : itemStack.getTag().getList("Items", Tag.TAG_COMPOUND)) {
+                        var base = new CompoundTag();
+                        var slot = ((CompoundTag) itemNbt).get("Slot");
+                        if (slot != null) {
+                            base.put("Slot", slot);
+                        }
+                        outList.add(getPolymerItemStack(ItemStack.of((CompoundTag) itemNbt), tooltipContext, player).save(base));
+                    }
+
+                    out.getTag().put("Items", outList);
+                }
+            } catch (Throwable e) {
+                if (PolymerImpl.LOG_MORE_ERRORS) {
+                    e.printStackTrace();
+                }
+            }
+        } else {
+            if (itemStack.hasFoil()) {
+                var list = new ListTag();
+                list.add(new CompoundTag());
+                out.getTag().put(ItemStack.TAG_ENCH, list);
+            }
+        }
+
+        for (EquipmentSlot slot : EquipmentSlot.values()) {
+            Multimap<Attribute, AttributeModifier> multimap = itemStack.getAttributeModifiers(slot);
+            for (Map.Entry<Attribute, AttributeModifier> entry : multimap.entries()) {
+                out.addAttributeModifier(entry.getKey(), entry.getValue(), slot);
+            }
+        }
+
+        try {
+            List<Component> tooltip = itemStack.getTooltipLines(player, tooltipContext);
+            MutableComponent name = (MutableComponent) tooltip.remove(0);
+
+            if (!out.getDisplayName().equals(name)) {
+                name.setStyle(name.getStyle().applyTo(NON_ITALIC_STYLE));
+                out.setHoverName(name);
+            }
+
+
+            if (itemStack.getItem() instanceof PolymerItem) {
+                ((PolymerItem) itemStack.getItem()).modifyClientTooltip(tooltip, itemStack, player);
+            }
+
+            for (Component t : tooltip) {
+                lore.add(StringTag.valueOf(Component.Serializer.toJson(Component.empty().append(t).setStyle(PolymerItemUtils.CLEAN_STYLE))));
+            }
+        } catch (Throwable e) {
+            if (PolymerImpl.LOG_MORE_ERRORS) {
+                PolymerImpl.LOGGER.error("Failed to get tooltip of " + itemStack, e);
+            }
+
+            // Fallback for mods that require client side methods for tooltips
+            try {
+                MutableComponent name = itemStack.getHoverName().copy();
+
+                if (!out.getHoverName().equals(name)) {
+                    name.setStyle(name.getStyle().applyTo(NON_ITALIC_STYLE));
+                    out.setHoverName(name);
+                }
+            } catch (Throwable e2) {
+                // Fallback for mods that can't even handle names correctly...
+                // Do nothing and hope for the best™
+
+                if (PolymerImpl.LOG_MORE_ERRORS) {
+                    PolymerImpl.LOGGER.error("Failed for second time. Ignoring.", e2);
+
+                }
+            }
+        }
+        var outNbt = out.getOrCreateTag();
+
+        if (lore.size() > 0) {
+            outNbt.getCompound("display").put("Lore", lore);
+        }
+        if (color != -1) {
+            outNbt.getCompound("display").putInt("color", color);
+        }
+        if (cmd != -1) {
+            outNbt.putInt("CustomModelData", cmd);
+        }
+
+        return ITEM_MODIFICATION_EVENT.invoke((col) -> {
+            var custom = out;
+
+            for (var in : col) {
+                custom = in.modifyItem(itemStack, custom, player);
+            }
+
+            return custom;
+        });
+    }
+
+    /**
+     * This method is minimal wrapper around {@link PolymerItem#getPolymerItem(ItemStack, ServerPlayer)} to make sure
+     * It gets replaced if it represents other PolymerItem
+     *
+     * @param item        PolymerItem
+     * @param stack       Server side ItemStack
+     * @param maxDistance Maximum number of checks for nested virtual blocks
+     * @return Client side ItemStack
+     */
+    public static ItemWithMetadata getItemSafely(PolymerItem item, ItemStack stack, @Nullable ServerPlayer player, int maxDistance) {
+        Item out = item.getPolymerItem(stack, player);
+        PolymerItem lastVirtual = item;
+
+        int req = 0;
+        while (out instanceof PolymerItem newItem && newItem != item && req < maxDistance) {
+            out = newItem.getPolymerItem(stack, player);
+            lastVirtual = newItem;
+            req++;
+        }
+        return new ItemWithMetadata(out, lastVirtual.getPolymerCustomModelData(stack, player), lastVirtual.getPolymerArmorColor(stack, player));
+    }
+
+    /**
+     * This method is minimal wrapper around {@link PolymerItem#getPolymerItem(ItemStack, ServerPlayer)} to make sure
+     * It gets replaced if it represents other PolymerItem
+     *
+     * @param item  PolymerItem
+     * @param stack Server side ItemStack
+     * @return Client side ItemStack
+     */
+    public static ItemWithMetadata getItemSafely(PolymerItem item, ItemStack stack, @Nullable ServerPlayer player) {
+        return getItemSafely(item, stack, player, PolymerBlockUtils.NESTED_DEFAULT_DISTANCE);
+    }
+
+    @FunctionalInterface
+    public interface ItemModificationEventHandler {
+        ItemStack modifyItem(ItemStack original, ItemStack client, ServerPlayer player);
+    }
+
+    public record ItemWithMetadata(Item item, int customModelData, int color) {
+    }
+}
diff --git a/src/main/java/eu/pb4/polymer/core/api/item/SimplePolymerItem.java b/src/main/java/eu/pb4/polymer/core/api/item/SimplePolymerItem.java
new file mode 100644
index 0000000000000000000000000000000000000000..12dc1d4cc4a6ea312fea586daf41225555ac2702
--- /dev/null
+++ b/src/main/java/eu/pb4/polymer/core/api/item/SimplePolymerItem.java
@@ -0,0 +1,23 @@
+package eu.pb4.polymer.core.api.item;
+
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.ItemStack;
+import org.jetbrains.annotations.Nullable;
+
+/**
+ * Basic implementation of PolymerItem
+ */
+public class SimplePolymerItem extends Item implements PolymerItem {
+    private final Item polymerItem;
+
+    public SimplePolymerItem(Item.Properties settings, Item polymerItem) {
+        super(settings);
+        this.polymerItem = polymerItem;
+    }
+
+    @Override
+    public Item getPolymerItem(ItemStack itemStack, @Nullable ServerPlayer player) {
+        return this.polymerItem;
+    }
+}
diff --git a/src/main/java/eu/pb4/polymer/core/api/other/PolymerEnchantment.java b/src/main/java/eu/pb4/polymer/core/api/other/PolymerEnchantment.java
new file mode 100644
index 0000000000000000000000000000000000000000..a5d2aad9b807edcdac7d205abcae32bfcaa2eb50
--- /dev/null
+++ b/src/main/java/eu/pb4/polymer/core/api/other/PolymerEnchantment.java
@@ -0,0 +1,17 @@
+package eu.pb4.polymer.core.api.other;
+
+import eu.pb4.polymer.core.api.utils.PolymerSyncedObject;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.item.enchantment.Enchantment;
+import org.jetbrains.annotations.Nullable;
+
+/**
+ * Defaulted interface for Enchantments
+ */
+public interface PolymerEnchantment extends PolymerSyncedObject<Enchantment> {
+    @Nullable
+    @Override
+    default Enchantment getPolymerReplacement(ServerPlayer player) {
+        return null;
+    }
+}
diff --git a/src/main/java/eu/pb4/polymer/core/api/other/PolymerStatusEffect.java b/src/main/java/eu/pb4/polymer/core/api/other/PolymerStatusEffect.java
new file mode 100644
index 0000000000000000000000000000000000000000..e942a70530c674aeeaf7948c352c868f2162caa4
--- /dev/null
+++ b/src/main/java/eu/pb4/polymer/core/api/other/PolymerStatusEffect.java
@@ -0,0 +1,23 @@
+package eu.pb4.polymer.core.api.other;
+
+import eu.pb4.polymer.core.api.utils.PolymerSyncedObject;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.effect.MobEffect;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.Items;
+import org.jetbrains.annotations.Nullable;
+
+public interface PolymerStatusEffect extends PolymerSyncedObject<MobEffect> {
+    @Nullable
+    default ItemStack getPolymerIcon(ServerPlayer player) {
+        var icon = Items.POTION.getDefaultInstance();
+        icon.getOrCreateTag().putInt("CustomPotionColor", ((MobEffect) this).getColor());
+        return icon;
+    }
+
+    @Override
+    @Nullable
+    default MobEffect getPolymerReplacement(ServerPlayer player) {
+        return null;
+    }
+}
diff --git a/src/main/java/eu/pb4/polymer/core/api/utils/PolymerObject.java b/src/main/java/eu/pb4/polymer/core/api/utils/PolymerObject.java
new file mode 100644
index 0000000000000000000000000000000000000000..e54b55bb993533ccaeaed6a3e4323dfe12e4a0c1
--- /dev/null
+++ b/src/main/java/eu/pb4/polymer/core/api/utils/PolymerObject.java
@@ -0,0 +1,17 @@
+package eu.pb4.polymer.core.api.utils;
+
+import java.util.function.Predicate;
+
+/**
+ * Used to mark general polymer objects
+ */
+public interface PolymerObject {
+    Predicate<Object> PREDICATE = (obj) -> obj instanceof PolymerObject;
+    Predicate<Object> PREDICATE_NOT = (obj) -> !(obj instanceof PolymerObject);
+
+    static boolean is(Object obj) {
+        return obj instanceof PolymerObject;
+    }
+
+
+}
diff --git a/src/main/java/eu/pb4/polymer/core/api/utils/PolymerSyncedObject.java b/src/main/java/eu/pb4/polymer/core/api/utils/PolymerSyncedObject.java
new file mode 100644
index 0000000000000000000000000000000000000000..6a8d110e63c24ba47acb99e4ed47a1debad81bc3
--- /dev/null
+++ b/src/main/java/eu/pb4/polymer/core/api/utils/PolymerSyncedObject.java
@@ -0,0 +1,37 @@
+package eu.pb4.polymer.core.api.utils;
+
+import net.minecraft.server.level.ServerPlayer;
+
+/**
+ * Used to mark client-synchronized polymer objects like BlockEntities, Enchantments, Recipes, etc
+ */
+
+public interface PolymerSyncedObject<T> extends PolymerObject {
+
+    /**
+     * Generic method to get polymer replacement sent to player
+     *
+     * @param player target player
+     * @return a replacement. It shouldn't be a null unless specified otherwise
+     */
+    T getPolymerReplacement(ServerPlayer player);
+
+    /**
+     * Allows to gate syncing of this object with clients running polymer
+     */
+    default boolean canSynchronizeToPolymerClient(ServerPlayer player) {
+        return true;
+    }
+
+    /**
+     * Allows to mark it to still send it to supported clients (for client optional setups)
+     * Currently used for tags
+     */
+    default boolean canSyncRawToClient(ServerPlayer player) {
+        return false;
+    }
+
+    static boolean canSyncRawToClient(Object obj, ServerPlayer player) {
+        return obj instanceof PolymerSyncedObject pol ? pol.canSyncRawToClient(player) : !(obj instanceof PolymerObject);
+    }
+}
diff --git a/src/main/java/eu/pb4/polymer/core/api/utils/PolymerUtils.java b/src/main/java/eu/pb4/polymer/core/api/utils/PolymerUtils.java
new file mode 100644
index 0000000000000000000000000000000000000000..59aa0a87112991073cf47ad5d99fc90db164cfb1
--- /dev/null
+++ b/src/main/java/eu/pb4/polymer/core/api/utils/PolymerUtils.java
@@ -0,0 +1,26 @@
+package eu.pb4.polymer.core.api.utils;
+
+import eu.pb4.polymer.core.impl.PolymerImplUtils;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.item.TooltipFlag;
+import org.jetbrains.annotations.Nullable;
+
+public class PolymerUtils {
+    // ...
+
+    /**
+     * Returns current TooltipContext of player,
+     */
+    public static TooltipFlag getTooltipContext(@Nullable ServerPlayer player) {
+        return PolymerImplUtils.getTooltipContext(player);
+    }
+
+    /**
+     * Returns current TooltipContext of player,
+     */
+    public static TooltipFlag getCreativeTooltipContext(@Nullable ServerPlayer player) {
+        return PolymerImplUtils.getTooltipContext(player).withCreative();
+    }
+
+    // ...
+}
diff --git a/src/main/java/eu/pb4/polymer/core/impl/PolymerImpl.java b/src/main/java/eu/pb4/polymer/core/impl/PolymerImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..6af6c9fa8d13804f91ec2cd7cae769103fb2cbb1
--- /dev/null
+++ b/src/main/java/eu/pb4/polymer/core/impl/PolymerImpl.java
@@ -0,0 +1,9 @@
+package eu.pb4.polymer.core.impl;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class PolymerImpl {
+    public static final Logger LOGGER = LoggerFactory.getLogger("Polymer");
+    public static final boolean LOG_MORE_ERRORS = false;
+}
diff --git a/src/main/java/eu/pb4/polymer/core/impl/PolymerImplUtils.java b/src/main/java/eu/pb4/polymer/core/impl/PolymerImplUtils.java
new file mode 100644
index 0000000000000000000000000000000000000000..4c1a539b8055aa2c528263d6516bae11fecbfc7f
--- /dev/null
+++ b/src/main/java/eu/pb4/polymer/core/impl/PolymerImplUtils.java
@@ -0,0 +1,15 @@
+package eu.pb4.polymer.core.impl;
+
+import eu.pb4.polymer.core.impl.interfaces.PolymerNetworkHandlerExtension;
+import eu.pb4.polymer.core.impl.other.PolymerTooltipContext;
+import net.minecraft.server.level.ServerPlayer;
+
+public class PolymerImplUtils {
+
+    public static PolymerTooltipContext getTooltipContext(ServerPlayer player) {
+        return player != null
+                && player.connection instanceof PolymerNetworkHandlerExtension h
+                && h.polymer$advancedTooltip() ? PolymerTooltipContext.ADVANCED : PolymerTooltipContext.BASIC;
+    }
+
+}
diff --git a/src/main/java/eu/pb4/polymer/core/impl/interfaces/PolymerNetworkHandlerExtension.java b/src/main/java/eu/pb4/polymer/core/impl/interfaces/PolymerNetworkHandlerExtension.java
new file mode 100644
index 0000000000000000000000000000000000000000..10596e71f5a3c0613083a751dfcbf0e3dc8b479a
--- /dev/null
+++ b/src/main/java/eu/pb4/polymer/core/impl/interfaces/PolymerNetworkHandlerExtension.java
@@ -0,0 +1,30 @@
+package eu.pb4.polymer.core.impl.interfaces;
+
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.server.network.ServerGamePacketListenerImpl;
+import org.jetbrains.annotations.ApiStatus;
+
+@ApiStatus.Internal
+@SuppressWarnings({"unused"})
+public interface PolymerNetworkHandlerExtension {
+    void polymer$schedulePacket(Packet<?> packet, int duration);
+
+    boolean polymer$advancedTooltip();
+    void polymer$setAdvancedTooltip(boolean value);
+
+    void polymer$delayAction(String identifier, int delay, Runnable action);
+
+//    BlockMapper polymer$getBlockMapper();
+//    void polymer$setBlockMapper(BlockMapper mapper);
+
+    static PolymerNetworkHandlerExtension of(ServerPlayer player) {
+        return (PolymerNetworkHandlerExtension) player.connection;
+    }
+
+    static PolymerNetworkHandlerExtension of(ServerGamePacketListenerImpl handler) {
+        return (PolymerNetworkHandlerExtension) handler;
+    }
+
+    void polymer$delayAfterSequence(Runnable runnable);
+}
diff --git a/src/main/java/eu/pb4/polymer/core/impl/other/PolymerTooltipContext.java b/src/main/java/eu/pb4/polymer/core/impl/other/PolymerTooltipContext.java
new file mode 100644
index 0000000000000000000000000000000000000000..dbbb681f0081ef2b25bb05e7e2297fb677c10fe3
--- /dev/null
+++ b/src/main/java/eu/pb4/polymer/core/impl/other/PolymerTooltipContext.java
@@ -0,0 +1,26 @@
+package eu.pb4.polymer.core.impl.other;
+
+import net.minecraft.world.item.TooltipFlag;
+
+public record PolymerTooltipContext(boolean advanced, boolean creative) implements TooltipFlag {
+    public static final PolymerTooltipContext BASIC = new PolymerTooltipContext(false, false);
+    public static final PolymerTooltipContext ADVANCED = new PolymerTooltipContext(true, false);
+
+    @Override
+    public boolean isAdvanced() {
+        return this.advanced;
+    }
+
+    @Override
+    public boolean isCreative() {
+        return this.creative;
+    }
+
+    public PolymerTooltipContext withCreative() {
+        return new PolymerTooltipContext(this.advanced, true);
+    }
+
+    public static PolymerTooltipContext of(TooltipFlag context) {
+        return new PolymerTooltipContext(context.isAdvanced(), context.isCreative());
+    }
+}
diff --git a/src/main/java/eu/pb4/polymer/resourcepack/api/PolymerArmorModel.java b/src/main/java/eu/pb4/polymer/resourcepack/api/PolymerArmorModel.java
new file mode 100644
index 0000000000000000000000000000000000000000..cf19270e8cb659b92b42dc4afc874577557f6732
--- /dev/null
+++ b/src/main/java/eu/pb4/polymer/resourcepack/api/PolymerArmorModel.java
@@ -0,0 +1,15 @@
+package eu.pb4.polymer.resourcepack.api;
+
+import net.minecraft.resources.ResourceLocation;
+import org.jetbrains.annotations.ApiStatus;
+
+/**
+ * Represents information about armor texture
+ *
+ * Values returned by methods might change in future!
+ */
+@ApiStatus.NonExtendable
+public interface PolymerArmorModel{
+    int color();
+    ResourceLocation modelPath();
+}
diff --git a/src/main/java/eu/pb4/polymer/resourcepack/api/PolymerModelData.java b/src/main/java/eu/pb4/polymer/resourcepack/api/PolymerModelData.java
new file mode 100644
index 0000000000000000000000000000000000000000..4e6eef1f2df61bff33f8cd23a32f0076b42b3697
--- /dev/null
+++ b/src/main/java/eu/pb4/polymer/resourcepack/api/PolymerModelData.java
@@ -0,0 +1,19 @@
+package eu.pb4.polymer.resourcepack.api;
+
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.world.item.Item;
+import org.jetbrains.annotations.ApiStatus;
+
+/**
+ * Represents information about CustomModelData of item
+ *
+ * Values returned by methods might change in future!
+ */
+@ApiStatus.NonExtendable
+public interface PolymerModelData {
+    Item item();
+
+    int value();
+
+    ResourceLocation modelPath();
+}
diff --git a/src/main/java/eu/pb4/polymer/resourcepack/api/PolymerResourcePackUtils.java b/src/main/java/eu/pb4/polymer/resourcepack/api/PolymerResourcePackUtils.java
new file mode 100644
index 0000000000000000000000000000000000000000..eec2d3bf3d8bcf4e943182b19d3815a67896881d
--- /dev/null
+++ b/src/main/java/eu/pb4/polymer/resourcepack/api/PolymerResourcePackUtils.java
@@ -0,0 +1,190 @@
+package eu.pb4.polymer.resourcepack.api;
+
+import eu.pb4.polymer.common.api.events.SimpleEvent;
+import eu.pb4.polymer.common.impl.CommonImpl;
+import eu.pb4.polymer.common.impl.CompatStatus;
+import eu.pb4.polymer.resourcepack.impl.PolymerResourcePackImpl;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.item.Item;
+import org.jetbrains.annotations.Nullable;
+
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.List;
+import java.util.function.Consumer;
+
+/**
+ * Global utilities allowing creation of single, polymer mod compatible resource pack
+ */
+public final class PolymerResourcePackUtils {
+//    public static final Path DEFAULT_PATH = FabricLoader.getInstance().getGameDir().resolve("polymer-resourcepack.zip").toAbsolutePath().normalize();
+
+    private PolymerResourcePackUtils() {
+    }
+
+    private static final ResourcePackCreator INSTANCE = new ResourcePackCreator(PolymerResourcePackImpl.USE_OFFSET ? PolymerResourcePackImpl.OFFSET_VALUES : 1);
+
+    public static final SimpleEvent<Consumer<ResourcePackBuilder>> RESOURCE_PACK_CREATION_EVENT = INSTANCE.creationEvent;
+    public static final SimpleEvent<Consumer<ResourcePackBuilder>> RESOURCE_PACK_AFTER_INITIAL_CREATION_EVENT = INSTANCE.afterInitialCreationEvent;
+    public static final SimpleEvent<Runnable> RESOURCE_PACK_FINISHED_EVENT = INSTANCE.finishedEvent;
+    private static boolean REQUIRED = PolymerResourcePackImpl.FORCE_REQUIRE;
+    private static boolean DEFAULT_CHECK = true;
+
+    /**
+     * This method can be used to register custom model data for items
+     *
+     * @param vanillaItem Vanilla/Client side item
+     * @param modelPath   Path to model in resource pack
+     * @return PolymerModelData with data about this model
+     */
+    public static PolymerModelData requestModel(Item vanillaItem, ResourceLocation modelPath) {
+        return INSTANCE.requestModel(vanillaItem, modelPath);
+    }
+
+    /**
+     * This method can be used to register custom model data for items
+     *
+     * @param modelPath Path to model in resource pack
+     * @return PolymerArmorModel with data about this model
+     */
+    public static PolymerArmorModel requestArmor(ResourceLocation modelPath) {
+        return INSTANCE.requestArmor(modelPath);
+    }
+
+    /**
+     * Adds mod with provided mod id as a source of assets
+     *
+     * @param modId Id of mods used as a source
+     */
+    public static boolean addModAssets(String modId) {
+        return INSTANCE.addAssetSource(modId);
+    }
+
+    /**
+     * Allows to check if there are any provided resources
+     */
+    public static boolean hasResources() {
+        return !INSTANCE.isEmpty();
+    }
+
+    /**
+     * Makes resource pack required
+     */
+    public static void markAsRequired() {
+        REQUIRED = true;
+    }
+
+    /**
+     * Returns if resource pack is required
+     */
+    public static boolean isRequired() {
+        return REQUIRED;
+    }
+
+//    /**
+//     * Allows to check if player has server side resoucepack installed
+//     * However it's impossible to check if it's polymer one or not
+//     *
+//     * @param player Player to check
+//     * @return True if player has a server resourcepack
+//     */
+//    public static boolean hasPack(@Nullable ServerPlayer player) {
+//        return PolymerCommonUtils.hasResourcePack(player);
+//    }
+
+//    /**
+//     * Sets resource pack status of player
+//     *
+//     * @param player Player to change status
+//     * @param status true if player has resource pack, otherwise false
+//     */
+//    public static void setPlayerStatus(ServerPlayer player, boolean status) {
+//        ((CommonResourcePackInfoHolder) player).polymerCommon$setResourcePack(status);
+//        if (player.connection != null) {
+//            ((CommonResourcePackInfoHolder) player.connection).polymerCommon$setResourcePack(status);
+//        }
+//    }
+
+    /**
+     * Returns true if color is taken
+     */
+    public static boolean isColorTaken(int color) {
+        return INSTANCE.isColorTaken(color);
+    }
+
+//    /**
+//     * Gets an unmodifiable list of models for an item.
+//     * This can be useful if you need to extract this list and parse it yourself.
+//     *
+//     * @param item Item you want list for
+//     * @return An unmodifiable list of models
+//     */
+//    public static List<PolymerModelData> getModelsFor(Item item) {
+//        return INSTANCE.getModelsFor(item);
+//    }
+//
+//    public static void disableDefaultCheck() {
+//        DEFAULT_CHECK = false;
+//        CommonImplUtils.disableResourcePackCheck = true;
+//    }
+//
+//    public static boolean shouldCheckByDefault() {
+//        return DEFAULT_CHECK;
+//    }
+//
+//    public static void ignoreNextDefaultCheck(ServerPlayer player) {
+//        ((CommonResourcePackInfoHolder) player.networkHandler).polymerCommon$setIgnoreNextResourcePack();
+//    }
+//
+//    public static ResourcePackBuilder createBuilder(Path output) {
+//        return new DefaultRPBuilder(output);
+//    }
+
+//    public static boolean build() {
+//        return build(PolymerResourcePackUtils.DEFAULT_PATH);
+//    }
+//
+//    public static boolean build(Path output) {
+//        return build(output, (s) -> {});
+//    }
+//
+//    public static boolean build(Path output, Consumer<String> status) {
+//        try {
+//            return INSTANCE.build(output, status);
+//        } catch (Exception e) {
+//            CommonImpl.LOGGER.error("Couldn't create resource pack!");
+//            e.printStackTrace();
+//            return false;
+//        }
+//    }
+
+    static {
+        INSTANCE.creationEvent.register((builder) -> {
+            Path path = CommonImpl.getGameDir().resolve("polymer/source_assets");
+            if (Files.isDirectory(path)) {
+                builder.copyFromPath(path);
+            }
+
+            if (CompatStatus.POLYMC) {
+                try {
+                    Files.createDirectories(path);
+//                    PolyMcHelpers.importPolyMcResources(builder);
+                } catch(Exception e){
+                    e.printStackTrace();
+                }
+            }
+        });
+
+        INSTANCE.afterInitialCreationEvent.register((builder) -> {
+            Path path = CommonImpl.getGameDir().resolve("polymer/override_assets");
+            if (Files.isDirectory(path)) {
+                builder.copyFromPath(path);
+            }
+        });
+    }
+
+//    public static ResourcePackCreator getInstance() {
+//        return INSTANCE;
+//    }
+}
diff --git a/src/main/java/eu/pb4/polymer/resourcepack/api/ResourcePackBuilder.java b/src/main/java/eu/pb4/polymer/resourcepack/api/ResourcePackBuilder.java
new file mode 100644
index 0000000000000000000000000000000000000000..40ff19d718843c999a0b0249924c90f8c4042283
--- /dev/null
+++ b/src/main/java/eu/pb4/polymer/resourcepack/api/ResourcePackBuilder.java
@@ -0,0 +1,22 @@
+package eu.pb4.polymer.resourcepack.api;
+
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.Nullable;
+
+import java.nio.file.Path;
+
+@ApiStatus.NonExtendable
+public interface ResourcePackBuilder {
+    boolean addData(String path, byte[] data);
+    boolean copyAssets(String modId);
+    default boolean copyFromPath(Path path) {
+        return this.copyFromPath(path, true);
+    }
+    boolean copyFromPath(Path path, boolean override);
+    boolean addCustomModelData(PolymerModelData itemModel);
+    boolean addArmorModel(PolymerArmorModel model);
+    @Nullable
+    byte[] getData(String path);
+    @Nullable
+    byte[] getDataOrVanilla(String path);
+}
diff --git a/src/main/java/eu/pb4/polymer/resourcepack/api/ResourcePackCreator.java b/src/main/java/eu/pb4/polymer/resourcepack/api/ResourcePackCreator.java
new file mode 100644
index 0000000000000000000000000000000000000000..c030bf9a41bbab78d917dafd91832cc55bb35ad8
--- /dev/null
+++ b/src/main/java/eu/pb4/polymer/resourcepack/api/ResourcePackCreator.java
@@ -0,0 +1,304 @@
+package eu.pb4.polymer.resourcepack.api;
+
+import com.google.gson.JsonArray;
+import com.google.gson.JsonObject;
+import eu.pb4.polymer.common.api.events.SimpleEvent;
+import eu.pb4.polymer.common.impl.CommonImpl;
+import eu.pb4.polymer.resourcepack.impl.generation.PolymerArmorModelImpl;
+import eu.pb4.polymer.resourcepack.impl.generation.PolymerModelDataImpl;
+import it.unimi.dsi.fastutil.Hash;
+import it.unimi.dsi.fastutil.ints.IntOpenHashSet;
+import it.unimi.dsi.fastutil.ints.IntSet;
+import it.unimi.dsi.fastutil.objects.Object2IntMap;
+import it.unimi.dsi.fastutil.objects.Object2IntOpenCustomHashMap;
+import it.unimi.dsi.fastutil.objects.Object2ObjectOpenCustomHashMap;
+import it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap;
+import net.minecraft.Util;
+import net.minecraft.network.chat.Component;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.world.item.Item;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.Nullable;
+
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Path;
+import java.util.*;
+import java.util.Map.Entry;
+import java.util.concurrent.ExecutionException;
+import java.util.function.Consumer;
+import net.minecraft.SharedConstants;
+
+/**
+ * Utilities allowing simple creation of resource pack
+ */
+public final class ResourcePackCreator {
+    private static enum IdentityHashStrategy implements Hash.Strategy<Object> {
+        INSTANCE;
+
+        private IdentityHashStrategy() {
+        }
+
+        public int hashCode(Object o) {
+            return System.identityHashCode(o);
+        }
+
+        public boolean equals(Object o, Object o2) {
+            return o == o2;
+        }
+    }
+    public static <K> Hash.Strategy<K> identityHashStrategy() {
+        return (Hash.Strategy<K>) IdentityHashStrategy.INSTANCE;
+    }
+    public final SimpleEvent<Consumer<ResourcePackBuilder>> creationEvent = new SimpleEvent<>();
+    public final SimpleEvent<Runnable> finishedEvent = new SimpleEvent<>();
+    public final SimpleEvent<Consumer<ResourcePackBuilder>> afterInitialCreationEvent = new SimpleEvent<>();
+    private final Map<Item, List<PolymerModelData>> items = new Object2ObjectOpenCustomHashMap<>(identityHashStrategy());
+    private final Object2IntMap<Item> itemIds = new Object2IntOpenCustomHashMap<>(identityHashStrategy());
+    private final Map<Item, Map<ResourceLocation, PolymerModelData>> itemModels = new Object2ObjectOpenCustomHashMap<>(identityHashStrategy());
+//    private final Map<Item, List<ItemOverride>> itemOverrides = new Object2ObjectOpenCustomHashMap<>(Util.identityHashStrategy());
+
+    private final Set<String> modIds = new HashSet<>();
+    private final IntSet takenArmorColors = new IntOpenHashSet();
+    private final Map<ResourceLocation, PolymerArmorModel> armorModelMap = new HashMap<>();
+    private final int cmdOffset;
+    private int armorColor = 0;
+    private Component packDescription = null;
+    private byte[] packIcon = null;
+    private Set<Path> sourcePaths = new HashSet<>();
+
+    public static ResourcePackCreator create() {
+        return new ResourcePackCreator(0);
+    }
+
+    protected ResourcePackCreator(int cmdOffset) {
+        this.cmdOffset = cmdOffset;
+        this.itemIds.defaultReturnValue(1);
+    }
+
+    /**
+     * This method can be used to register custom model data for items
+     *
+     * @param vanillaItem Vanilla/Client side item
+     * @param modelPath   Path to model in resource pack
+     * @return PolymerModelData with data about this model
+     */
+    public PolymerModelData requestModel(Item vanillaItem, ResourceLocation modelPath) {
+        var map = this.itemModels.computeIfAbsent(vanillaItem, (x) -> new Object2ObjectOpenHashMap<>());
+
+        if (map.containsKey(modelPath)) {
+            return map.get(modelPath);
+        } else {
+            return this.forceDefineModel(vanillaItem, this.itemIds.getInt(vanillaItem), modelPath, true);
+        }
+    }
+
+//    /**
+//     * This method can be used to define custom overrides items
+//     *
+//     * @param item Vanilla/Client side item
+//     * @param override Override that needs to be added
+//     * @return PolymerModelData with data about this model
+//     */
+//    public void defineOverride(Item item, ItemOverride override) {
+//        this.itemOverrides.computeIfAbsent(item, (x) -> new ArrayList<>()).add(override);
+//    }
+
+    /**
+     * This method can be used to register custom model data for items.
+     * Use this method only if you really need to preserve ids
+     *
+     * @param vanillaItem Vanilla/Client side item
+     * @param customModelData forced CMD
+     * @param modelPath   Path to model in resource pack
+     * @param respectOffset Whatever output CustomModelData should have offset added
+     * @return PolymerModelData with data about this model
+     */
+    @ApiStatus.Experimental
+    public PolymerModelData forceDefineModel(Item vanillaItem, int customModelData, ResourceLocation modelPath, boolean respectOffset) {
+        var map = this.itemModels.computeIfAbsent(vanillaItem, (x) -> new Object2ObjectOpenHashMap<>());
+
+        var cmdInfoList = this.items.computeIfAbsent(vanillaItem, (x) -> new ArrayList<>());
+        var cmdInfo = new PolymerModelDataImpl(vanillaItem, customModelData + (respectOffset ? this.cmdOffset : 0), modelPath);
+        cmdInfoList.add(cmdInfo);
+        this.itemIds.put(vanillaItem, Math.max(this.itemIds.getInt(vanillaItem), customModelData + 1));
+        map.put(modelPath, cmdInfo);
+        return cmdInfo;
+    }
+
+    /**
+     * This method can be used to register custom model data for items
+     *
+     * @param modelPath Path to model in resource pack
+     * @return PolymerArmorModel with data about this model
+     */
+    public PolymerArmorModel requestArmor(ResourceLocation modelPath) {
+        if (this.armorModelMap.containsKey(modelPath)) {
+            return this.armorModelMap.get(modelPath);
+        } else {
+            this.armorColor++;
+            int color = 0xFFFFFF - armorColor * 2 + 1;
+            var model = new PolymerArmorModelImpl(color, modelPath);
+
+            this.armorModelMap.put(modelPath, model);
+            this.takenArmorColors.add(color);
+            return model;
+        }
+    }
+
+    /**
+     * Adds mod with provided mod id as a source of assets
+     *
+     * @param modId Id of mods used as a source
+     */
+    public boolean addAssetSource(String modId) {
+        if (CommonImpl.isModLoaded(modId)) {
+            this.modIds.add(modId);
+            return true;
+        }
+
+        return false;
+    }
+
+    /**
+     * Adds mod with provided mod id as a source of assets
+     *
+     * @param sourcePath Path to a source
+     */
+    public boolean addAssetSource(Path sourcePath) {
+        return this.sourcePaths.add(sourcePath);
+    }
+
+    /**
+     * Returns true if color is taken
+     */
+    public boolean isColorTaken(int color) {
+        return takenArmorColors.contains(color & 0xFFFFFF);
+    }
+
+    /**
+     * Gets an unmodifiable list of models for an item.
+     * This can be useful if you need to extract this list and parse it yourself.
+     *
+     * @param item Item you want list for
+     * @return An unmodifiable list of models
+     */
+    public List<PolymerModelData> getModelsFor(Item item) {
+        return Collections.unmodifiableList(items.getOrDefault(item, Collections.emptyList()));
+    }
+
+    /**
+     * Sets pack description
+     *
+     * @param description new description
+     */
+    public void setPackDescription(String description) {
+        this.packDescription = Component.literal(description);
+    }
+
+    /**
+     * Sets pack description
+     *
+     * @param description new description
+     */
+    public void setPackDescription(Component description) {
+        this.packDescription = description;
+    }
+
+    @Nullable
+    public Component getPackDescription() {
+        return this.packDescription;
+    }
+
+    /**
+     * Sets icon of pack
+     *
+     * @param packIcon bytes representing png image of icon
+     */
+    public void setPackIcon(byte[] packIcon) {
+        this.packIcon = packIcon;
+    }
+
+    @Nullable
+    public byte[] getPackIcon() {
+        return packIcon;
+    }
+
+    public boolean isEmpty() {
+        return this.items.isEmpty() && this.modIds.isEmpty() && this.armorModelMap.isEmpty() && this.creationEvent.isEmpty();
+    }
+
+//    public boolean build(Path output) throws ExecutionException, InterruptedException {
+//        return build(output, (s) -> {});
+//    }
+//
+//    public boolean build(Path output, Consumer<String> status) throws ExecutionException, InterruptedException {
+//        boolean successful = true;
+//
+//        var builder = new DefaultRPBuilder(output);
+//        status.accept("action:created_builder");
+//
+//        if (this.packDescription != null) {
+//            var obj = new JsonObject();
+//
+//            var pack = new JsonObject();
+//            pack.addProperty("pack_format", SharedConstants.RESOURCE_PACK_VERSION);
+//            pack.add("description", Component.Serializer.toJsonTree(this.packDescription));
+//
+//            obj.add("pack", pack);
+//            builder.addData("pack.mcmeta", obj.toString().getBytes(StandardCharsets.UTF_8));
+//        }
+//
+//
+//        if (this.packIcon != null) {
+//            builder.addData("pack.png", this.packIcon);
+//        }
+//
+//        status.accept("action:creation_event_start");
+//        this.creationEvent.invoke((x) -> x.accept(builder));
+//        status.accept("action:creation_event_finish");
+//
+//        for (var path : this.sourcePaths) {
+//            status.accept("action:copy_path_start/" + path);
+//            successful = builder.copyFromPath(path) && successful;
+//            status.accept("action:copy_path_end/" + path);
+//        }
+//
+//        for (String modId : this.modIds) {
+//            status.accept("action:copy_mod_start/" + modId);
+//            successful = builder.copyAssets(modId) && successful;
+//            status.accept("action:copy_mod_end/" + modId);
+//        }
+//
+//        status.accept("action:copy_overrides_start");
+//        for (var entry : this.itemOverrides.entrySet()) {
+//            var x = builder.getCustomModels(entry.getKey(), DefaultRPBuilder.OverridePlace.BEFORE_CUSTOM_MODEL_DATA);
+//            entry.getValue().forEach(a -> x.add(a.toJson()));
+//        }
+//        status.accept("action:copy_overrides_finish");
+//
+//        for (var cmdInfoList : this.items.values()) {
+//            status.accept("action:custom_model_data_start");
+//            for (PolymerModelData cmdInfo : cmdInfoList) {
+//                builder.addCustomModelData(cmdInfo);
+//            }
+//            status.accept("action:add_custom_model_data_finish");
+//        }
+//
+//        status.accept("action:custom_armors_start");
+//        for (var armor : this.armorModelMap.values()) {
+//            builder.addArmorModel(armor);
+//        }
+//        status.accept("action:custom_armors_finish");
+//
+//        status.accept("action:late_creation_event_start");
+//        this.afterInitialCreationEvent.invoke((x) -> x.accept(builder));
+//        status.accept("action:late_creation_event_finish");
+//
+//        status.accept("action:build");
+//        successful = builder.buildResourcePack().get() && successful;
+//
+//        status.accept("action:done");
+//        this.finishedEvent.invoke(Runnable::run);
+//        return successful;
+//    }
+}
diff --git a/src/main/java/eu/pb4/polymer/resourcepack/impl/PolymerResourcePackImpl.java b/src/main/java/eu/pb4/polymer/resourcepack/impl/PolymerResourcePackImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..5e3c880226b0acb4c22d6330a7c9daf9ac19f324
--- /dev/null
+++ b/src/main/java/eu/pb4/polymer/resourcepack/impl/PolymerResourcePackImpl.java
@@ -0,0 +1,40 @@
+package eu.pb4.polymer.resourcepack.impl;
+
+import com.google.gson.annotations.SerializedName;
+import eu.pb4.polymer.common.impl.CommonImpl;
+import eu.pb4.polymer.common.impl.CompatStatus;
+
+public class PolymerResourcePackImpl {
+    public static final boolean FORCE_REQUIRE;
+    public static final boolean USE_OFFSET;
+    public static final int OFFSET_VALUES;
+    public static final boolean USE_ALT_ARMOR_HANDLER;
+
+
+    static {
+        var config = CommonImpl.loadConfig("resource-pack", Config.class);
+
+        FORCE_REQUIRE = config.markResourcePackAsRequiredByDefault || CompatStatus.POLYMC;
+
+        USE_OFFSET = config.forcePackOffset || CompatStatus.POLYMC;
+
+        OFFSET_VALUES = config.offsetValue;
+
+        USE_ALT_ARMOR_HANDLER = config.useAlternativeArmorHandler || CompatStatus.REQUIRE_ALT_ARMOR_HANDLER;
+    }
+
+
+    public static class Config {
+        public String _c1 = "Marks resource pack as required, only effects clients and mods using api to check it";
+        public boolean markResourcePackAsRequiredByDefault = false;
+
+        public String _c2 = "Force-enables offset of CustomModelData";
+        public boolean forcePackOffset = false;
+
+        public String _c3 = "Value of CustomModelData offset when enabled";
+        public int offsetValue = 100000;
+        public String _c4 = "Enables usage of alternative armor rendering for increased mod compatibility";
+        @SerializedName("use_alternative_armor_rendering")
+        public boolean useAlternativeArmorHandler;
+    }
+}
diff --git a/src/main/java/eu/pb4/polymer/resourcepack/impl/generation/PolymerArmorModelImpl.java b/src/main/java/eu/pb4/polymer/resourcepack/impl/generation/PolymerArmorModelImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..25d229e769021bf00fa9c828273e002adffffb1d
--- /dev/null
+++ b/src/main/java/eu/pb4/polymer/resourcepack/impl/generation/PolymerArmorModelImpl.java
@@ -0,0 +1,7 @@
+package eu.pb4.polymer.resourcepack.impl.generation;
+
+import eu.pb4.polymer.resourcepack.api.PolymerArmorModel;
+import net.minecraft.resources.ResourceLocation;
+
+public record PolymerArmorModelImpl(int color, ResourceLocation modelPath) implements PolymerArmorModel {
+}
diff --git a/src/main/java/eu/pb4/polymer/resourcepack/impl/generation/PolymerModelDataImpl.java b/src/main/java/eu/pb4/polymer/resourcepack/impl/generation/PolymerModelDataImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..68cd1a0cc19bbcf38ca8a23a721d58b972432cb5
--- /dev/null
+++ b/src/main/java/eu/pb4/polymer/resourcepack/impl/generation/PolymerModelDataImpl.java
@@ -0,0 +1,8 @@
+package eu.pb4.polymer.resourcepack.impl.generation;
+
+import eu.pb4.polymer.resourcepack.api.PolymerModelData;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.world.item.Item;
+
+public record PolymerModelDataImpl(Item item, int value, ResourceLocation modelPath) implements PolymerModelData {
+}
diff --git a/src/main/java/net/fabricmc/fabric/api/entity/event/v1/ServerEntityWorldChangeEvents.java b/src/main/java/net/fabricmc/fabric/api/entity/event/v1/ServerEntityWorldChangeEvents.java
new file mode 100644
index 0000000000000000000000000000000000000000..e976d8f372b8fbff7ff4a4d4d87d3657bea4650d
--- /dev/null
+++ b/src/main/java/net/fabricmc/fabric/api/entity/event/v1/ServerEntityWorldChangeEvents.java
@@ -0,0 +1,28 @@
+package net.fabricmc.fabric.api.entity.event.v1;
+
+import net.fabricmc.fabric.api.event.Event;
+import net.fabricmc.fabric.api.event.EventFactory;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.ServerPlayer;
+
+public class ServerEntityWorldChangeEvents {
+
+    public static final Event<AfterPlayerChange> AFTER_PLAYER_CHANGE_WORLD = EventFactory.createArrayBacked(AfterPlayerChange.class, callbacks -> (player, origin, destination) -> {
+        for (AfterPlayerChange callback : callbacks) {
+            callback.afterChangeWorld(player, origin, destination);
+        }
+    });
+
+    @FunctionalInterface
+    public interface AfterPlayerChange {
+        /**
+         * Called after a player has been moved to different world.
+         *
+         * @param player the player
+         * @param origin the original world the player was in
+         * @param destination the new world the player was moved to
+         */
+        void afterChangeWorld(ServerPlayer player, ServerLevel origin, ServerLevel destination);
+    }
+
+}
diff --git a/src/main/java/net/fabricmc/fabric/api/event/Event.java b/src/main/java/net/fabricmc/fabric/api/event/Event.java
new file mode 100644
index 0000000000000000000000000000000000000000..d67db0c6313c3768b82116242140c4a3fc2e7279
--- /dev/null
+++ b/src/main/java/net/fabricmc/fabric/api/event/Event.java
@@ -0,0 +1,90 @@
+/*
+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.fabric.api.event;
+
+import net.minecraft.resources.ResourceLocation;
+import org.jetbrains.annotations.ApiStatus;
+
+/**
+ * Base class for Fabric's event implementations.
+ *
+ * @param <T> The listener type.
+ * @see EventFactory
+ */
+@ApiStatus.NonExtendable // Should only be extended by fabric API.
+public abstract class Event<T> {
+    /**
+     * The invoker field. This should be updated by the implementation to
+     * always refer to an instance containing all code that should be
+     * executed upon event emission.
+     */
+    protected volatile T invoker;
+
+    /**
+     * Returns the invoker instance.
+     *
+     * <p>An "invoker" is an object which hides multiple registered
+     * listeners of type T under one instance of type T, executing
+     * them and leaving early as necessary.
+     *
+     * @return The invoker instance.
+     */
+    public final T invoker() {
+        return invoker;
+    }
+
+    /**
+     * Register a listener to the event, in the default phase.
+     * Have a look at {@link #addPhaseOrdering} for an explanation of event phases.
+     *
+     * @param listener The desired listener.
+     */
+    public abstract void register(T listener);
+
+    /**
+     * The identifier of the default phase.
+     * Have a look at {@link EventFactory#createWithPhases} for an explanation of event phases.
+     */
+    public static final ResourceLocation DEFAULT_PHASE = new ResourceLocation("fabric", "default");
+
+    /**
+     * Register a listener to the event for the specified phase.
+     * Have a look at {@link EventFactory#createWithPhases} for an explanation of event phases.
+     *
+     * @param phase ResourceLocation of the phase this listener should be registered for. It will be created if it didn't exist yet.
+     * @param listener The desired listener.
+     */
+    public void register(ResourceLocation phase, T listener) {
+        // This is done to keep compatibility with existing Event subclasses, but they should really not be subclassing Event.
+        register(listener);
+    }
+
+    /**
+     * Request that listeners registered for one phase be executed before listeners registered for another phase.
+     * Relying on the default phases supplied to {@link EventFactory#createWithPhases} should be preferred over manually
+     * registering phase ordering dependencies.
+     *
+     * <p>Incompatible ordering constraints such as cycles will lead to inconsistent behavior:
+     * some constraints will be respected and some will be ignored. If this happens, a warning will be logged.
+     *
+     * @param firstPhase The identifier of the phase that should run before the other. It will be created if it didn't exist yet.
+     * @param secondPhase The identifier of the phase that should run after the other. It will be created if it didn't exist yet.
+     */
+    public void addPhaseOrdering(ResourceLocation firstPhase, ResourceLocation secondPhase) {
+        // This is not abstract to avoid breaking existing Event subclasses, but they should really not be subclassing Event.
+    }
+}
diff --git a/src/main/java/net/fabricmc/fabric/api/event/EventFactory.java b/src/main/java/net/fabricmc/fabric/api/event/EventFactory.java
new file mode 100644
index 0000000000000000000000000000000000000000..2417b124d8823627128fc50b39869c5e169f5dce
--- /dev/null
+++ b/src/main/java/net/fabricmc/fabric/api/event/EventFactory.java
@@ -0,0 +1,137 @@
+/*
+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.fabric.api.event;
+
+import java.util.function.Function;
+import net.fabricmc.fabric.impl.base.event.EventFactoryImpl;
+import net.minecraft.resources.ResourceLocation;
+
+/**
+ * Helper for creating {@link Event} classes.
+ */
+public final class EventFactory {
+    private EventFactory() { }
+
+    /**
+     * Create an "array-backed" Event instance.
+     *
+     * <p>If your factory simply delegates to the listeners without adding custom behavior,
+     * consider using {@linkplain #createArrayBacked(Class, Object, Function) the other overload}
+     * if performance of this event is critical.
+     *
+     * @param type           The listener class type.
+     * @param invokerFactory The invoker factory, combining multiple listeners into one instance.
+     * @param <T>            The listener type.
+     * @return The Event instance.
+     */
+    public static <T> Event<T> createArrayBacked(Class<? super T> type, Function<T[], T> invokerFactory) {
+        return EventFactoryImpl.createArrayBacked(type, invokerFactory);
+    }
+
+    /**
+     * Create an "array-backed" Event instance with a custom empty invoker,
+     * for an event whose {@code invokerFactory} only delegates to the listeners.
+     * <ul>
+     *   <li>If there is no listener, the custom empty invoker will be used.</li>
+     *   <li><b>If there is only one listener, that one will be used as the invoker
+     *   and the factory will not be called.</b></li>
+     *   <li>Only when there are at least two listeners will the factory be used.</li>
+     * </ul>
+     *
+     * <p>Having a custom empty invoker (of type (...) -&gt; {}) increases performance
+     * relative to iterating over an empty array; however, it only really matters
+     * if the event is executed thousands of times a second.
+     *
+     * @param type           The listener class type.
+     * @param emptyInvoker   The custom empty invoker.
+     * @param invokerFactory The invoker factory, combining multiple listeners into one instance.
+     * @param <T>            The listener type.
+     * @return The Event instance.
+     */
+    public static <T> Event<T> createArrayBacked(Class<T> type, T emptyInvoker, Function<T[], T> invokerFactory) {
+        return createArrayBacked(type, listeners -> {
+            if (listeners.length == 0) {
+                return emptyInvoker;
+            } else if (listeners.length == 1) {
+                return listeners[0];
+            } else {
+                return invokerFactory.apply(listeners);
+            }
+        });
+    }
+
+    /**
+     * Create an array-backed event with a list of default phases that get invoked in order.
+     * Exposing the identifiers of the default phases as {@code public static final} constants is encouraged.
+     *
+     * <p>An event phase is a named group of listeners, which may be ordered before or after other groups of listeners.
+     * This allows some listeners to take priority over other listeners.
+     * Adding separate events should be considered before making use of multiple event phases.
+     *
+     * <p>Phases may be freely added to events created with any of the factory functions,
+     * however using this function is preferred for widely used event phases.
+     * If more phases are necessary, discussion with the author of the Event is encouraged.
+     *
+     * <p>Refer to {@link Event#addPhaseOrdering} for an explanation of event phases.
+     *
+     * @param type           The listener class type.
+     * @param invokerFactory The invoker factory, combining multiple listeners into one instance.
+     * @param defaultPhases  The default phases of this event, in the correct order. Must contain {@link Event#DEFAULT_PHASE}.
+     * @param <T>            The listener type.
+     * @return The Event instance.
+     */
+    public static <T> Event<T> createWithPhases(Class<? super T> type, Function<T[], T> invokerFactory, ResourceLocation... defaultPhases) {
+        EventFactoryImpl.ensureContainsDefault(defaultPhases);
+        EventFactoryImpl.ensureNoDuplicates(defaultPhases);
+
+        Event<T> event = createArrayBacked(type, invokerFactory);
+
+        for (int i = 1; i < defaultPhases.length; ++i) {
+            event.addPhaseOrdering(defaultPhases[i-1], defaultPhases[i]);
+        }
+
+        return event;
+    }
+
+    /**
+     * @deprecated This is not to be used in events anymore.
+     */
+    @Deprecated
+    public static String getHandlerName(Object handler) {
+        return handler.getClass().getName();
+    }
+
+    /**
+     * @deprecated Always returns {@code false}, do not use. This is not to be used in events anymore, standard Java profilers will do fine.
+     */
+    @Deprecated
+    public static boolean isProfilingEnabled() {
+        return false;
+    }
+
+    /**
+     * Invalidate and re-create all existing "invoker" instances across
+     * events created by this EventFactory. Use this if, for instance,
+     * the profilingEnabled field changes.
+     *
+     * @deprecated Do not use, will be removed in a future release.
+     */
+    @Deprecated(forRemoval = true)
+    public static void invalidate() {
+        EventFactoryImpl.invalidate();
+    }
+}
diff --git a/src/main/java/net/fabricmc/fabric/api/itemgroup/v1/FabricItemGroupEntries.java b/src/main/java/net/fabricmc/fabric/api/itemgroup/v1/FabricItemGroupEntries.java
new file mode 100644
index 0000000000000000000000000000000000000000..0d2e38ed07ac9aeb344ba454718ae2d2bf13731e
--- /dev/null
+++ b/src/main/java/net/fabricmc/fabric/api/itemgroup/v1/FabricItemGroupEntries.java
@@ -0,0 +1,506 @@
+/*
+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.fabric.api.itemgroup.v1;
+
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.List;
+import java.util.function.Predicate;
+
+import net.minecraft.world.flag.FeatureFlagSet;
+import net.minecraft.world.item.CreativeModeTab;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.level.ItemLike;
+import org.jetbrains.annotations.ApiStatus;
+
+/**
+ * This class allows the entries of {@linkplain CreativeModeTab item groups} to be modified by the events in {@link ItemGroupEvents}.
+ */
+public class FabricItemGroupEntries implements CreativeModeTab.Output {
+    private final CreativeModeTab.ItemDisplayParameters context;
+    private final List<ItemStack> displayStacks;
+    private final List<ItemStack> searchTabStacks;
+
+    @ApiStatus.Internal
+    public FabricItemGroupEntries(CreativeModeTab.ItemDisplayParameters context, List<ItemStack> displayStacks, List<ItemStack> searchTabStacks) {
+        this.context = context;
+        this.displayStacks = displayStacks;
+        this.searchTabStacks = searchTabStacks;
+    }
+
+    public CreativeModeTab.ItemDisplayParameters getContext() {
+        return context;
+    }
+
+    /**
+     * @return the currently enabled feature set
+     */
+    public FeatureFlagSet getEnabledFeatures() {
+        return context.enabledFeatures();
+    }
+
+    /**
+     * @return whether to show items restricted to operators, such as command blocks
+     */
+    public boolean shouldShowOpRestrictedItems() {
+        return context.hasPermissions();
+    }
+
+    /**
+     * @return the stacks that will be shown in the tab in the creative mode inventory
+     * @apiNote This list can be modified.
+     */
+    public List<ItemStack> getDisplayStacks() {
+        return displayStacks;
+    }
+
+    /**
+     * @return the stacks that will be searched by the creative mode inventory search
+     * @apiNote This list can be modified.
+     */
+    public List<ItemStack> getSearchTabStacks() {
+        return searchTabStacks;
+    }
+
+    /**
+     * Adds a stack to the end of the item group. Duplicate stacks will be removed.
+     *
+     * @param visibility Determines whether the stack will be shown in the tab itself, returned
+     *                   for searches, or both.
+     */
+    @Override
+    public void accept(ItemStack stack, CreativeModeTab.TabVisibility visibility) {
+        if (isEnabled(stack)) {
+            checkStack(stack);
+
+            switch (visibility) {
+                case PARENT_AND_SEARCH_TABS -> {
+                    this.displayStacks.add(stack);
+                    this.searchTabStacks.add(stack);
+                }
+                case PARENT_TAB_ONLY -> this.displayStacks.add(stack);
+                case SEARCH_TAB_ONLY -> this.searchTabStacks.add(stack);
+            }
+        }
+    }
+
+    /**
+     * See {@link #prepend(ItemStack, CreativeModeTab.TabVisibility)}. Will use {@link CreativeModeTab.TabVisibility#PARENT_AND_SEARCH_TABS}
+     * for visibility.
+     */
+    public void prepend(ItemStack stack) {
+        prepend(stack, CreativeModeTab.TabVisibility.PARENT_AND_SEARCH_TABS);
+    }
+
+    /**
+     * Adds a stack to the beginning of the item group. Duplicate stacks will be removed.
+     *
+     * @param visibility Determines whether the stack will be shown in the tab itself, returned
+     *                   for searches, or both.
+     */
+    public void prepend(ItemStack stack, CreativeModeTab.TabVisibility visibility) {
+        if (isEnabled(stack)) {
+            checkStack(stack);
+
+            switch (visibility) {
+                case PARENT_AND_SEARCH_TABS -> {
+                    this.displayStacks.add(0, stack);
+                    this.searchTabStacks.add(0, stack);
+                }
+                case PARENT_TAB_ONLY -> this.displayStacks.add(0, stack);
+                case SEARCH_TAB_ONLY -> this.searchTabStacks.add(0, stack);
+            }
+        }
+    }
+
+    /**
+     * See {@link #prepend(ItemStack)}. Automatically creates an {@link ItemStack} from the given item.
+     */
+    public void prepend(ItemLike item) {
+        prepend(item, CreativeModeTab.TabVisibility.PARENT_AND_SEARCH_TABS);
+    }
+
+    /**
+     * See {@link #prepend(ItemStack, net.minecraft.world.item.CreativeModeTab.TabVisibility)}.
+     * Automatically creates an {@link ItemStack} from the given item.
+     */
+    public void prepend(ItemLike item, CreativeModeTab.TabVisibility visibility) {
+        prepend(new ItemStack(item), visibility);
+    }
+
+    /**
+     * See {@link #addAfter(ItemLike, Collection)}.
+     */
+    public void addAfter(ItemLike afterLast, ItemStack... newStack) {
+        addAfter(afterLast, Arrays.asList(newStack));
+    }
+
+    /**
+     * See {@link #addAfter(ItemStack, Collection)}.
+     */
+    public void addAfter(ItemStack afterLast, ItemStack... newStack) {
+        addAfter(afterLast, Arrays.asList(newStack));
+    }
+
+    /**
+     * See {@link #addAfter(ItemLike, Collection)}.
+     */
+    public void addAfter(ItemLike afterLast, ItemLike... newItem) {
+        addAfter(afterLast, Arrays.stream(newItem).map(ItemStack::new).toList());
+    }
+
+    /**
+     * See {@link #addAfter(ItemStack, Collection)}.
+     */
+    public void addAfter(ItemStack afterLast, ItemLike... newItem) {
+        addAfter(afterLast, Arrays.stream(newItem).map(ItemStack::new).toList());
+    }
+
+    /**
+     * See {@link #addAfter(ItemLike, Collection, net.minecraft.world.item.CreativeModeTab.TabVisibility)}.
+     */
+    public void addAfter(ItemLike afterLast, Collection<ItemStack> newStacks) {
+        addAfter(afterLast, newStacks, CreativeModeTab.TabVisibility.PARENT_AND_SEARCH_TABS);
+    }
+
+    /**
+     * See {@link #addAfter(ItemStack, Collection, net.minecraft.world.item.CreativeModeTab.TabVisibility)}.
+     */
+    public void addAfter(ItemStack afterLast, Collection<ItemStack> newStacks) {
+        addAfter(afterLast, newStacks, CreativeModeTab.TabVisibility.PARENT_AND_SEARCH_TABS);
+    }
+
+    /**
+     * Adds stacks after an existing item in the group, or at the end, if the item isn't in the group.
+     *
+     * @param afterLast  Add {@code newStacks} after the last entry of this item in the group.
+     * @param newStacks  The stacks to add. Only {@linkplain #isEnabled(ItemStack) enabled} stacks will be added.
+     * @param visibility Determines whether the stack will be shown in the tab itself, returned
+     *                   for searches, or both.
+     */
+    public void addAfter(ItemLike afterLast, Collection<ItemStack> newStacks, CreativeModeTab.TabVisibility visibility) {
+        newStacks = getEnabledStacks(newStacks);
+
+        if (newStacks.isEmpty()) {
+            return;
+        }
+
+        switch (visibility) {
+            case PARENT_AND_SEARCH_TABS -> {
+                addAfter(afterLast, newStacks, displayStacks);
+                addAfter(afterLast, newStacks, searchTabStacks);
+            }
+            case PARENT_TAB_ONLY -> addAfter(afterLast, newStacks, displayStacks);
+            case SEARCH_TAB_ONLY -> addAfter(afterLast, newStacks, searchTabStacks);
+        }
+    }
+
+    /**
+     * Adds stacks after an existing stack in the group, or at the end, if the stack isn't in the group.
+     *
+     * @param afterLast  Add {@code newStacks} after the last group entry matching this stack (compared using {@link ItemStack#isSameItemSameTags}).
+     * @param newStacks  The stacks to add. Only {@linkplain #isEnabled(ItemStack) enabled} stacks will be added.
+     * @param visibility Determines whether the stack will be shown in the tab itself, returned
+     *                   for searches, or both.
+     */
+    public void addAfter(ItemStack afterLast, Collection<ItemStack> newStacks, CreativeModeTab.TabVisibility visibility) {
+        newStacks = getEnabledStacks(newStacks);
+
+        if (newStacks.isEmpty()) {
+            return;
+        }
+
+        switch (visibility) {
+            case PARENT_AND_SEARCH_TABS -> {
+                addAfter(afterLast, newStacks, displayStacks);
+                addAfter(afterLast, newStacks, searchTabStacks);
+            }
+            case PARENT_TAB_ONLY -> addAfter(afterLast, newStacks, displayStacks);
+            case SEARCH_TAB_ONLY -> addAfter(afterLast, newStacks, searchTabStacks);
+        }
+    }
+
+    /**
+     * Adds stacks after the last group entry matching a predicate, or at the end, if no entries match.
+     *
+     * @param afterLast  Add {@code newStacks} after the last group entry matching this predicate.
+     * @param newStacks  The stacks to add. Only {@linkplain #isEnabled(ItemStack) enabled} stacks will be added.
+     * @param visibility Determines whether the stack will be shown in the tab itself, returned
+     *                   for searches, or both.
+     */
+    public void addAfter(Predicate<ItemStack> afterLast, Collection<ItemStack> newStacks, CreativeModeTab.TabVisibility visibility) {
+        newStacks = getEnabledStacks(newStacks);
+
+        if (newStacks.isEmpty()) {
+            return;
+        }
+
+        switch (visibility) {
+            case PARENT_AND_SEARCH_TABS -> {
+                addAfter(afterLast, newStacks, displayStacks);
+                addAfter(afterLast, newStacks, searchTabStacks);
+            }
+            case PARENT_TAB_ONLY -> addAfter(afterLast, newStacks, displayStacks);
+            case SEARCH_TAB_ONLY -> addAfter(afterLast, newStacks, searchTabStacks);
+        }
+    }
+
+    /**
+     * See {@link #addBefore(ItemLike, Collection)}.
+     */
+    public void addBefore(ItemLike beforeFirst, ItemStack... newStack) {
+        addBefore(beforeFirst, Arrays.asList(newStack));
+    }
+
+    /**
+     * See {@link #addBefore(ItemStack, Collection)}.
+     */
+    public void addBefore(ItemStack beforeFirst, ItemStack... newStack) {
+        addBefore(beforeFirst, Arrays.asList(newStack));
+    }
+
+    /**
+     * See {@link #addBefore(ItemLike, Collection)}.
+     */
+    public void addBefore(ItemLike beforeFirst, ItemLike... newItem) {
+        addBefore(beforeFirst, Arrays.stream(newItem).map(ItemStack::new).toList());
+    }
+
+    /**
+     * See {@link #addBefore(ItemStack, Collection)}.
+     */
+    public void addBefore(ItemStack beforeFirst, ItemLike... newItem) {
+        addBefore(beforeFirst, Arrays.stream(newItem).map(ItemStack::new).toList());
+    }
+
+    /**
+     * See {@link #addBefore(ItemLike, Collection, net.minecraft.world.item.CreativeModeTab.TabVisibility)}.
+     */
+    public void addBefore(ItemLike beforeFirst, Collection<ItemStack> newStacks) {
+        addBefore(beforeFirst, newStacks, CreativeModeTab.TabVisibility.PARENT_AND_SEARCH_TABS);
+    }
+
+    /**
+     * See {@link #addBefore(ItemStack, Collection, net.minecraft.world.item.CreativeModeTab.TabVisibility)}.
+     */
+    public void addBefore(ItemStack beforeFirst, Collection<ItemStack> newStacks) {
+        addBefore(beforeFirst, newStacks, CreativeModeTab.TabVisibility.PARENT_AND_SEARCH_TABS);
+    }
+
+    /**
+     * Adds stacks before an existing item in the group, or at the end, if the item isn't in the group.
+     *
+     * @param beforeFirst Add {@code newStacks} before the first entry of this item in the group.
+     * @param newStacks   The stacks to add. Only {@linkplain #isEnabled(ItemStack) enabled} stacks will be added.
+     * @param visibility  Determines whether the stack will be shown in the tab itself, returned
+     *                    for searches, or both.
+     */
+    public void addBefore(ItemLike beforeFirst, Collection<ItemStack> newStacks, CreativeModeTab.TabVisibility visibility) {
+        newStacks = getEnabledStacks(newStacks);
+
+        if (newStacks.isEmpty()) {
+            return;
+        }
+
+        switch (visibility) {
+            case PARENT_AND_SEARCH_TABS -> {
+                addBefore(beforeFirst, newStacks, displayStacks);
+                addBefore(beforeFirst, newStacks, searchTabStacks);
+            }
+            case PARENT_TAB_ONLY -> addBefore(beforeFirst, newStacks, displayStacks);
+            case SEARCH_TAB_ONLY -> addBefore(beforeFirst, newStacks, searchTabStacks);
+        }
+    }
+
+    /**
+     * Adds stacks before an existing stack to the group, or at the end, if the stack isn't in the group.
+     *
+     * @param beforeFirst Add {@code newStacks} before the first group entry matching this stack (compared using {@link ItemStack#isSameItemSameTags}).
+     * @param newStacks   The stacks to add. Only {@linkplain #isEnabled(ItemStack) enabled} stacks will be added.
+     * @param visibility  Determines whether the stack will be shown in the tab itself, returned
+     *                    for searches, or both.
+     */
+    public void addBefore(ItemStack beforeFirst, Collection<ItemStack> newStacks, CreativeModeTab.TabVisibility visibility) {
+        newStacks = getEnabledStacks(newStacks);
+
+        if (newStacks.isEmpty()) {
+            return;
+        }
+
+        switch (visibility) {
+            case PARENT_AND_SEARCH_TABS -> {
+                addBefore(beforeFirst, newStacks, displayStacks);
+                addBefore(beforeFirst, newStacks, searchTabStacks);
+            }
+            case PARENT_TAB_ONLY -> addBefore(beforeFirst, newStacks, displayStacks);
+            case SEARCH_TAB_ONLY -> addBefore(beforeFirst, newStacks, searchTabStacks);
+        }
+    }
+
+    /**
+     * Adds stacks before the first group entry matching a predicate, or at the end, if no entries match.
+     *
+     * @param beforeFirst Add {@code newStacks} before the first group entry matching this predicate.
+     * @param newStacks   The stacks to add. Only {@linkplain #isEnabled(ItemStack) enabled} stacks will be added.
+     * @param visibility  Determines whether the stack will be shown in the tab itself, returned
+     *                    for searches, or both.
+     */
+    public void addBefore(Predicate<ItemStack> beforeFirst, Collection<ItemStack> newStacks, CreativeModeTab.TabVisibility visibility) {
+        newStacks = getEnabledStacks(newStacks);
+
+        if (newStacks.isEmpty()) {
+            return;
+        }
+
+        switch (visibility) {
+            case PARENT_AND_SEARCH_TABS -> {
+                addBefore(beforeFirst, newStacks, displayStacks);
+                addBefore(beforeFirst, newStacks, searchTabStacks);
+            }
+            case PARENT_TAB_ONLY -> addBefore(beforeFirst, newStacks, displayStacks);
+            case SEARCH_TAB_ONLY -> addBefore(beforeFirst, newStacks, searchTabStacks);
+        }
+    }
+
+    /**
+     * @return True if the item of a given stack is enabled in the current {@link FeatureFlagSet}.
+     * @see Item#isEnabled
+     */
+    private boolean isEnabled(ItemStack stack) {
+        return stack.getItem().isEnabled(getEnabledFeatures());
+    }
+
+    private Collection<ItemStack> getEnabledStacks(Collection<ItemStack> newStacks) {
+        // If not all stacks are enabled, filter the list, otherwise use it as-is
+        if (newStacks.stream().allMatch(this::isEnabled)) {
+            return newStacks;
+        }
+
+        return newStacks.stream().filter(this::isEnabled).toList();
+    }
+
+    /**
+     * Adds the {@link ItemStack} before the first match, if no matches the {@link ItemStack} is appended to the end of the {@link CreativeModeTab}.
+     */
+    private static void addBefore(Predicate<ItemStack> predicate, Collection<ItemStack> newStacks, List<ItemStack> addTo) {
+        checkStacks(newStacks);
+
+        for (int i = 0; i < addTo.size(); i++) {
+            if (predicate.test(addTo.get(i))) {
+                addTo.subList(i, i).addAll(newStacks);
+                return;
+            }
+        }
+
+        // Anchor not found, add to end
+        addTo.addAll(newStacks);
+    }
+
+    private static void addAfter(Predicate<ItemStack> predicate, Collection<ItemStack> newStacks, List<ItemStack> addTo) {
+        checkStacks(newStacks);
+
+        // Iterate in reverse to add after the last match
+        for (int i = addTo.size() - 1; i >= 0; i--) {
+            if (predicate.test(addTo.get(i))) {
+                addTo.subList(i + 1, i + 1).addAll(newStacks);
+                return;
+            }
+        }
+
+        // Anchor not found, add to end
+        addTo.addAll(newStacks);
+    }
+
+    private static void addBefore(ItemStack anchor, Collection<ItemStack> newStacks, List<ItemStack> addTo) {
+        checkStacks(newStacks);
+
+        for (int i = 0; i < addTo.size(); i++) {
+            if (ItemStack.isSameItemSameTags(anchor, addTo.get(i))) {
+                addTo.subList(i, i).addAll(newStacks);
+                return;
+            }
+        }
+
+        // Anchor not found, add to end
+        addTo.addAll(newStacks);
+    }
+
+    private static void addAfter(ItemStack anchor, Collection<ItemStack> newStacks, List<ItemStack> addTo) {
+        checkStacks(newStacks);
+
+        // Iterate in reverse to add after the last match
+        for (int i = addTo.size() - 1; i >= 0; i--) {
+            if (ItemStack.isSameItemSameTags(anchor, addTo.get(i))) {
+                addTo.subList(i + 1, i + 1).addAll(newStacks);
+                return;
+            }
+        }
+
+        // Anchor not found, add to end
+        addTo.addAll(newStacks);
+    }
+
+    private static void addBefore(ItemLike anchor, Collection<ItemStack> newStacks, List<ItemStack> addTo) {
+        checkStacks(newStacks);
+
+        Item anchorItem = anchor.asItem();
+
+        for (int i = 0; i < addTo.size(); i++) {
+            if (addTo.get(i).is(anchorItem)) {
+                addTo.subList(i, i).addAll(newStacks);
+                return;
+            }
+        }
+
+        // Anchor not found, add to end
+        addTo.addAll(newStacks);
+    }
+
+    private static void addAfter(ItemLike anchor, Collection<ItemStack> newStacks, List<ItemStack> addTo) {
+        checkStacks(newStacks);
+
+        Item anchorItem = anchor.asItem();
+
+        // Iterate in reverse to add after the last match
+        for (int i = addTo.size() - 1; i >= 0; i--) {
+            if (addTo.get(i).is(anchorItem)) {
+                addTo.subList(i + 1, i + 1).addAll(newStacks);
+                return;
+            }
+        }
+
+        // Anchor not found, add to end
+        addTo.addAll(newStacks);
+    }
+
+    private static void checkStacks(Collection<ItemStack> stacks) {
+        for (ItemStack stack : stacks) {
+            checkStack(stack);
+        }
+    }
+
+    private static void checkStack(ItemStack stack) {
+        if (stack.isEmpty()) {
+            throw new IllegalArgumentException("Cannot add empty stack");
+        }
+
+        if (stack.getCount() != 1) {
+            throw new IllegalArgumentException("Stack size must be exactly 1 for stack: " + stack);
+        }
+    }
+}
diff --git a/src/main/java/net/fabricmc/fabric/api/itemgroup/v1/ItemGroupEvents.java b/src/main/java/net/fabricmc/fabric/api/itemgroup/v1/ItemGroupEvents.java
new file mode 100644
index 0000000000000000000000000000000000000000..569428377afa6387c6dd2ccfa3a5a31df4facbe5
--- /dev/null
+++ b/src/main/java/net/fabricmc/fabric/api/itemgroup/v1/ItemGroupEvents.java
@@ -0,0 +1,23 @@
+package net.fabricmc.fabric.api.itemgroup.v1;
+
+import net.fabricmc.fabric.api.event.Event;
+import net.fabricmc.fabric.impl.itemgroup.ItemGroupEventsImpl;
+import net.minecraft.resources.ResourceKey;
+import net.minecraft.world.item.CreativeModeTab;
+
+public class ItemGroupEvents {
+
+    public static Event<ModifyEntries> modifyEntriesEvent(ResourceKey<CreativeModeTab> registryKey) {
+        return ItemGroupEventsImpl.getOrCreateModifyEntriesEvent(registryKey);
+    }
+
+    @FunctionalInterface
+    public interface ModifyEntries {
+        /**
+         * Modifies the item group entries.
+         * @param entries the entries
+         * @see FabricItemGroupEntries
+         */
+        void modifyEntries(FabricItemGroupEntries entries);
+    }
+}
diff --git a/src/main/java/net/fabricmc/fabric/impl/base/event/ArrayBackedEvent.java b/src/main/java/net/fabricmc/fabric/impl/base/event/ArrayBackedEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..0c56cbf84659329226ef6702b164f68d6de085af
--- /dev/null
+++ b/src/main/java/net/fabricmc/fabric/impl/base/event/ArrayBackedEvent.java
@@ -0,0 +1,124 @@
+/*
+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.fabric.impl.base.event;
+
+import java.lang.reflect.Array;
+import java.util.ArrayList;
+import java.util.Comparator;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Objects;
+import java.util.function.Function;
+import net.fabricmc.fabric.api.event.Event;
+import net.fabricmc.fabric.impl.base.toposort.NodeSorting;
+import net.minecraft.resources.ResourceLocation;
+
+class ArrayBackedEvent<T> extends Event<T> {
+    private final Function<T[], T> invokerFactory;
+    private final Object lock = new Object();
+    private T[] handlers;
+    /**
+     * Registered event phases.
+     */
+    private final Map<ResourceLocation, EventPhaseData<T>> phases = new LinkedHashMap<>();
+    /**
+     * Phases sorted in the correct dependency order.
+     */
+    private final List<EventPhaseData<T>> sortedPhases = new ArrayList<>();
+
+    @SuppressWarnings("unchecked")
+    ArrayBackedEvent(Class<? super T> type, Function<T[], T> invokerFactory) {
+        this.invokerFactory = invokerFactory;
+        this.handlers = (T[]) Array.newInstance(type, 0);
+        update();
+    }
+
+    void update() {
+        this.invoker = invokerFactory.apply(handlers);
+    }
+
+    @Override
+    public void register(T listener) {
+        register(DEFAULT_PHASE, listener);
+    }
+
+    @Override
+    public void register(ResourceLocation phaseIdentifier, T listener) {
+        Objects.requireNonNull(phaseIdentifier, "Tried to register a listener for a null phase!");
+        Objects.requireNonNull(listener, "Tried to register a null listener!");
+
+        synchronized (lock) {
+            getOrCreatePhase(phaseIdentifier, true).addListener(listener);
+            rebuildInvoker(handlers.length + 1);
+        }
+    }
+
+    private EventPhaseData<T> getOrCreatePhase(ResourceLocation id, boolean sortIfCreate) {
+        EventPhaseData<T> phase = phases.get(id);
+
+        if (phase == null) {
+            phase = new EventPhaseData<>(id, handlers.getClass().getComponentType());
+            phases.put(id, phase);
+            sortedPhases.add(phase);
+
+            if (sortIfCreate) {
+                NodeSorting.sort(sortedPhases, "event phases", Comparator.comparing(data -> data.id));
+            }
+        }
+
+        return phase;
+    }
+
+    private void rebuildInvoker(int newLength) {
+        // Rebuild handlers.
+        if (sortedPhases.size() == 1) {
+            // Special case with a single phase: use the array of the phase directly.
+            handlers = sortedPhases.get(0).listeners;
+        } else {
+            @SuppressWarnings("unchecked")
+            T[] newHandlers = (T[]) Array.newInstance(handlers.getClass().getComponentType(), newLength);
+            int newHandlersIndex = 0;
+
+            for (EventPhaseData<T> existingPhase : sortedPhases) {
+                int length = existingPhase.listeners.length;
+                System.arraycopy(existingPhase.listeners, 0, newHandlers, newHandlersIndex, length);
+                newHandlersIndex += length;
+            }
+
+            handlers = newHandlers;
+        }
+
+        // Rebuild invoker.
+        update();
+    }
+
+    @Override
+    public void addPhaseOrdering(ResourceLocation firstPhase, ResourceLocation secondPhase) {
+        Objects.requireNonNull(firstPhase, "Tried to add an ordering for a null phase.");
+        Objects.requireNonNull(secondPhase, "Tried to add an ordering for a null phase.");
+        if (firstPhase.equals(secondPhase)) throw new IllegalArgumentException("Tried to add a phase that depends on itself.");
+
+        synchronized (lock) {
+            EventPhaseData<T> first = getOrCreatePhase(firstPhase, false);
+            EventPhaseData<T> second = getOrCreatePhase(secondPhase, false);
+            EventPhaseData.link(first, second);
+            NodeSorting.sort(this.sortedPhases, "event phases", Comparator.comparing(data -> data.id));
+            rebuildInvoker(handlers.length);
+        }
+    }
+}
diff --git a/src/main/java/net/fabricmc/fabric/impl/base/event/EventFactoryImpl.java b/src/main/java/net/fabricmc/fabric/impl/base/event/EventFactoryImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..c825249ceb5250954ce2e2a805c487cb3c1762e5
--- /dev/null
+++ b/src/main/java/net/fabricmc/fabric/impl/base/event/EventFactoryImpl.java
@@ -0,0 +1,123 @@
+/*
+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.fabric.impl.base.event;
+
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.MethodType;
+import java.lang.reflect.Array;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.lang.reflect.Proxy;
+import java.util.Collections;
+import java.util.Set;
+import java.util.function.Function;
+
+import com.google.common.collect.MapMaker;
+import net.fabricmc.fabric.api.event.Event;
+import net.minecraft.resources.ResourceLocation;
+
+public final class EventFactoryImpl {
+    private static final Set<ArrayBackedEvent<?>> ARRAY_BACKED_EVENTS
+            = Collections.newSetFromMap(new MapMaker().weakKeys().makeMap());
+
+    private EventFactoryImpl() { }
+
+    public static void invalidate() {
+        ARRAY_BACKED_EVENTS.forEach(ArrayBackedEvent::update);
+    }
+
+    public static <T> Event<T> createArrayBacked(Class<? super T> type, Function<T[], T> invokerFactory) {
+        ArrayBackedEvent<T> event = new ArrayBackedEvent<>(type, invokerFactory);
+        ARRAY_BACKED_EVENTS.add(event);
+        return event;
+    }
+
+    public static void ensureContainsDefault(ResourceLocation[] defaultPhases) {
+        for (ResourceLocation id : defaultPhases) {
+            if (id.equals(Event.DEFAULT_PHASE)) {
+                return;
+            }
+        }
+
+        throw new IllegalArgumentException("The event phases must contain Event.DEFAULT_PHASE.");
+    }
+
+    public static void ensureNoDuplicates(ResourceLocation[] defaultPhases) {
+        for (int i = 0; i < defaultPhases.length; ++i) {
+            for (int j = i+1; j < defaultPhases.length; ++j) {
+                if (defaultPhases[i].equals(defaultPhases[j])) {
+                    throw new IllegalArgumentException("Duplicate event phase: " + defaultPhases[i]);
+                }
+            }
+        }
+    }
+
+    // Code originally by sfPlayer1.
+    // Unfortunately, it's slightly slower than just passing an empty array in the first place.
+    private static <T> T buildEmptyInvoker(Class<T> handlerClass, Function<T[], T> invokerSetup) {
+        // find the functional interface method
+        Method funcIfMethod = null;
+
+        for (Method m : handlerClass.getMethods()) {
+            if ((m.getModifiers() & (Modifier.STRICT | Modifier.PRIVATE)) == 0) {
+                if (funcIfMethod != null) {
+                    throw new IllegalStateException("Multiple virtual methods in " + handlerClass + "; cannot build empty invoker!");
+                }
+
+                funcIfMethod = m;
+            }
+        }
+
+        if (funcIfMethod == null) {
+            throw new IllegalStateException("No virtual methods in " + handlerClass + "; cannot build empty invoker!");
+        }
+
+        Object defValue = null;
+
+        try {
+            // concert to mh, determine its type without the "this" reference
+            MethodHandle target = MethodHandles.lookup().unreflect(funcIfMethod);
+            MethodType type = target.type().dropParameterTypes(0, 1);
+
+            if (type.returnType() != void.class) {
+                // determine default return value by invoking invokerSetup.apply(T[0]) with all-jvm-default args (null for refs, false for boolean, etc.)
+                // explicitCastArguments is being used to cast Object=null to the jvm default value for the correct type
+
+                // construct method desc (TLjava/lang/Object;Ljava/lang/Object;...)R where T = invoker ref ("this"), R = invoker ret type and args 1+ are Object for each non-"this" invoker arg
+                MethodType objTargetType = MethodType.genericMethodType(type.parameterCount()).changeReturnType(type.returnType()).insertParameterTypes(0, target.type().parameterType(0));
+                // explicit cast to translate to the invoker args from Object to their real type, inferring jvm default values
+                MethodHandle objTarget = MethodHandles.explicitCastArguments(target, objTargetType);
+
+                // build invocation args with 0 = "this", 1+ = null
+                Object[] args = new Object[target.type().parameterCount()];
+                //noinspection unchecked
+                args[0] = invokerSetup.apply((T[]) Array.newInstance(handlerClass, 0));
+
+                // retrieve default by invoking invokerSetup.apply(T[0]).targetName(def,def,...)
+                defValue = objTarget.invokeWithArguments(args);
+            }
+        } catch (Throwable t) {
+            throw new RuntimeException(t);
+        }
+
+        final Object returnValue = defValue;
+        //noinspection unchecked
+        return (T) Proxy.newProxyInstance(EventFactoryImpl.class.getClassLoader(), new Class[]{handlerClass},
+                (proxy, method, args) -> returnValue);
+    }
+}
diff --git a/src/main/java/net/fabricmc/fabric/impl/base/event/EventPhaseData.java b/src/main/java/net/fabricmc/fabric/impl/base/event/EventPhaseData.java
new file mode 100644
index 0000000000000000000000000000000000000000..a044fa603b997fb838fadad6e37709b4d979ec0d
--- /dev/null
+++ b/src/main/java/net/fabricmc/fabric/impl/base/event/EventPhaseData.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.fabric.impl.base.event;
+
+import java.lang.reflect.Array;
+import java.util.Arrays;
+import net.fabricmc.fabric.impl.base.toposort.SortableNode;
+import net.minecraft.resources.ResourceLocation;
+
+/**
+ * Data of an {@link ArrayBackedEvent} phase.
+ */
+class EventPhaseData<T> extends SortableNode<EventPhaseData<T>> {
+    final ResourceLocation id;
+    T[] listeners;
+
+    @SuppressWarnings("unchecked")
+    EventPhaseData(ResourceLocation id, Class<?> listenerClass) {
+        this.id = id;
+        this.listeners = (T[]) Array.newInstance(listenerClass, 0);
+    }
+
+    void addListener(T listener) {
+        int oldLength = listeners.length;
+        listeners = Arrays.copyOf(listeners, oldLength + 1);
+        listeners[oldLength] = listener;
+    }
+
+    @Override
+    protected String getDescription() {
+        return id.toString();
+    }
+}
diff --git a/src/main/java/net/fabricmc/fabric/impl/base/toposort/NodeSorting.java b/src/main/java/net/fabricmc/fabric/impl/base/toposort/NodeSorting.java
new file mode 100644
index 0000000000000000000000000000000000000000..f8fbe26a63e84e6bbfb7d6f9767f964f33130df6
--- /dev/null
+++ b/src/main/java/net/fabricmc/fabric/impl/base/toposort/NodeSorting.java
@@ -0,0 +1,190 @@
+/*
+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.fabric.impl.base.toposort;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.IdentityHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.PriorityQueue;
+
+import com.google.common.annotations.VisibleForTesting;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Contains a topological sort implementation, with tie breaking using a {@link Comparator}.
+ *
+ * <p>The final order is always deterministic (i.e. doesn't change with the order of the input elements or the edges),
+ * assuming that they are all different according to the comparator. This also holds in the presence of cycles.
+ *
+ * <p>The steps are as follows:
+ * <ol>
+ *     <li>Compute node SCCs (Strongly Connected Components, i.e. cycles).</li>
+ *     <li>Sort nodes within SCCs using the comparator.</li>
+ *     <li>Sort SCCs with respect to each other by respecting constraints, and using the comparator in case of a tie.</li>
+ * </ol>
+ */
+public class NodeSorting {
+    private static final Logger LOGGER = LoggerFactory.getLogger("fabric-api-base");
+
+    @VisibleForTesting
+    public static boolean ENABLE_CYCLE_WARNING = true;
+
+    /**
+     * Sort a list of nodes.
+     *
+     * @param sortedNodes The list of nodes to sort. Will be modified in-place.
+     * @param elementDescription A description of the elements, used for logging in the presence of cycles.
+     * @param comparator The comparator to break ties and to order elements within a cycle.
+     * @return {@code true} if all the constraints were satisfied, {@code false} if there was at least one cycle.
+     */
+    public static <N extends SortableNode<N>> boolean sort(List<N> sortedNodes, String elementDescription, Comparator<N> comparator) {
+        // FIRST KOSARAJU SCC VISIT
+        List<N> toposort = new ArrayList<>(sortedNodes.size());
+
+        for (N node : sortedNodes) {
+            forwardVisit(node, null, toposort);
+        }
+
+        clearStatus(toposort);
+        Collections.reverse(toposort);
+
+        // SECOND KOSARAJU SCC VISIT
+        Map<N, NodeScc<N>> nodeToScc = new IdentityHashMap<>();
+
+        for (N node : toposort) {
+            if (!node.visited) {
+                List<N> sccNodes = new ArrayList<>();
+                // Collect nodes in SCC.
+                backwardVisit(node, sccNodes);
+                // Sort nodes by id.
+                sccNodes.sort(comparator);
+                // Mark nodes as belonging to this SCC.
+                NodeScc<N> scc = new NodeScc<>(sccNodes);
+
+                for (N nodeInScc : sccNodes) {
+                    nodeToScc.put(nodeInScc, scc);
+                }
+            }
+        }
+
+        clearStatus(toposort);
+
+        // Build SCC graph
+        for (NodeScc<N> scc : nodeToScc.values()) {
+            for (N node : scc.nodes) {
+                for (N subsequentNode : node.subsequentNodes) {
+                    NodeScc<N> subsequentScc = nodeToScc.get(subsequentNode);
+
+                    if (subsequentScc != scc) {
+                        scc.subsequentSccs.add(subsequentScc);
+                        subsequentScc.inDegree++;
+                    }
+                }
+            }
+        }
+
+        // Order SCCs according to priorities. When there is a choice, use the SCC with the lowest id.
+        // The priority queue contains all SCCs that currently have 0 in-degree.
+        PriorityQueue<NodeScc<N>> pq = new PriorityQueue<>(Comparator.comparing(scc -> scc.nodes.get(0), comparator));
+        sortedNodes.clear();
+
+        for (NodeScc<N> scc : nodeToScc.values()) {
+            if (scc.inDegree == 0) {
+                pq.add(scc);
+                // Prevent adding the same SCC multiple times, as nodeToScc may contain the same value multiple times.
+                scc.inDegree = -1;
+            }
+        }
+
+        boolean noCycle = true;
+
+        while (!pq.isEmpty()) {
+            NodeScc<N> scc = pq.poll();
+            sortedNodes.addAll(scc.nodes);
+
+            if (scc.nodes.size() > 1) {
+                noCycle = false;
+
+                if (ENABLE_CYCLE_WARNING) {
+                    // Print cycle warning
+                    StringBuilder builder = new StringBuilder();
+                    builder.append("Found cycle while sorting ").append(elementDescription).append(":\n");
+
+                    for (N node : scc.nodes) {
+                        builder.append("\t").append(node.getDescription()).append("\n");
+                    }
+
+                    LOGGER.warn(builder.toString());
+                }
+            }
+
+            for (NodeScc<N> subsequentScc : scc.subsequentSccs) {
+                subsequentScc.inDegree--;
+
+                if (subsequentScc.inDegree == 0) {
+                    pq.add(subsequentScc);
+                }
+            }
+        }
+
+        return noCycle;
+    }
+
+    private static <N extends SortableNode<N>> void forwardVisit(N node, N parent, List<N> toposort) {
+        if (!node.visited) {
+            // Not yet visited.
+            node.visited = true;
+
+            for (N data : node.subsequentNodes) {
+                forwardVisit(data, node, toposort);
+            }
+
+            toposort.add(node);
+        }
+    }
+
+    private static <N extends SortableNode<N>> void clearStatus(List<N> nodes) {
+        for (N node : nodes) {
+            node.visited = false;
+        }
+    }
+
+    private static <N extends SortableNode<N>> void backwardVisit(N node, List<N> sccNodes) {
+        if (!node.visited) {
+            node.visited = true;
+            sccNodes.add(node);
+
+            for (N data : node.previousNodes) {
+                backwardVisit(data, sccNodes);
+            }
+        }
+    }
+
+    private static class NodeScc<N extends SortableNode<N>> {
+        final List<N> nodes;
+        final List<NodeScc<N>> subsequentSccs = new ArrayList<>();
+        int inDegree = 0;
+
+        private NodeScc(List<N> nodes) {
+            this.nodes = nodes;
+        }
+    }
+}
diff --git a/src/main/java/net/fabricmc/fabric/impl/base/toposort/SortableNode.java b/src/main/java/net/fabricmc/fabric/impl/base/toposort/SortableNode.java
new file mode 100644
index 0000000000000000000000000000000000000000..fbbdc0c67b513efc925c278ca08dbbd2874adb13
--- /dev/null
+++ b/src/main/java/net/fabricmc/fabric/impl/base/toposort/SortableNode.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.fabric.impl.base.toposort;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public abstract class SortableNode<N extends SortableNode<N>> {
+    final List<N> subsequentNodes = new ArrayList<>();
+    final List<N> previousNodes = new ArrayList<>();
+    boolean visited = false;
+
+    /**
+     * @return Description of this node, used to print the cycle warning.
+     */
+    protected abstract String getDescription();
+
+    public static <N extends SortableNode<N>> void link(N first, N second) {
+        if (first == second) {
+            throw new IllegalArgumentException("Cannot link a node to itself!");
+        }
+
+        first.subsequentNodes.add(second);
+        second.previousNodes.add(first);
+    }
+}
diff --git a/src/main/java/net/fabricmc/fabric/impl/itemgroup/ItemGroupEventsImpl.java b/src/main/java/net/fabricmc/fabric/impl/itemgroup/ItemGroupEventsImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..690b581cdf860c7df87705eb751bedcd9cdbc988
--- /dev/null
+++ b/src/main/java/net/fabricmc/fabric/impl/itemgroup/ItemGroupEventsImpl.java
@@ -0,0 +1,32 @@
+package net.fabricmc.fabric.impl.itemgroup;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import net.minecraft.resources.ResourceKey;
+import net.minecraft.world.item.CreativeModeTab;
+import org.jetbrains.annotations.Nullable;
+import net.fabricmc.fabric.api.event.Event;
+import net.fabricmc.fabric.api.event.EventFactory;
+import net.fabricmc.fabric.api.itemgroup.v1.ItemGroupEvents;
+
+public class ItemGroupEventsImpl {
+    private static final Map<ResourceKey<CreativeModeTab>, Event<ItemGroupEvents.ModifyEntries>> ITEM_GROUP_EVENT_MAP = new HashMap<>();
+
+    public static Event<ItemGroupEvents.ModifyEntries> getOrCreateModifyEntriesEvent(ResourceKey<CreativeModeTab> registryKey) {
+        return ITEM_GROUP_EVENT_MAP.computeIfAbsent(registryKey, (g -> createModifyEvent()));
+    }
+
+    @Nullable
+    public static Event<ItemGroupEvents.ModifyEntries> getModifyEntriesEvent(ResourceKey<CreativeModeTab> registryKey) {
+        return ITEM_GROUP_EVENT_MAP.get(registryKey);
+    }
+
+    private static Event<ItemGroupEvents.ModifyEntries> createModifyEvent() {
+        return EventFactory.createArrayBacked(ItemGroupEvents.ModifyEntries.class, callbacks -> (entries) -> {
+            for (ItemGroupEvents.ModifyEntries callback : callbacks) {
+                callback.modifyEntries(entries);
+            }
+        });
+    }
+}
diff --git a/src/main/java/net/fabricmc/yarn/constants/MiningLevels.java b/src/main/java/net/fabricmc/yarn/constants/MiningLevels.java
new file mode 100644
index 0000000000000000000000000000000000000000..155896eece8859cde8c377e3f711f9d65be8c260
--- /dev/null
+++ b/src/main/java/net/fabricmc/yarn/constants/MiningLevels.java
@@ -0,0 +1,50 @@
+/*
+ * This file is free for everyone to use under the Creative Commons Zero license.
+ */
+
+package net.fabricmc.yarn.constants;
+
+/**
+ * Constants of Mining Levels.
+ * <p>Mining levels are used by blocks to determine the strength of the tools required to successfully harvest them.
+ * <br>All tool materials have an assigned mining level. If a tool's mining level is equal to or greater than the block's,
+ * the tool will apply its efficiency bonus and the block will drop its loot table.
+ * <p>Blocks without mining levels, or items that aren't tools, use {@link MiningLevels#HAND}.
+ * @see net.minecraft.world.item.Tier#getLevel() ToolMaterial#getMiningLevel
+ */
+public final class MiningLevels {
+    /**
+     * Blocks with this level do not require a tool to harvest.
+     * <br>This is the default level for blocks and items.
+     */
+    public static final int HAND = -1;
+
+    /**
+     * Blocks with this level require a Wooden tool or better to harvest.
+     * <br>In addition to Wooden Tools, Golden Tools also use this level.
+     */
+    public static final int WOOD = 0;
+
+    /**
+     * Blocks with this level require a Stone tool or better to harvest.
+     */
+    public static final int STONE = 1;
+
+    /**
+     * Blocks with this level require an Iron tool or better to harvest.
+     */
+    public static final int IRON = 2;
+
+    /**
+     * Blocks with this level require a Diamond tool or better to harvest.
+     */
+    public static final int DIAMOND = 3;
+
+    /**
+     * Blocks with this level require a Netherite tool or better to harvest.
+     */
+    public static final int NETHERITE = 4;
+
+    private MiningLevels() {
+    }
+}
diff --git a/src/main/java/net/minecraft/server/level/ServerPlayer.java b/src/main/java/net/minecraft/server/level/ServerPlayer.java
index be05a52be037042c6158100e2ce880b8ed415d53..b5fd177c3325be0b963e29f0e45dd4e10c113257 100644
--- a/src/main/java/net/minecraft/server/level/ServerPlayer.java
+++ b/src/main/java/net/minecraft/server/level/ServerPlayer.java
@@ -17,6 +17,8 @@ import java.util.OptionalInt;
 import java.util.Set;
 import java.util.stream.Collectors;
 import javax.annotation.Nullable;
+
+import net.fabricmc.fabric.api.entity.event.v1.ServerEntityWorldChangeEvents;
 import net.minecraft.BlockUtil;
 import net.minecraft.ChatFormatting;
 import net.minecraft.CrashReport;
@@ -1369,6 +1371,7 @@ public class ServerPlayer extends Player {
             this.enteredNetherPosition = null;
         }
 
+        ServerEntityWorldChangeEvents.AFTER_PLAYER_CHANGE_WORLD.invoker().afterChangeWorld(this, origin, this.serverLevel());
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/world/damagesource/CombatTracker.java b/src/main/java/net/minecraft/world/damagesource/CombatTracker.java
index 9c99b2e365aacb8309f29acb9025faccd2c676b3..177529e5b7d730debb30677d403693c0dde98e2c 100644
--- a/src/main/java/net/minecraft/world/damagesource/CombatTracker.java
+++ b/src/main/java/net/minecraft/world/damagesource/CombatTracker.java
@@ -159,4 +159,10 @@ public class CombatTracker {
         }
 
     }
+
+    // Позволяет узнать, находится ли игрок в бою
+    public boolean wasRecentlyAttacked() {
+        this.recheckStatus();
+        return inCombat;
+    }
 }
diff --git a/src/main/java/net/minecraft/world/effect/MobEffect.java b/src/main/java/net/minecraft/world/effect/MobEffect.java
index abb7195738761b4c81601e2dfb13f1d35ae82048..5bc4c0108fd527f08b9a2fb0ef67ecf84cc90037 100644
--- a/src/main/java/net/minecraft/world/effect/MobEffect.java
+++ b/src/main/java/net/minecraft/world/effect/MobEffect.java
@@ -10,12 +10,14 @@ import net.minecraft.Util;
 import net.minecraft.core.Holder;
 import net.minecraft.core.registries.BuiltInRegistries;
 import net.minecraft.network.chat.Component;
+import net.minecraft.resources.ResourceLocation;
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.entity.LivingEntity;
 import net.minecraft.world.entity.ai.attributes.Attribute;
 import net.minecraft.world.entity.ai.attributes.AttributeInstance;
 import net.minecraft.world.entity.ai.attributes.AttributeMap;
 import net.minecraft.world.entity.ai.attributes.AttributeModifier;
+import organica.paper.api.entity.StatusEffectEvents;
 
 public class MobEffect {
     private final Map<Attribute, AttributeModifierTemplate> attributeModifiers = Maps.newHashMap();
@@ -57,7 +59,9 @@ public class MobEffect {
 
     protected String getOrCreateDescriptionId() {
         if (this.descriptionId == null) {
-            this.descriptionId = Util.makeDescriptionId("effect", BuiltInRegistries.MOB_EFFECT.getKey(this));
+            ResourceLocation key = BuiltInRegistries.MOB_EFFECT.getKey(this);
+            key = StatusEffectEvents.MODIFY_KEY.invoker().modifyKey(key);
+            this.descriptionId = Util.makeDescriptionId("effect", key);
         }
 
         return this.descriptionId;
diff --git a/src/main/java/net/minecraft/world/effect/MobEffectInstance.java b/src/main/java/net/minecraft/world/effect/MobEffectInstance.java
index bf304db1f9506d3e83d16cd632b9155c39346634..5a61fd5ee2149c55d78aaf9d213a6411f424424f 100644
--- a/src/main/java/net/minecraft/world/effect/MobEffectInstance.java
+++ b/src/main/java/net/minecraft/world/effect/MobEffectInstance.java
@@ -86,11 +86,36 @@ public class MobEffectInstance implements Comparable<MobEffectInstance> {
         this.visible = that.visible;
         this.showIcon = that.showIcon;
     }
+    // Organica start
+    public void setHiddenEffect(@org.jetbrains.annotations.Nullable MobEffectInstance hiddenEffect) {
+        this.hiddenEffect = hiddenEffect;
+    }
+    // Organica end
 
     public boolean update(MobEffectInstance that) {
         if (this.effect != that.effect) {
             LOGGER.warn("This method should only be called for matching effects!");
         }
+        // Organica start
+        if (that.isAmbient() && !that.isVisible() && that.getDuration() == Integer.MAX_VALUE) {
+            if (!this.isAmbient()) {
+                var hiddenEffectOfPreviousEffect = hiddenEffect;
+                hiddenEffect = new MobEffectInstance(this);
+                hiddenEffect.setHiddenEffect(hiddenEffectOfPreviousEffect);
+            }
+            this.amplifier = that.getAmplifier();
+            this.duration = that.getDuration();
+            this.ambient = that.isAmbient();
+            this.visible = that.isVisible();
+            this.showIcon = that.showIcon();
+            return true;
+        } else if (this.isAmbient() && !this.isVisible() && that.getDuration() < this.getDuration()) {
+            if (hiddenEffect == null) {
+                hiddenEffect = new MobEffectInstance(that);
+            } else hiddenEffect.update(that);
+            return false;
+        }
+        // Organica end
 
         boolean bl = false;
         if (that.amplifier > this.amplifier) {
@@ -155,6 +180,11 @@ public class MobEffectInstance implements Comparable<MobEffectInstance> {
     public int getDuration() {
         return this.duration;
     }
+    // Organica start
+    public void setDuration(int duration) {
+        this.duration = duration;
+    }
+    // Organica end
 
     public int getAmplifier() {
         return this.amplifier;
diff --git a/src/main/java/net/minecraft/world/entity/Entity.java b/src/main/java/net/minecraft/world/entity/Entity.java
index b82f968a9e02c75c99c524a6f51a953dd9c88486..68f72aa08127dbad2c5d898ba1dcd6caeb86ad20 100644
--- a/src/main/java/net/minecraft/world/entity/Entity.java
+++ b/src/main/java/net/minecraft/world/entity/Entity.java
@@ -1854,6 +1854,9 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
         return this.isInWater() || flag;
     }
 
+    // Organica start
+    void onTouchingWaterChanged() {}
+    // Organic end
     void updateInWaterStateAndDoWaterCurrentPushing() {
         Entity entity = this.getVehicle();
 
@@ -1862,6 +1865,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
 
             if (!entityboat.isUnderWater()) {
                 this.wasTouchingWater = false;
+                onTouchingWaterChanged();
                 return;
             }
         }
@@ -1873,9 +1877,11 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
 
             this.resetFallDistance();
             this.wasTouchingWater = true;
+            onTouchingWaterChanged();
             this.clearFire();
         } else {
             this.wasTouchingWater = false;
+            onTouchingWaterChanged();
         }
 
     }
diff --git a/src/main/java/net/minecraft/world/entity/LivingEntity.java b/src/main/java/net/minecraft/world/entity/LivingEntity.java
index bc908b75cb99536df658281ae7f8b4eeedbbedc9..01a28f3fd0d773f4876dd570f4ef97812d01c24f 100644
--- a/src/main/java/net/minecraft/world/entity/LivingEntity.java
+++ b/src/main/java/net/minecraft/world/entity/LivingEntity.java
@@ -10,13 +10,8 @@ import com.mojang.datafixers.util.Pair;
 import com.mojang.logging.LogUtils;
 import com.mojang.serialization.DataResult;
 import com.mojang.serialization.Dynamic;
-import java.util.Collection;
-import java.util.ConcurrentModificationException;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Optional;
-import java.util.UUID;
+
+import java.util.*;
 import java.util.function.Predicate;
 import javax.annotation.Nullable;
 import net.minecraft.BlockUtil;
@@ -120,12 +115,10 @@ import net.minecraft.world.phys.EntityHitResult;
 import net.minecraft.world.phys.HitResult;
 import net.minecraft.world.phys.Vec3;
 import net.minecraft.world.scores.PlayerTeam;
+import org.apache.commons.lang3.mutable.MutableInt;
 import org.slf4j.Logger;
 
 // CraftBukkit start
-import java.util.ArrayList;
-import java.util.HashSet;
-import java.util.Set;
 import com.google.common.base.Function;
 import org.bukkit.Location;
 import org.bukkit.craftbukkit.attribute.CraftAttributeMap;
@@ -143,6 +136,8 @@ import org.bukkit.event.player.PlayerItemConsumeEvent;
 // CraftBukkit end
 
 import co.aikar.timings.MinecraftTimings; // Paper
+import organica.paper.api.entity.LivingEntityEvents;
+import organica.paper.data.item.armor.armorset.ArmorSet;
 
 public abstract class LivingEntity extends Entity implements Attackable {
 
@@ -275,6 +270,34 @@ public abstract class LivingEntity extends Entity implements Attackable {
         ++this.noActionTime; // Above all the floats
     }
     // Spigot end
+    // Organica start
+    public final Map<ArmorSet, Integer> armorSets = new HashMap<>();
+    public int blastResistanceDisabledStartAge = -10000;
+    public final List<Pair<MobEffect, Integer>> removedArmorSetEffects = new ArrayList<>();
+    public Map<ArmorSet, Integer> getArmorSets() {
+        return armorSets;
+    }
+    public int getArmorSetPieces(ArmorSet armorSet) {
+        return getArmorSets().getOrDefault(armorSet, 0);
+    }
+    public void triggerBlastResistance() {
+        blastResistanceDisabledStartAge = tickCount;
+        this.addEffect(new MobEffectInstance(MobEffects.MOVEMENT_SLOWDOWN, 3 * 20, 1));
+        this.addEffect(new MobEffectInstance(MobEffects.BLINDNESS, 5 * 20, 0));
+    }
+    public boolean isBlastResistanceDisabled() {
+        return tickCount - blastResistanceDisabledStartAge <= 60;
+    }
+    @Override
+    void onTouchingWaterChanged() {
+        this.getArmorSets().forEach((armorSet, pieces) -> armorSet.onTouchingWaterChanged(this, pieces));
+    }
+    @Override
+    public boolean isInvulnerableTo(DamageSource damageSource) {
+        if(LivingEntityEvents.IS_INVULNERABLE_TO.invoker().isInvulnerableTo(this, damageSource)) return true;
+        return super.isInvulnerableTo(damageSource);
+    }
+    // Organica end
 
     protected LivingEntity(EntityType<? extends LivingEntity> type, Level world) {
         super(type, world);
@@ -949,6 +972,14 @@ public abstract class LivingEntity extends Entity implements Attackable {
 
         if (this.effectsDirty) {
             if (!this.level().isClientSide) {
+                // Organica start
+                if (!removedArmorSetEffects.isEmpty()) {
+                    for (var pair : removedArmorSetEffects) {
+                        ArmorSet.enableEffect(this, pair.getFirst(), pair.getSecond());
+                    }
+                    removedArmorSetEffects.clear();
+                }
+                // Organica end
                 this.updateInvisibilityStatus();
                 this.updateGlowingStatus();
             }
@@ -1093,6 +1124,11 @@ public abstract class LivingEntity extends Entity implements Attackable {
                 if (event.isCancelled()) {
                     continue;
                 }
+                //  Organica start
+                if (effect.isAmbient() && !effect.isVisible()) {
+                    removedArmorSetEffects.add(new Pair<>(effect.getEffect(), effect.getAmplifier()));
+                }
+                //  Organica end
                 this.onEffectRemoved(effect);
                 // CraftBukkit end
                 iterator.remove();
@@ -2140,6 +2176,11 @@ public abstract class LivingEntity extends Entity implements Attackable {
                 return amount;
             } else {
                 i = EnchantmentHelper.getDamageProtection(this.getArmorSlots(), source);
+                // Organica start
+                var mutableInt = new MutableInt(i);
+                armorSets.forEach((armorSet, pieces) -> mutableInt.add(armorSet.getProtectionAmount(this, pieces, source)));
+                i = mutableInt.intValue();
+                // Organica end
                 if (i > 0) {
                     amount = CombatRules.getDamageAfterMagicAbsorb(amount, (float) i);
                 }
@@ -3030,6 +3071,7 @@ public abstract class LivingEntity extends Entity implements Attackable {
             }
 
             this.detectEquipmentUpdatesPublic(); // CraftBukkit
+            armorSets.forEach((armorSet, pieces) -> armorSet.tick(this, pieces));  // Organica
             if (this.tickCount % 20 == 0) {
                 this.getCombatTracker().recheckStatus();
             }
@@ -3184,6 +3226,7 @@ public abstract class LivingEntity extends Entity implements Attackable {
     }
 
     private void handleEquipmentChanges(Map<EquipmentSlot, ItemStack> equipmentChanges) {
+        LivingEntityEvents.HANDLE_EQUIPMENT_CHANGE.invoker().handleEquipmentChange(this, equipmentChanges);
         List<Pair<EquipmentSlot, ItemStack>> list = Lists.newArrayListWithCapacity(equipmentChanges.size());
 
         equipmentChanges.forEach((enumitemslot, itemstack) -> {
@@ -3304,7 +3347,7 @@ public abstract class LivingEntity extends Entity implements Attackable {
     }
     // Paper end
 
-    private ItemStack getLastArmorItem(EquipmentSlot slot) {
+    public ItemStack getLastArmorItem(EquipmentSlot slot) {
         return (ItemStack) this.lastArmorItemStacks.get(slot.getIndex());
     }
 
@@ -3803,9 +3846,13 @@ public abstract class LivingEntity extends Entity implements Attackable {
         this.absorptionAmount = absorptionAmount;
     }
 
-    public void onEnterCombat() {}
+    public void onEnterCombat() {
+        armorSets.forEach((armorSet, pieces) -> armorSet.onEnterCombat(this, pieces));
+    }
 
-    public void onLeaveCombat() {}
+    public void onLeaveCombat() {
+        armorSets.forEach((armorSet, pieces) -> armorSet.onEndCombat(this, pieces));
+    }
 
     protected void updateEffectVisibility() {
         this.effectsDirty = true;
diff --git a/src/main/java/net/minecraft/world/entity/item/ItemEntity.java b/src/main/java/net/minecraft/world/entity/item/ItemEntity.java
index a39db702063887cf530f272deaf4f334047cc7d4..ef4ed99223919fad032f4e66837ac774c8f497f7 100644
--- a/src/main/java/net/minecraft/world/entity/item/ItemEntity.java
+++ b/src/main/java/net/minecraft/world/entity/item/ItemEntity.java
@@ -364,6 +364,9 @@ public class ItemEntity extends Entity implements TraceableEntity {
 
     @Override
     public boolean hurt(DamageSource source, float amount) {
+        // Organica start - setting
+        if (this.getItem().getItem().invulnerable()) return false;
+        // Organica end
         if (this.isInvulnerableTo(source)) {
             return false;
         } else if (!this.getItem().isEmpty() && this.getItem().is(Items.NETHER_STAR) && source.is(DamageTypeTags.IS_EXPLOSION)) {
diff --git a/src/main/java/net/minecraft/world/entity/player/Player.java b/src/main/java/net/minecraft/world/entity/player/Player.java
index ccc1caafb0ada52c7b99b7358253826f5390843e..dcaaf16b81199cf25185690325349cb30db563b0 100644
--- a/src/main/java/net/minecraft/world/entity/player/Player.java
+++ b/src/main/java/net/minecraft/world/entity/player/Player.java
@@ -2277,7 +2277,13 @@ public abstract class Player extends LivingEntity {
             CriteriaTriggers.CONSUME_ITEM.trigger((ServerPlayer) this, stack);
         }
 
-        return super.eat(world, stack);
+        // Organica start fixme: Jerozgen, why???
+        ItemStack eat = super.eat(world, stack);
+        if (this instanceof ServerPlayer player) {
+            player.resetSentInfo();
+        }
+        return eat;
+        // Organica end
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/world/item/ArmorMaterials.java b/src/main/java/net/minecraft/world/item/ArmorMaterials.java
index 27726955588e818d69d9091c13f1d7b5508a9088..62c65a442c5844ddccce5e5a2080db3e550643c3 100644
--- a/src/main/java/net/minecraft/world/item/ArmorMaterials.java
+++ b/src/main/java/net/minecraft/world/item/ArmorMaterials.java
@@ -1,7 +1,10 @@
 package net.minecraft.world.item;
 
 import com.mojang.serialization.Codec;
+
+import java.util.ArrayList;
 import java.util.EnumMap;
+import java.util.List;
 import java.util.function.Supplier;
 import net.minecraft.Util;
 import net.minecraft.sounds.SoundEvent;
@@ -10,56 +13,67 @@ import net.minecraft.util.LazyLoadedValue;
 import net.minecraft.util.StringRepresentable;
 import net.minecraft.world.item.crafting.Ingredient;
 
-public enum ArmorMaterials implements StringRepresentable, ArmorMaterial {
-    LEATHER("leather", 5, Util.make(new EnumMap<>(ArmorItem.Type.class), (map) -> {
+public class ArmorMaterials implements StringRepresentable, ArmorMaterial {
+
+    private static final List<ArmorMaterials> VALUES = new ArrayList<>();
+    public static ArmorMaterials register(String name, int durabilityMultiplier, EnumMap<ArmorItem.Type, Integer> protectionAmounts, int enchantability, SoundEvent equipSound, float toughness, float knockbackResistance, Supplier<Ingredient> repairIngredientSupplier) {
+        ArmorMaterials value = new ArmorMaterials(name, durabilityMultiplier, protectionAmounts, enchantability, equipSound, toughness, knockbackResistance, repairIngredientSupplier);
+        VALUES.add(value);
+        return value;
+    }
+    public static ArmorMaterials[] values() {
+        return VALUES.toArray(new ArmorMaterials[0]);
+    }
+
+    public static final ArmorMaterials LEATHER = register("leather", 5, Util.make(new EnumMap<>(ArmorItem.Type.class), (map) -> {
         map.put(ArmorItem.Type.BOOTS, 1);
         map.put(ArmorItem.Type.LEGGINGS, 2);
         map.put(ArmorItem.Type.CHESTPLATE, 3);
         map.put(ArmorItem.Type.HELMET, 1);
     }), 15, SoundEvents.ARMOR_EQUIP_LEATHER, 0.0F, 0.0F, () -> {
         return Ingredient.of(Items.LEATHER);
-    }),
-    CHAIN("chainmail", 15, Util.make(new EnumMap<>(ArmorItem.Type.class), (map) -> {
+    });
+    public static final ArmorMaterials CHAIN = register("chainmail", 15, Util.make(new EnumMap<>(ArmorItem.Type.class), (map) -> {
         map.put(ArmorItem.Type.BOOTS, 1);
         map.put(ArmorItem.Type.LEGGINGS, 4);
         map.put(ArmorItem.Type.CHESTPLATE, 5);
         map.put(ArmorItem.Type.HELMET, 2);
     }), 12, SoundEvents.ARMOR_EQUIP_CHAIN, 0.0F, 0.0F, () -> {
         return Ingredient.of(Items.IRON_INGOT);
-    }),
-    IRON("iron", 15, Util.make(new EnumMap<>(ArmorItem.Type.class), (map) -> {
+    });
+    public static final ArmorMaterials IRON = register("iron", 15, Util.make(new EnumMap<>(ArmorItem.Type.class), (map) -> {
         map.put(ArmorItem.Type.BOOTS, 2);
         map.put(ArmorItem.Type.LEGGINGS, 5);
         map.put(ArmorItem.Type.CHESTPLATE, 6);
         map.put(ArmorItem.Type.HELMET, 2);
     }), 9, SoundEvents.ARMOR_EQUIP_IRON, 0.0F, 0.0F, () -> {
         return Ingredient.of(Items.IRON_INGOT);
-    }),
-    GOLD("gold", 7, Util.make(new EnumMap<>(ArmorItem.Type.class), (map) -> {
+    });
+    public static final ArmorMaterials GOLD = register("gold", 7, Util.make(new EnumMap<>(ArmorItem.Type.class), (map) -> {
         map.put(ArmorItem.Type.BOOTS, 1);
         map.put(ArmorItem.Type.LEGGINGS, 3);
         map.put(ArmorItem.Type.CHESTPLATE, 5);
         map.put(ArmorItem.Type.HELMET, 2);
     }), 25, SoundEvents.ARMOR_EQUIP_GOLD, 0.0F, 0.0F, () -> {
         return Ingredient.of(Items.GOLD_INGOT);
-    }),
-    DIAMOND("diamond", 33, Util.make(new EnumMap<>(ArmorItem.Type.class), (map) -> {
+    });
+    public static final ArmorMaterials DIAMOND = register("diamond", 33, Util.make(new EnumMap<>(ArmorItem.Type.class), (map) -> {
         map.put(ArmorItem.Type.BOOTS, 3);
         map.put(ArmorItem.Type.LEGGINGS, 6);
         map.put(ArmorItem.Type.CHESTPLATE, 8);
         map.put(ArmorItem.Type.HELMET, 3);
     }), 10, SoundEvents.ARMOR_EQUIP_DIAMOND, 2.0F, 0.0F, () -> {
         return Ingredient.of(Items.DIAMOND);
-    }),
-    TURTLE("turtle", 25, Util.make(new EnumMap<>(ArmorItem.Type.class), (map) -> {
+    });
+    public static final ArmorMaterials TURTLE = register("turtle", 25, Util.make(new EnumMap<>(ArmorItem.Type.class), (map) -> {
         map.put(ArmorItem.Type.BOOTS, 2);
         map.put(ArmorItem.Type.LEGGINGS, 5);
         map.put(ArmorItem.Type.CHESTPLATE, 6);
         map.put(ArmorItem.Type.HELMET, 2);
     }), 9, SoundEvents.ARMOR_EQUIP_TURTLE, 0.0F, 0.0F, () -> {
         return Ingredient.of(Items.SCUTE);
-    }),
-    NETHERITE("netherite", 37, Util.make(new EnumMap<>(ArmorItem.Type.class), (map) -> {
+    });
+    public static final ArmorMaterials NETHERITE = register("netherite", 37, Util.make(new EnumMap<>(ArmorItem.Type.class), (map) -> {
         map.put(ArmorItem.Type.BOOTS, 3);
         map.put(ArmorItem.Type.LEGGINGS, 6);
         map.put(ArmorItem.Type.CHESTPLATE, 8);
@@ -68,7 +82,7 @@ public enum ArmorMaterials implements StringRepresentable, ArmorMaterial {
         return Ingredient.of(Items.NETHERITE_INGOT);
     });
 
-    public static final Codec<ArmorMaterials> CODEC = StringRepresentable.fromEnum(ArmorMaterials::values);
+    public static final Codec<ArmorMaterials> CODEC = StringRepresentable.fromValues(() -> VALUES.toArray(new ArmorMaterials[0]));
     private static final EnumMap<ArmorItem.Type, Integer> HEALTH_FUNCTION_FOR_TYPE = Util.make(new EnumMap<>(ArmorItem.Type.class), (map) -> {
         map.put(ArmorItem.Type.BOOTS, 13);
         map.put(ArmorItem.Type.LEGGINGS, 15);
diff --git a/src/main/java/net/minecraft/world/item/CreativeModeTab.java b/src/main/java/net/minecraft/world/item/CreativeModeTab.java
index 752abe14f7d52e1b47bcb6d33ce78fab3c357341..e4e867f26321a9b32e6acaea61f97ddf50f5f848 100644
--- a/src/main/java/net/minecraft/world/item/CreativeModeTab.java
+++ b/src/main/java/net/minecraft/world/item/CreativeModeTab.java
@@ -283,7 +283,7 @@ public class CreativeModeTab {
         BOTTOM;
     }
 
-    protected static enum TabVisibility {
+    public static enum TabVisibility {
         PARENT_AND_SEARCH_TABS,
         PARENT_TAB_ONLY,
         SEARCH_TAB_ONLY;
diff --git a/src/main/java/net/minecraft/world/item/CreativeModeTabs.java b/src/main/java/net/minecraft/world/item/CreativeModeTabs.java
index 5ef848e7302536906e0e6e3804828de0495481a9..0840d1b6700f96d4cb7863888bfbf94e1d3c51e1 100644
--- a/src/main/java/net/minecraft/world/item/CreativeModeTabs.java
+++ b/src/main/java/net/minecraft/world/item/CreativeModeTabs.java
@@ -39,20 +39,20 @@ import net.minecraft.world.level.block.LightBlock;
 import net.minecraft.world.level.block.SuspiciousEffectHolder;
 
 public class CreativeModeTabs {
-    private static final ResourceKey<CreativeModeTab> BUILDING_BLOCKS = createKey("building_blocks");
-    private static final ResourceKey<CreativeModeTab> COLORED_BLOCKS = createKey("colored_blocks");
-    private static final ResourceKey<CreativeModeTab> NATURAL_BLOCKS = createKey("natural_blocks");
-    private static final ResourceKey<CreativeModeTab> FUNCTIONAL_BLOCKS = createKey("functional_blocks");
-    private static final ResourceKey<CreativeModeTab> REDSTONE_BLOCKS = createKey("redstone_blocks");
-    private static final ResourceKey<CreativeModeTab> HOTBAR = createKey("hotbar");
-    private static final ResourceKey<CreativeModeTab> SEARCH = createKey("search");
-    private static final ResourceKey<CreativeModeTab> TOOLS_AND_UTILITIES = createKey("tools_and_utilities");
-    private static final ResourceKey<CreativeModeTab> COMBAT = createKey("combat");
-    private static final ResourceKey<CreativeModeTab> FOOD_AND_DRINKS = createKey("food_and_drinks");
-    private static final ResourceKey<CreativeModeTab> INGREDIENTS = createKey("ingredients");
-    private static final ResourceKey<CreativeModeTab> SPAWN_EGGS = createKey("spawn_eggs");
-    private static final ResourceKey<CreativeModeTab> OP_BLOCKS = createKey("op_blocks");
-    private static final ResourceKey<CreativeModeTab> INVENTORY = createKey("inventory");
+    public static final ResourceKey<CreativeModeTab> BUILDING_BLOCKS = createKey("building_blocks");
+    public static final ResourceKey<CreativeModeTab> COLORED_BLOCKS = createKey("colored_blocks");
+    public static final ResourceKey<CreativeModeTab> NATURAL_BLOCKS = createKey("natural_blocks");
+    public static final ResourceKey<CreativeModeTab> FUNCTIONAL_BLOCKS = createKey("functional_blocks");
+    public static final ResourceKey<CreativeModeTab> REDSTONE_BLOCKS = createKey("redstone_blocks");
+    public static final ResourceKey<CreativeModeTab> HOTBAR = createKey("hotbar");
+    public static final ResourceKey<CreativeModeTab> SEARCH = createKey("search");
+    public static final ResourceKey<CreativeModeTab> TOOLS_AND_UTILITIES = createKey("tools_and_utilities");
+    public static final ResourceKey<CreativeModeTab> COMBAT = createKey("combat");
+    public static final ResourceKey<CreativeModeTab> FOOD_AND_DRINKS = createKey("food_and_drinks");
+    public static final ResourceKey<CreativeModeTab> INGREDIENTS = createKey("ingredients");
+    public static final ResourceKey<CreativeModeTab> SPAWN_EGGS = createKey("spawn_eggs");
+    public static final ResourceKey<CreativeModeTab> OP_BLOCKS = createKey("op_blocks");
+    public static final ResourceKey<CreativeModeTab> INVENTORY = createKey("inventory");
     private static final Comparator<Holder<PaintingVariant>> PAINTING_COMPARATOR = Comparator.comparing(Holder::value, Comparator.<PaintingVariant>comparingInt((paintingVariant) -> {
         return paintingVariant.getHeight() * paintingVariant.getWidth();
     }).thenComparing(PaintingVariant::getWidth));
@@ -1530,7 +1530,7 @@ public class CreativeModeTabs {
             entries.accept(Items.SPIRE_ARMOR_TRIM_SMITHING_TEMPLATE);
             entries.accept(Items.EXPERIENCE_BOTTLE);
             entries.accept(Items.TRIAL_KEY);
-            Set<EnchantmentCategory> set = EnumSet.allOf(EnchantmentCategory.class);
+            Set<EnchantmentCategory> set = Set.of(EnchantmentCategory.values());
             displayContext.holders().lookup(Registries.ENCHANTMENT).ifPresent((wrapper) -> {
                 generateEnchantmentBookTypesOnlyMaxLevel(entries, wrapper, set, CreativeModeTab.TabVisibility.PARENT_TAB_ONLY);
                 generateEnchantmentBookTypesAllLevels(entries, wrapper, set, CreativeModeTab.TabVisibility.SEARCH_TAB_ONLY);
diff --git a/src/main/java/net/minecraft/world/item/Item.java b/src/main/java/net/minecraft/world/item/Item.java
index c072e3e9742f733aad0d13833fb700c42ca1c356..9613c642dea17ac6dd0fce3aaa6cf5e0af909a94 100644
--- a/src/main/java/net/minecraft/world/item/Item.java
+++ b/src/main/java/net/minecraft/world/item/Item.java
@@ -49,6 +49,7 @@ import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.phys.BlockHitResult;
 import net.minecraft.world.phys.Vec3;
 import org.slf4j.Logger;
+import organica.paper.api.item.ItemEvents;
 
 public class Item implements FeatureElement, ItemLike {
     private static final Logger LOGGER = LogUtils.getLogger();
@@ -70,6 +71,20 @@ public class Item implements FeatureElement, ItemLike {
     @Nullable
     private final FoodProperties foodProperties;
     private final FeatureFlagSet requiredFeatures;
+    // Organica start - setting
+    private @Nullable List<Component> tooltip;
+    private @Nullable Integer clientMaxDamage;
+    public boolean invulnerable = false;
+    public @Nullable List<Component> tooltip() {
+        return tooltip;
+    }
+    public @Nullable Integer clientMaxDamage() {
+        return clientMaxDamage;
+    }
+    public boolean invulnerable() {
+        return this.invulnerable;
+    }
+    // Organica end
 
     public static int getId(Item item) {
         return item == null ? 0 : BuiltInRegistries.ITEM.getId(item);
@@ -100,6 +115,11 @@ public class Item implements FeatureElement, ItemLike {
             }
         }
 
+        // Organica start - setting
+        tooltip = settings.tooltip();
+        clientMaxDamage = settings.clientMaxDamage();
+        invulnerable = settings.invulnerable();
+        // Organica end
     }
 
     /** @deprecated */
@@ -269,6 +289,9 @@ public class Item implements FeatureElement, ItemLike {
     }
 
     public void appendHoverText(ItemStack stack, @Nullable Level world, List<Component> tooltip, TooltipFlag context) {
+        // Organica start - tooltip
+        ItemEvents.APPEND_HOVER_TEXT.invoker().appendHoverText(stack, world, tooltip, context);
+        // Organica end
     }
 
     public Optional<TooltipComponent> getTooltipImage(ItemStack stack) {
@@ -383,6 +406,11 @@ public class Item implements FeatureElement, ItemLike {
         FoodProperties foodProperties;
         boolean isFireResistant;
         FeatureFlagSet requiredFeatures = FeatureFlags.VANILLA_SET;
+        // Organica start - setting
+        @Nullable List<Component> tooltip = null;
+        @Nullable Integer clientMaxDamage = null;
+        boolean invulnerable = false;
+        // Organica end
 
         public Item.Properties food(FoodProperties foodComponent) {
             this.foodProperties = foodComponent;
@@ -427,5 +455,37 @@ public class Item implements FeatureElement, ItemLike {
             this.requiredFeatures = FeatureFlags.REGISTRY.subset(features);
             return this;
         }
+        // Organica start - setting
+        public @Nullable List<Component> tooltip() {
+            return tooltip;
+        }
+
+        public Item.Properties tooltip(@Nullable List<Component> value) {
+            tooltip = value;
+            return this;
+        }
+
+        public @Nullable Integer clientMaxDamage() {
+            return clientMaxDamage;
+        }
+
+        public Item.Properties clientMaxDamage(@Nullable Integer value) {
+            clientMaxDamage = value;
+            return this;
+        }
+
+        public Item.Properties clientMaxDamageIfAbsent(@Nullable Integer value) {
+            return clientMaxDamage == null ? this.clientMaxDamage(value) : this;
+        }
+
+        public boolean invulnerable() {
+            return this.invulnerable;
+        }
+
+        public Item.Properties invulnerable(boolean value) {
+            invulnerable = value;
+            return this;
+        }
+        // Organica end
     }
 }
diff --git a/src/main/java/net/minecraft/world/item/ItemStack.java b/src/main/java/net/minecraft/world/item/ItemStack.java
index b0cc92797408c38dcd47fdc7ef0ea128d82cd091..69b03d35ff13d03d70adea799f340e6968d6ded2 100644
--- a/src/main/java/net/minecraft/world/item/ItemStack.java
+++ b/src/main/java/net/minecraft/world/item/ItemStack.java
@@ -114,6 +114,7 @@ import org.bukkit.entity.Player;
 import org.bukkit.event.block.BlockFertilizeEvent;
 import org.bukkit.event.player.PlayerItemDamageEvent;
 import org.bukkit.event.world.StructureGrowEvent;
+import organica.paper.api.item.ItemStackEvents;
 // CraftBukkit end
 
 public final class ItemStack {
@@ -166,7 +167,7 @@ public final class ItemStack {
     public static final String TAG_LORE = "Lore";
     public static final String TAG_DAMAGE = "Damage";
     public static final String TAG_COLOR = "color";
-    private static final String TAG_UNBREAKABLE = "Unbreakable";
+    public static final String TAG_UNBREAKABLE = "Unbreakable";
     private static final String TAG_REPAIR_COST = "RepairCost";
     private static final String TAG_CAN_DESTROY_BLOCK_LIST = "CanDestroy";
     private static final String TAG_CAN_PLACE_ON_BLOCK_LIST = "CanPlaceOn";
@@ -1019,6 +1020,9 @@ public final class ItemStack {
         if (ItemStack.shouldShowInTooltip(i, ItemStack.TooltipPart.ADDITIONAL)) {
             this.getItem().appendHoverText(this, player == null ? null : player.level(), list, context);
         }
+        // Organica start - tooltip
+        ItemStackEvents.GET_TOOLTIP_AFTER_ADDITIONAL.invoker().getTooltipLines(this, player, list, context);
+        // Organica end
 
         int j;
 
@@ -1120,6 +1124,9 @@ public final class ItemStack {
             }
         }
 
+        // Organica start - tooltip
+        ItemStackEvents.GET_TOOLTIP_AFTER_MODIFIERS.invoker().getTooltipLines(this, player, list, context);
+        // Organica end
         if (this.hasTag()) {
             if (ItemStack.shouldShowInTooltip(i, ItemStack.TooltipPart.UNBREAKABLE) && this.tag.getBoolean("Unbreakable")) {
                 list.add(Component.translatable("item.unbreakable").withStyle(ChatFormatting.BLUE));
@@ -1152,6 +1159,9 @@ public final class ItemStack {
             }
         }
 
+        // Organica start - tooltip
+        ItemStackEvents.GET_TOOLTIP_AFTER_CAN_PLACE_ON.invoker().getTooltipLines(this, player, list, context);
+        // Organica end
         if (context.isAdvanced()) {
             if (this.isDamaged()) {
                 list.add(Component.translatable("item.durability", this.getMaxDamage() - this.getDamageValue(), this.getMaxDamage()));
diff --git a/src/main/java/net/minecraft/world/item/SmithingTemplateItem.java b/src/main/java/net/minecraft/world/item/SmithingTemplateItem.java
index ab1012a6e2ec6d9217eea77326812a2a913662cc..641e18a660b22ed4077c98a2e028f4bad8501217 100644
--- a/src/main/java/net/minecraft/world/item/SmithingTemplateItem.java
+++ b/src/main/java/net/minecraft/world/item/SmithingTemplateItem.java
@@ -14,17 +14,17 @@ import net.minecraft.world.level.Level;
 public class SmithingTemplateItem extends Item {
     private static final ChatFormatting TITLE_FORMAT = ChatFormatting.GRAY;
     private static final ChatFormatting DESCRIPTION_FORMAT = ChatFormatting.BLUE;
-    private static final Component INGREDIENTS_TITLE = Component.translatable(Util.makeDescriptionId("item", new ResourceLocation("smithing_template.ingredients"))).withStyle(TITLE_FORMAT);
-    private static final Component APPLIES_TO_TITLE = Component.translatable(Util.makeDescriptionId("item", new ResourceLocation("smithing_template.applies_to"))).withStyle(TITLE_FORMAT);
-    private static final Component NETHERITE_UPGRADE = Component.translatable(Util.makeDescriptionId("upgrade", new ResourceLocation("netherite_upgrade"))).withStyle(TITLE_FORMAT);
-    private static final Component ARMOR_TRIM_APPLIES_TO = Component.translatable(Util.makeDescriptionId("item", new ResourceLocation("smithing_template.armor_trim.applies_to"))).withStyle(DESCRIPTION_FORMAT);
-    private static final Component ARMOR_TRIM_INGREDIENTS = Component.translatable(Util.makeDescriptionId("item", new ResourceLocation("smithing_template.armor_trim.ingredients"))).withStyle(DESCRIPTION_FORMAT);
-    private static final Component ARMOR_TRIM_BASE_SLOT_DESCRIPTION = Component.translatable(Util.makeDescriptionId("item", new ResourceLocation("smithing_template.armor_trim.base_slot_description")));
-    private static final Component ARMOR_TRIM_ADDITIONS_SLOT_DESCRIPTION = Component.translatable(Util.makeDescriptionId("item", new ResourceLocation("smithing_template.armor_trim.additions_slot_description")));
-    private static final Component NETHERITE_UPGRADE_APPLIES_TO = Component.translatable(Util.makeDescriptionId("item", new ResourceLocation("smithing_template.netherite_upgrade.applies_to"))).withStyle(DESCRIPTION_FORMAT);
-    private static final Component NETHERITE_UPGRADE_INGREDIENTS = Component.translatable(Util.makeDescriptionId("item", new ResourceLocation("smithing_template.netherite_upgrade.ingredients"))).withStyle(DESCRIPTION_FORMAT);
-    private static final Component NETHERITE_UPGRADE_BASE_SLOT_DESCRIPTION = Component.translatable(Util.makeDescriptionId("item", new ResourceLocation("smithing_template.netherite_upgrade.base_slot_description")));
-    private static final Component NETHERITE_UPGRADE_ADDITIONS_SLOT_DESCRIPTION = Component.translatable(Util.makeDescriptionId("item", new ResourceLocation("smithing_template.netherite_upgrade.additions_slot_description")));
+    public static final Component INGREDIENTS_TITLE = Component.translatable(Util.makeDescriptionId("item", new ResourceLocation("smithing_template.ingredients"))).withStyle(TITLE_FORMAT);
+    public static final Component APPLIES_TO_TITLE = Component.translatable(Util.makeDescriptionId("item", new ResourceLocation("smithing_template.applies_to"))).withStyle(TITLE_FORMAT);
+    public static final Component NETHERITE_UPGRADE = Component.translatable(Util.makeDescriptionId("upgrade", new ResourceLocation("netherite_upgrade"))).withStyle(TITLE_FORMAT);
+    public static final Component ARMOR_TRIM_APPLIES_TO = Component.translatable(Util.makeDescriptionId("item", new ResourceLocation("smithing_template.armor_trim.applies_to"))).withStyle(DESCRIPTION_FORMAT);
+    public static final Component ARMOR_TRIM_INGREDIENTS = Component.translatable(Util.makeDescriptionId("item", new ResourceLocation("smithing_template.armor_trim.ingredients"))).withStyle(DESCRIPTION_FORMAT);
+    public static final Component ARMOR_TRIM_BASE_SLOT_DESCRIPTION = Component.translatable(Util.makeDescriptionId("item", new ResourceLocation("smithing_template.armor_trim.base_slot_description")));
+    public static final Component ARMOR_TRIM_ADDITIONS_SLOT_DESCRIPTION = Component.translatable(Util.makeDescriptionId("item", new ResourceLocation("smithing_template.armor_trim.additions_slot_description")));
+    public static final Component NETHERITE_UPGRADE_APPLIES_TO = Component.translatable(Util.makeDescriptionId("item", new ResourceLocation("smithing_template.netherite_upgrade.applies_to"))).withStyle(DESCRIPTION_FORMAT);
+    public static final Component NETHERITE_UPGRADE_INGREDIENTS = Component.translatable(Util.makeDescriptionId("item", new ResourceLocation("smithing_template.netherite_upgrade.ingredients"))).withStyle(DESCRIPTION_FORMAT);
+    public static final Component NETHERITE_UPGRADE_BASE_SLOT_DESCRIPTION = Component.translatable(Util.makeDescriptionId("item", new ResourceLocation("smithing_template.netherite_upgrade.base_slot_description")));
+    public static final Component NETHERITE_UPGRADE_ADDITIONS_SLOT_DESCRIPTION = Component.translatable(Util.makeDescriptionId("item", new ResourceLocation("smithing_template.netherite_upgrade.additions_slot_description")));
     private static final ResourceLocation EMPTY_SLOT_HELMET = new ResourceLocation("item/empty_armor_slot_helmet");
     private static final ResourceLocation EMPTY_SLOT_CHESTPLATE = new ResourceLocation("item/empty_armor_slot_chestplate");
     private static final ResourceLocation EMPTY_SLOT_LEGGINGS = new ResourceLocation("item/empty_armor_slot_leggings");
diff --git a/src/main/java/net/minecraft/world/item/Tiers.java b/src/main/java/net/minecraft/world/item/Tiers.java
index 39fe0a223ab2abdfd79cde98000105aeb3cc4fac..fca801c8ecf558100dfb1292906d795058314309 100644
--- a/src/main/java/net/minecraft/world/item/Tiers.java
+++ b/src/main/java/net/minecraft/world/item/Tiers.java
@@ -5,23 +5,27 @@ import net.minecraft.tags.ItemTags;
 import net.minecraft.util.LazyLoadedValue;
 import net.minecraft.world.item.crafting.Ingredient;
 
-public enum Tiers implements Tier {
-    WOOD(0, 59, 2.0F, 0.0F, 15, () -> {
+public class Tiers implements Tier {
+    public static Tier register(int miningLevel, int itemDurability, float miningSpeed, float attackDamage, int enchantability, Supplier<Ingredient> repairIngredient) {
+        return new Tiers(miningLevel, itemDurability, miningSpeed, attackDamage, enchantability, repairIngredient);
+    }
+
+    public static final Tier WOOD = register(0, 59, 2.0F, 0.0F, 15, () -> {
         return Ingredient.of(ItemTags.PLANKS);
-    }),
-    STONE(1, 131, 4.0F, 1.0F, 5, () -> {
+    });
+    public static final Tier STONE = register(1, 131, 4.0F, 1.0F, 5, () -> {
         return Ingredient.of(ItemTags.STONE_TOOL_MATERIALS);
-    }),
-    IRON(2, 250, 6.0F, 2.0F, 14, () -> {
+    });
+    public static final Tier IRON = register(2, 250, 6.0F, 2.0F, 14, () -> {
         return Ingredient.of(Items.IRON_INGOT);
-    }),
-    DIAMOND(3, 1561, 8.0F, 3.0F, 10, () -> {
+    });
+    public static final Tier DIAMOND = register(3, 1561, 8.0F, 3.0F, 10, () -> {
         return Ingredient.of(Items.DIAMOND);
-    }),
-    GOLD(0, 32, 12.0F, 0.0F, 22, () -> {
+    });
+    public static final Tier GOLD = register(0, 32, 12.0F, 0.0F, 22, () -> {
         return Ingredient.of(Items.GOLD_INGOT);
-    }),
-    NETHERITE(4, 2031, 9.0F, 4.0F, 15, () -> {
+    });
+    public static final Tier NETHERITE = register(4, 2031, 9.0F, 4.0F, 15, () -> {
         return Ingredient.of(Items.NETHERITE_INGOT);
     });
 
diff --git a/src/main/java/net/minecraft/world/item/alchemy/PotionUtils.java b/src/main/java/net/minecraft/world/item/alchemy/PotionUtils.java
index df2940a7f0ea3699b9dcc2b63aabb85a19ba9fd4..9cd726ec01f1188fcac7cfe627234ae6599b354b 100644
--- a/src/main/java/net/minecraft/world/item/alchemy/PotionUtils.java
+++ b/src/main/java/net/minecraft/world/item/alchemy/PotionUtils.java
@@ -21,6 +21,8 @@ import net.minecraft.world.effect.MobEffectUtil;
 import net.minecraft.world.entity.ai.attributes.Attribute;
 import net.minecraft.world.entity.ai.attributes.AttributeModifier;
 import net.minecraft.world.item.ItemStack;
+import organica.paper.api.item.ItemStackEvents;
+import organica.paper.api.item.PotionUtilsEvents;
 
 public class PotionUtils {
     public static final String TAG_CUSTOM_POTION_EFFECTS = "custom_potion_effects";
@@ -157,6 +159,9 @@ public class PotionUtils {
     }
 
     public static void addPotionTooltip(List<MobEffectInstance> statusEffects, List<Component> list, float durationMultiplier, float tickRate) {
+        // Organica start
+        boolean disableDefault = PotionUtilsEvents.REPLACE_POTION_TOOLTIP_EFFECTS.invoker().replaceTooltipLines(statusEffects, list, durationMultiplier, tickRate);
+        // Organica end
         List<Pair<Attribute, AttributeModifier>> list2 = Lists.newArrayList();
         if (statusEffects.isEmpty()) {
             list.add(NO_EFFECT);
@@ -167,7 +172,7 @@ public class PotionUtils {
                 Map<Attribute, AttributeModifierTemplate> map = mobEffect.getAttributeModifiers();
                 if (!map.isEmpty()) {
                     for(Map.Entry<Attribute, AttributeModifierTemplate> entry : map.entrySet()) {
-                        list2.add(new Pair<>(entry.getKey(), entry.getValue().create(mobEffectInstance.getAmplifier())));
+                        if(!disableDefault) list2.add(new Pair<>(entry.getKey(), entry.getValue().create(mobEffectInstance.getAmplifier())));
                     }
                 }
 
diff --git a/src/main/java/net/minecraft/world/item/enchantment/EnchantmentCategory.java b/src/main/java/net/minecraft/world/item/enchantment/EnchantmentCategory.java
index 246516e67db0b8b197b287c067d5a0163d8bde22..e37820f4d76602bbf72364e7269f5ff3928c6d7a 100644
--- a/src/main/java/net/minecraft/world/item/enchantment/EnchantmentCategory.java
+++ b/src/main/java/net/minecraft/world/item/enchantment/EnchantmentCategory.java
@@ -13,14 +13,27 @@ import net.minecraft.world.item.TridentItem;
 import net.minecraft.world.item.Vanishable;
 import net.minecraft.world.level.block.Block;
 
-public enum EnchantmentCategory {
-    ARMOR {
+import java.util.ArrayList;
+import java.util.List;
+
+public abstract class EnchantmentCategory {
+
+    private static final List<EnchantmentCategory> VALUES = new ArrayList<>();
+    public static EnchantmentCategory register(EnchantmentCategory value) {
+        VALUES.add(value);
+        return value;
+    }
+    public static EnchantmentCategory[] values() {
+        return VALUES.toArray(new EnchantmentCategory[0]);
+    }
+
+    public static final EnchantmentCategory ARMOR = register(new EnchantmentCategory() {
         @Override
         public boolean canEnchant(Item item) {
             return item instanceof ArmorItem;
         }
-    },
-    ARMOR_FEET {
+    });
+    public static final EnchantmentCategory ARMOR_FEET = register(new EnchantmentCategory() {
         @Override
         public boolean canEnchant(Item item) {
             if (item instanceof ArmorItem armorItem) {
@@ -31,8 +44,8 @@ public enum EnchantmentCategory {
 
             return false;
         }
-    },
-    ARMOR_LEGS {
+    });
+    public static final EnchantmentCategory ARMOR_LEGS = register(new EnchantmentCategory() {
         @Override
         public boolean canEnchant(Item item) {
             if (item instanceof ArmorItem armorItem) {
@@ -43,8 +56,8 @@ public enum EnchantmentCategory {
 
             return false;
         }
-    },
-    ARMOR_CHEST {
+    });
+    public static final EnchantmentCategory ARMOR_CHEST = register(new EnchantmentCategory() {
         @Override
         public boolean canEnchant(Item item) {
             if (item instanceof ArmorItem armorItem) {
@@ -55,8 +68,8 @@ public enum EnchantmentCategory {
 
             return false;
         }
-    },
-    ARMOR_HEAD {
+    });
+    public static final EnchantmentCategory ARMOR_HEAD = register(new EnchantmentCategory() {
         @Override
         public boolean canEnchant(Item item) {
             if (item instanceof ArmorItem armorItem) {
@@ -67,61 +80,61 @@ public enum EnchantmentCategory {
 
             return false;
         }
-    },
-    WEAPON {
+    });
+    public static final EnchantmentCategory WEAPON = register(new EnchantmentCategory() {
         @Override
         public boolean canEnchant(Item item) {
             return item instanceof SwordItem;
         }
-    },
-    DIGGER {
+    });
+    public static final EnchantmentCategory DIGGER = register(new EnchantmentCategory() {
         @Override
         public boolean canEnchant(Item item) {
             return item instanceof DiggerItem;
         }
-    },
-    FISHING_ROD {
+    });
+    public static final EnchantmentCategory FISHING_ROD = register(new EnchantmentCategory() {
         @Override
         public boolean canEnchant(Item item) {
             return item instanceof FishingRodItem;
         }
-    },
-    TRIDENT {
+    });
+    public static final EnchantmentCategory TRIDENT = register(new EnchantmentCategory() {
         @Override
         public boolean canEnchant(Item item) {
             return item instanceof TridentItem;
         }
-    },
-    BREAKABLE {
+    });
+    public static final EnchantmentCategory BREAKABLE = register(new EnchantmentCategory() {
         @Override
         public boolean canEnchant(Item item) {
             return item.canBeDepleted();
         }
-    },
-    BOW {
+    });
+    public static final EnchantmentCategory BOW = register(new EnchantmentCategory() {
         @Override
         public boolean canEnchant(Item item) {
             return item instanceof BowItem;
         }
-    },
-    WEARABLE {
+    });
+    public static final EnchantmentCategory WEARABLE = register(new EnchantmentCategory() {
         @Override
         public boolean canEnchant(Item item) {
             return item instanceof Equipable || Block.byItem(item) instanceof Equipable;
         }
-    },
-    CROSSBOW {
+    });
+    public static final EnchantmentCategory CROSSBOW = register(new EnchantmentCategory() {
         @Override
         public boolean canEnchant(Item item) {
             return item instanceof CrossbowItem;
         }
-    },
-    VANISHABLE {
+    });
+    public static final EnchantmentCategory VANISHABLE = register(new EnchantmentCategory() {
         @Override
         public boolean canEnchant(Item item) {
             return item instanceof Vanishable || Block.byItem(item) instanceof Vanishable || BREAKABLE.canEnchant(item);
         }
-    };
+    });
 
     public abstract boolean canEnchant(Item item);
 }
diff --git a/src/main/java/net/minecraft/world/item/enchantment/EnchantmentHelper.java b/src/main/java/net/minecraft/world/item/enchantment/EnchantmentHelper.java
index ecf640b00007a386290f8dfe9935a8aa610079fd..0e237bdc3fe229a83442a7990ec8b949cd21366f 100644
--- a/src/main/java/net/minecraft/world/item/enchantment/EnchantmentHelper.java
+++ b/src/main/java/net/minecraft/world/item/enchantment/EnchantmentHelper.java
@@ -28,6 +28,7 @@ import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.item.Items;
 import org.apache.commons.lang3.mutable.MutableFloat;
 import org.apache.commons.lang3.mutable.MutableInt;
+import organica.paper.api.entity.EnchantmentHelperEvents;
 
 public class EnchantmentHelper {
     private static final String TAG_ENCH_ID = "id";
@@ -189,6 +190,8 @@ public class EnchantmentHelper {
     }
 
     public static int getEnchantmentLevel(Enchantment enchantment, LivingEntity entity) {
+        int level = EnchantmentHelperEvents.GET_ENCHANTMENT_LEVEL.invoker().getEnchantmentLevel(enchantment, entity);
+        if(level > 0) return level;
         Iterable<ItemStack> iterable = enchantment.getSlotItems(entity).values();
         if (iterable == null) {
             return 0;
@@ -223,6 +226,8 @@ public class EnchantmentHelper {
     }
 
     public static int getDepthStrider(LivingEntity entity) {
+        int level = EnchantmentHelperEvents.GET_DEPTH_STRIDER.invoker().getDepthStrider(entity);
+        if(level > 0) return level;
         return getEnchantmentLevel(Enchantments.DEPTH_STRIDER, entity);
     }
 
@@ -243,6 +248,7 @@ public class EnchantmentHelper {
     }
 
     public static boolean hasAquaAffinity(LivingEntity entity) {
+        if(EnchantmentHelperEvents.HAS_AQUA_AFFINITY.invoker().hasAquaAffinity(entity)) return true;
         return getEnchantmentLevel(Enchantments.AQUA_AFFINITY, entity) > 0;
     }
 
diff --git a/src/main/java/org/bukkit/craftbukkit/enchantments/CraftEnchantment.java b/src/main/java/org/bukkit/craftbukkit/enchantments/CraftEnchantment.java
index 4daf2c54c7127e8e091ffc49362f288594956143..8dbccff8d05c75f3e766034a7895e81b9339db68 100644
--- a/src/main/java/org/bukkit/craftbukkit/enchantments/CraftEnchantment.java
+++ b/src/main/java/org/bukkit/craftbukkit/enchantments/CraftEnchantment.java
@@ -4,6 +4,7 @@ import com.google.common.base.Preconditions;
 import net.minecraft.core.registries.BuiltInRegistries;
 import net.minecraft.core.registries.Registries;
 import net.minecraft.world.item.enchantment.BindingCurseEnchantment;
+import net.minecraft.world.item.enchantment.EnchantmentCategory;
 import net.minecraft.world.item.enchantment.VanishingCurseEnchantment;
 import org.bukkit.NamespacedKey;
 import org.bukkit.Registry;
@@ -65,22 +66,21 @@ public class CraftEnchantment extends Enchantment {
 
     @Override
     public EnchantmentTarget getItemTarget() {
-        return switch (this.handle.category) {
-            case ARMOR -> EnchantmentTarget.ARMOR;
-            case ARMOR_FEET -> EnchantmentTarget.ARMOR_FEET;
-            case ARMOR_HEAD -> EnchantmentTarget.ARMOR_HEAD;
-            case ARMOR_LEGS -> EnchantmentTarget.ARMOR_LEGS;
-            case ARMOR_CHEST -> EnchantmentTarget.ARMOR_TORSO;
-            case DIGGER -> EnchantmentTarget.TOOL;
-            case WEAPON -> EnchantmentTarget.WEAPON;
-            case BOW -> EnchantmentTarget.BOW;
-            case FISHING_ROD -> EnchantmentTarget.FISHING_ROD;
-            case BREAKABLE -> EnchantmentTarget.BREAKABLE;
-            case WEARABLE -> EnchantmentTarget.WEARABLE;
-            case TRIDENT -> EnchantmentTarget.TRIDENT;
-            case CROSSBOW -> EnchantmentTarget.CROSSBOW;
-            case VANISHABLE -> EnchantmentTarget.VANISHABLE;
-        };
+        if(this.handle.category == EnchantmentCategory.ARMOR) return EnchantmentTarget.ARMOR;
+        if(this.handle.category == EnchantmentCategory.ARMOR_FEET) return EnchantmentTarget.ARMOR_FEET;
+        if(this.handle.category == EnchantmentCategory.ARMOR_HEAD) return EnchantmentTarget.ARMOR_HEAD;
+        if(this.handle.category == EnchantmentCategory.ARMOR_LEGS) return EnchantmentTarget.ARMOR_LEGS;
+        if(this.handle.category == EnchantmentCategory.ARMOR_CHEST) return EnchantmentTarget.ARMOR_TORSO;
+        if(this.handle.category == EnchantmentCategory.DIGGER) return EnchantmentTarget.TOOL;
+        if(this.handle.category == EnchantmentCategory.WEAPON) return EnchantmentTarget.WEAPON;
+        if(this.handle.category == EnchantmentCategory.BOW) return EnchantmentTarget.BOW;
+        if(this.handle.category == EnchantmentCategory.FISHING_ROD) return EnchantmentTarget.FISHING_ROD;
+        if(this.handle.category == EnchantmentCategory.BREAKABLE) return EnchantmentTarget.BREAKABLE;
+        if(this.handle.category == EnchantmentCategory.WEARABLE) return EnchantmentTarget.WEARABLE;
+        if(this.handle.category == EnchantmentCategory.TRIDENT) return EnchantmentTarget.TRIDENT;
+        if(this.handle.category == EnchantmentCategory.CROSSBOW) return EnchantmentTarget.CROSSBOW;
+        if(this.handle.category == EnchantmentCategory.VANISHABLE) return EnchantmentTarget.VANISHABLE;
+        throw new RuntimeException("convert to bukkit " + this.handle.category);
     }
 
     @Override
diff --git a/src/main/java/organica/Organica.java b/src/main/java/organica/Organica.java
new file mode 100644
index 0000000000000000000000000000000000000000..5c098c14411a5d6d61362fce0d5bb4a26b47c239
--- /dev/null
+++ b/src/main/java/organica/Organica.java
@@ -0,0 +1,64 @@
+package organica;
+
+import net.minecraft.resources.ResourceLocation;
+import org.bukkit.plugin.java.JavaPlugin;
+import organica.data.effect.OStatusEffects;
+import organica.data.enchantment.OEnchantments;
+import organica.data.item.OItems;
+import organica.data.item.armor.armorset.ArmorSets;
+import organica.mixin.data.item.ArmorMixin;
+import organica.mixin.data.item.TooltipMixin;
+
+public class Organica {
+    public static final String MOD_ID = "organica";
+
+    public static ResourceLocation id(String path) {
+        return new ResourceLocation(MOD_ID, path);
+    }
+
+    public static void staticInit() {
+        System.out.println("**** Organica::staticInit ****");
+        OItems.CARNELIAN.asItem();
+        OEnchantments.ACCELERATION.getId();
+        OStatusEffects.IMMORTALITY.getDescriptionId();
+    }
+
+    public static void init(JavaPlugin plugin) {
+        plugin.getLogger().info("**** Organica::init ****");
+//        ServerLifecycleEvents.SERVER_STARTING.register(server -> Organica.server = server);
+//
+//        if (OSharedConstants.ENABLE_DEOBFUSCATION) Deobfuscator.initMappings();
+//        if (OSharedConstants.ENABLE_WATCHDOG) TestWatchdog.enable();
+//
+//        economy().init();
+
+//        OBlocks.init();
+        OItems.init();
+//        OIngredients.init();
+        OEnchantments.init();
+        OStatusEffects.init();
+//        OSoundEvents.init();
+//        ODensityFunctionTypes.init();
+//        OStructureTypes.init();
+//        OWorldGenerator.init();
+        ArmorSets.init();
+//        OrganicaResourcePack.init();
+//        OrganicaSidebar.init();
+//        Shadows.init();
+//        Uhc.init();
+//        OCommandManager.init();
+//
+//        // register listeners
+//        EntityKillEntityListener.register();
+//        GameStateChangedListener.register();
+//        LivingEntityDeathListener.register();
+//        PlayerConnectionListener.register();
+//        PlayStateChangedListener.register();
+//        ServerListener.register();
+
+        // kind of mixins
+        ArmorMixin.init(plugin);
+        TooltipMixin.init();
+    }
+
+}
diff --git a/src/main/java/organica/data/OTexts.java b/src/main/java/organica/data/OTexts.java
new file mode 100644
index 0000000000000000000000000000000000000000..2c9a48686c47c7d6590d8a8ab035cd593155910a
--- /dev/null
+++ b/src/main/java/organica/data/OTexts.java
@@ -0,0 +1,282 @@
+package organica.data;
+
+import net.fabricmc.yarn.constants.MiningLevels;
+import net.minecraft.ChatFormatting;
+import net.minecraft.network.chat.CommonComponents;
+import net.minecraft.network.chat.Component;
+import net.minecraft.util.Mth;
+import net.minecraft.world.effect.MobEffect;
+import net.minecraft.world.effect.MobEffectInstance;
+import net.minecraft.world.effect.MobEffectUtil;
+import net.minecraft.world.effect.MobEffects;
+import net.minecraft.world.entity.EquipmentSlot;
+import net.minecraft.world.item.SmithingTemplateItem;
+import net.minecraft.world.item.enchantment.Enchantment;
+import net.minecraft.world.item.ItemStack;
+import organica.Organica;
+import organica.data.effect.ImmortalityStatusEffect;
+import organica.data.effect.OStatusEffects;
+import organica.data.item.OItems;
+
+import java.util.List;
+import java.util.Optional;
+
+import static net.minecraft.network.chat.Component.translatable;
+
+
+public final class OTexts {
+
+
+    public static final class Symbols {
+        private static Component withFont(String font, String text) {
+            return Component.literal(text).withStyle(style -> style
+                    .withFont(Organica.id(font))
+                    .withColor(ChatFormatting.WHITE));
+        }
+
+        public static Component vanillaNormalHeart() {
+            return Component.literal("❤").withStyle(style -> style.withColor(0xff1313));
+        }
+
+        public static Component vanillaAbsorptionHeart() {
+            return Component.literal("❤").withStyle(style -> style.withColor(0xd4af37));
+        }
+
+        public static Component fullNormalHeart() {
+            return withFont("hearts", "0");
+        }
+
+        public static Component halfNormalHeart() {
+            return withFont("hearts", "1");
+        }
+
+        public static Component emptyHeart() {
+            return withFont("hearts", "2");
+        }
+
+        public static Component fullAbsorptionHeart() {
+            return withFont("hearts", "3");
+        }
+
+        public static Component halfAbsorptionHeart() {
+            return withFont("hearts", "4");
+        }
+
+        public static Component heartOffset() {
+            return withFont("hearts", ".");
+        }
+    }
+
+    public static final class Tooltip {
+        public static int ENCHANTMENT_PURPLE = 0xf0ccff;
+        public static int DURABILITY_GRAY = 0x777777;
+
+        public static Component normalHearts(int health) {
+            return hearts(health, Symbols.fullNormalHeart(), Symbols.halfNormalHeart());
+        }
+
+        public static Component absorptionHearts(int health) {
+            return hearts(health, Symbols.fullAbsorptionHeart(), Symbols.halfAbsorptionHeart());
+        }
+
+        public static Component hearts(int health, Component heart, Component halfHeart) {
+            var hearts = health / 2;
+            var count = hearts + (health % 2 == 1 ? ".5" : "");
+            var countText = translatable("hearts.many", heart, count).withStyle(ChatFormatting.WHITE);
+            if (health >= 1 && health <= 20) {
+                var sequenceText = Component.empty();
+                for (var i = 0; i < hearts; i++) {
+                    sequenceText.append(heart);
+                    if (i < hearts - 1) sequenceText.append(Symbols.heartOffset());
+                }
+                if (health % 2 == 1) {
+                    if (hearts > 0) sequenceText.append(Symbols.heartOffset());
+                    sequenceText.append(halfHeart);
+                }
+                return sequenceText;
+            }
+            return countText;
+        }
+
+        public static Component effectClearing() {
+            return translatable("tooltip.effectClearing").withStyle(ChatFormatting.GRAY);
+        }
+
+        public static Component effect(MobEffect effect, int amplifier, int duration) {
+            return effect(new MobEffectInstance(effect, duration, amplifier), 1f, 1f);
+        }
+
+        public static Component effect(MobEffectInstance instance, float durationMultiplier, float chance) {
+            var effect = instance.getEffect();
+            var amplifier = instance.getAmplifier();
+            var duration = instance.getDuration();
+
+            var text = effect.getDisplayName().copy();
+            if (amplifier > 0)
+                text = translatable("potion.withAmplifier", text, translatable("potion.potency." + amplifier));
+            if (duration > 20)
+                text = translatable("potion.withDuration", text, MobEffectUtil.formatDuration(instance, durationMultiplier, 20));
+            if (chance != 1f)
+                text = translatable("potion.withChance", text, ItemStack.ATTRIBUTE_MODIFIER_FORMAT.format(chance * 100f));
+
+            text.withStyle(effect.getCategory().getTooltipFormatting());
+
+            if (effect.equals(MobEffects.REGENERATION)) {
+                var ticksPerHp = 50 >> amplifier;
+                var multipliedDuration = Mth.floor(duration * durationMultiplier);
+                return text.append(" ").append(normalHearts(ticksPerHp > 0 ? multipliedDuration / ticksPerHp : multipliedDuration));
+            }
+            if (effect.equals(MobEffects.ABSORPTION))
+                return text.append(" ").append(absorptionHearts(4 * (amplifier + 1)));
+            if (effect.equals(MobEffects.HEAL))
+                return text.append(" ").append(normalHearts(Math.max(4 << amplifier, 0)));
+
+            return text;
+        }
+
+        public static Component pieces(int count) {
+            return translatable("armorset.pieces." + count).withStyle(ChatFormatting.GRAY);
+        }
+
+        public static Component enchantment(Enchantment enchantment, int level) {
+            return enchantment.getFullname(level).copy().withStyle(ChatFormatting.WHITE);
+        }
+
+        public static Component armorEffect(MobEffect effect, int amplifier) {
+            var effectName = effect.getDisplayName().copy();
+            if (amplifier > 0)
+                effectName.append(" ").append(translatable("potion.potency." + amplifier));
+            return effectName.withStyle(ChatFormatting.WHITE);
+        }
+
+        public static Component armorEffect(MobEffect effect) {
+            return armorEffect(effect, 0);
+        }
+
+        public static Component slot(EquipmentSlot slot) {
+            return translatable("item.modifiers." + slot.getName()).withStyle(ChatFormatting.GRAY);
+        }
+
+        public static Component outOfCombat() {
+            return translatable("armorset.outOfCombat").withStyle(ChatFormatting.GRAY);
+        }
+
+        public static Component carnelianInTheNether(Component text) {
+            return translatable("armorset.organica.carnelian.inTheNether", text).withStyle(ChatFormatting.WHITE);
+        }
+
+        public static Component hematiteIncreasedSpeed() {
+            return translatable("armorset.organica.hematite.increasedSpeed").withStyle(ChatFormatting.WHITE);
+        }
+
+        public static Component hematiteDisabledSprint() {
+            return translatable("armorset.organica.hematite.disabledSprint").withStyle(ChatFormatting.WHITE);
+        }
+
+        public static Component effectTitle(MobEffect effect) {
+            return effect.getDisplayName().plainCopy().withStyle(ChatFormatting.YELLOW);
+        }
+
+        public static Component effectDescription(MobEffect effect, int line) {
+            if (effect.equals(OStatusEffects.IMMORTALITY)) {
+                var hearts = normalHearts(Math.round(ImmortalityStatusEffect.IMMORTALITY_HEALTH));
+                return translatable(effect.getDescriptionId() + ".desc." + line, hearts).withStyle(ChatFormatting.GRAY);
+            }
+            return translatable(effect.getDescriptionId() + ".desc." + line).withStyle(ChatFormatting.GRAY);
+        }
+
+        public static Component enchantmentTitle(Enchantment enchantment) {
+            return translatable(enchantment.getDescriptionId()).withStyle(ChatFormatting.YELLOW);
+        }
+
+        public static Component enchantmentDescription(Enchantment enchantment, int line) {
+            return translatable(enchantment.getDescriptionId() + ".desc." + line).withStyle(ChatFormatting.GRAY);
+        }
+
+        public static Component permanentEnchantment(Enchantment enchantment, int level) {
+            return enchantment.getFullname(level).copy().withStyle(s -> s.withColor(ENCHANTMENT_PURPLE));
+        }
+
+        public static Component durability(int current, int max) {
+            return translatable("tooltip.durability", current, max).withStyle(s -> s.withColor(DURABILITY_GRAY));
+        }
+
+        public static Component attribute(String key, float value) {
+            return translatable("attribute.modifier.equals.0",
+                    ItemStack.ATTRIBUTE_MODIFIER_FORMAT.format(value),
+                    translatable(key))
+                    .withStyle(ChatFormatting.DARK_GREEN);
+        }
+
+        public static Component miningSpeed(float miningSpeed) {
+            return attribute("tool.miningSpeed", miningSpeed);
+        }
+
+        public static Component miningLevel(int miningLevel) {
+            var levelName = switch (miningLevel) {
+                case MiningLevels.HAND -> "hand";
+                case MiningLevels.WOOD -> "wood";
+                case MiningLevels.STONE -> "stone";
+                case MiningLevels.IRON -> "iron";
+                case MiningLevels.DIAMOND -> "diamond";
+                case MiningLevels.NETHERITE -> "netherite";
+                default -> "unknown";
+            };
+            return translatable("tool.miningLevel.%s".formatted(levelName)).withStyle(ChatFormatting.DARK_GREEN);
+        }
+
+        public static Component maxResource(float maxResource) {
+            return attribute("shield.maxResource", maxResource);
+        }
+
+        public static Component regenerationCooldown(int regenerationCooldown) {
+            return attribute("shield.regenerationCooldown", regenerationCooldown / 20f);
+        }
+
+        public static Component disablingDuration(int disablingDuration) {
+            return attribute("shield.disablingDuration", disablingDuration / 20f);
+        }
+
+        public static Component absorbedDamageToTrigger(float absorbedDamageToTrigger) {
+            return translatable("shield.absorbedDamageToTrigger",
+                    Component.literal(ItemStack.ATTRIBUTE_MODIFIER_FORMAT.format(absorbedDamageToTrigger)).withStyle(ChatFormatting.YELLOW))
+                    .withStyle(ChatFormatting.GRAY);
+        }
+
+        public static Component carnelianIgnitesEntitiesInFront() {
+            return translatable("shield.organica.carnelian.ignitesEntitiesInFront").withStyle(ChatFormatting.WHITE);
+        }
+
+        public static Component hackmaniteKnocksBackEntitiesAround() {
+            return translatable("shield.organica.hackmanite.knocksBackEntitiesAround").withStyle(ChatFormatting.WHITE);
+        }
+
+        public static void upgradeSmithingTemplate(List<Component> tooltip) {
+            var titleFormatting = ChatFormatting.GRAY;
+            var descriptionFormatting = ChatFormatting.BLUE;
+            var prefix = "item.organica.upgrade_smithing_template";
+
+            tooltip.add(translatable(prefix + ".equipment_upgrade").withStyle(titleFormatting));
+            tooltip.add(CommonComponents.EMPTY);
+
+            tooltip.add(SmithingTemplateItem.APPLIES_TO_TITLE);
+            tooltip.add(CommonComponents.space().append(translatable(prefix + ".applies_to.diamond_equipment").withStyle(descriptionFormatting)));
+            tooltip.add(CommonComponents.space().append(translatable(prefix + ".applies_to.iron_equipment").withStyle(descriptionFormatting)));
+            tooltip.add(CommonComponents.space().append(translatable(prefix + ".applies_to.crossbow_and_bow").withStyle(descriptionFormatting)));
+            tooltip.add(CommonComponents.space().append(translatable(prefix + ".applies_to.trident").withStyle(descriptionFormatting)));
+
+            tooltip.add(SmithingTemplateItem.INGREDIENTS_TITLE);
+            tooltip.add(CommonComponents.space().append(translatable(OItems.CARNELIAN.getDescriptionId()).withStyle(descriptionFormatting)));
+            tooltip.add(CommonComponents.space().append(translatable(OItems.CITRINE_SHARDS.getDescriptionId()).withStyle(descriptionFormatting)));
+            tooltip.add(CommonComponents.space().append(translatable(OItems.AVENTURINE.getDescriptionId()).withStyle(descriptionFormatting)));
+            tooltip.add(CommonComponents.space().append(translatable(OItems.HEMATITE_INGOT.getDescriptionId()).withStyle(descriptionFormatting)));
+            tooltip.add(CommonComponents.space().append(translatable(OItems.HACKMANITE_CRYSTAL.getDescriptionId()).withStyle(descriptionFormatting)));
+
+            tooltip.add(translatable(prefix + ".ingredient_count").withStyle(titleFormatting));
+            tooltip.add(CommonComponents.space().append(translatable(prefix + ".ingredient_count.armor_and_pickaxe")).withStyle(descriptionFormatting));
+            tooltip.add(CommonComponents.space().append(translatable(prefix + ".ingredient_count.other")).withStyle(descriptionFormatting));
+        }
+    }
+
+
+}
diff --git a/src/main/java/organica/data/effect/BlastProtectionStatusEffect.java b/src/main/java/organica/data/effect/BlastProtectionStatusEffect.java
new file mode 100644
index 0000000000000000000000000000000000000000..43fe5b3fad3802ef2571b4d08d4d4f68a1cbf1d1
--- /dev/null
+++ b/src/main/java/organica/data/effect/BlastProtectionStatusEffect.java
@@ -0,0 +1,21 @@
+package organica.data.effect;
+
+import eu.pb4.polymer.core.api.other.PolymerStatusEffect;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.effect.MobEffect;
+import net.minecraft.world.effect.MobEffects;
+import net.minecraft.world.effect.MobEffectCategory;
+import org.jetbrains.annotations.Nullable;
+
+public class BlastProtectionStatusEffect extends MobEffect implements PolymerStatusEffect {
+
+    public BlastProtectionStatusEffect() {
+        super(MobEffectCategory.BENEFICIAL, 0xE4653A);
+    }
+
+    @Override
+    public @Nullable MobEffect getPolymerReplacement(ServerPlayer player) {
+        return MobEffects.HEAL;
+    }
+
+}
diff --git a/src/main/java/organica/data/effect/ImmortalityStatusEffect.java b/src/main/java/organica/data/effect/ImmortalityStatusEffect.java
new file mode 100644
index 0000000000000000000000000000000000000000..20ef76de5e324ade957d53fe6ee7ae10ef9114ac
--- /dev/null
+++ b/src/main/java/organica/data/effect/ImmortalityStatusEffect.java
@@ -0,0 +1,31 @@
+package organica.data.effect;
+
+import eu.pb4.polymer.core.api.other.PolymerStatusEffect;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.effect.MobEffect;
+import net.minecraft.world.effect.MobEffectCategory;
+import net.minecraft.world.effect.MobEffects;
+import net.minecraft.world.entity.ai.attributes.AttributeMap;
+import org.jetbrains.annotations.Nullable;
+
+public class ImmortalityStatusEffect extends MobEffect implements PolymerStatusEffect {
+    public final static float IMMORTALITY_HEALTH = 6f;
+
+    public ImmortalityStatusEffect() {
+        super(MobEffectCategory.BENEFICIAL, 0xFFFD87);
+    }
+
+    @Override
+    public @Nullable MobEffect getPolymerReplacement(ServerPlayer player) {
+        return MobEffects.SATURATION;
+    }
+
+    public void addAttributeModifiers(AttributeMap attributes, int amplifier) {
+        // @Jerozgen: fixme
+//        var health = entity.getHealth();
+//        if (0 < health && health < IMMORTALITY_HEALTH) {
+//            entity.setHealth(IMMORTALITY_HEALTH);
+//        }
+        super.addAttributeModifiers(attributes, amplifier);
+    }
+}
diff --git a/src/main/java/organica/data/effect/LightweightStatusEffect.java b/src/main/java/organica/data/effect/LightweightStatusEffect.java
new file mode 100644
index 0000000000000000000000000000000000000000..f2924a5eb7520a4165616eda8dff5689a47c5480
--- /dev/null
+++ b/src/main/java/organica/data/effect/LightweightStatusEffect.java
@@ -0,0 +1,21 @@
+package organica.data.effect;
+
+import eu.pb4.polymer.core.api.other.PolymerStatusEffect;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.effect.MobEffect;
+import net.minecraft.world.effect.MobEffectCategory;
+import net.minecraft.world.effect.MobEffects;
+import org.jetbrains.annotations.Nullable;
+
+public class LightweightStatusEffect extends MobEffect implements PolymerStatusEffect {
+
+    public LightweightStatusEffect() {
+        super(MobEffectCategory.BENEFICIAL, 0xC4FFFE);
+    }
+
+    @Override
+    public @Nullable MobEffect getPolymerReplacement(ServerPlayer player) {
+        return MobEffects.LUCK;
+    }
+
+}
diff --git a/src/main/java/organica/data/effect/OStatusEffects.java b/src/main/java/organica/data/effect/OStatusEffects.java
new file mode 100644
index 0000000000000000000000000000000000000000..6288be286183600901e0c5448dbf47a7a181b3d2
--- /dev/null
+++ b/src/main/java/organica/data/effect/OStatusEffects.java
@@ -0,0 +1,20 @@
+package organica.data.effect;
+
+import net.minecraft.core.Registry;
+import net.minecraft.core.registries.BuiltInRegistries;
+import net.minecraft.world.effect.MobEffect;
+import organica.Organica;
+
+public final class OStatusEffects {
+    public static final MobEffect BLAST_RESISTANCE = register("blast_resistance", new BlastProtectionStatusEffect());
+    public static final MobEffect LIGHTWEIGHT = register("lightweight", new LightweightStatusEffect());
+    public static final MobEffect IMMORTALITY = register("immortality", new ImmortalityStatusEffect());
+
+    private static MobEffect register(String id, MobEffect statusEffect) {
+        return Registry.register(BuiltInRegistries.MOB_EFFECT, Organica.id(id), statusEffect);
+    }
+
+    public static void init() {}
+
+    private OStatusEffects() {}
+}
diff --git a/src/main/java/organica/data/enchantment/AccelerationEnchantment.java b/src/main/java/organica/data/enchantment/AccelerationEnchantment.java
new file mode 100644
index 0000000000000000000000000000000000000000..24d75e9b8f9e053cbaef1a5ecfa1d243f0d6acb4
--- /dev/null
+++ b/src/main/java/organica/data/enchantment/AccelerationEnchantment.java
@@ -0,0 +1,41 @@
+package organica.data.enchantment;
+
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.world.entity.EquipmentSlot;
+import net.minecraft.world.item.enchantment.EnchantmentCategory;
+import organica.Organica;
+
+public class AccelerationEnchantment extends OEnchantment {
+
+    public static final int MAX_ACCELERATION_TICKS = 280;
+    public static final float MAX_ACCELERATION = 15f;
+
+    public AccelerationEnchantment(Rarity weight) {
+        super(weight, EnchantmentCategory.DIGGER, EquipmentSlot.MAINHAND);
+    }
+
+    @Override
+    public int getMaxLevel() {
+        return 1;
+    }
+
+    @Override
+    public int getMinCost(int level) {
+        return 20;
+    }
+
+    @Override
+    public int getMaxCost(int level) {
+        return 50;
+    }
+
+    @Override
+    protected int descriptionLines() {
+        return 2;
+    }
+
+    @Override
+    public ResourceLocation getId() {
+        return Organica.id("acceleration");
+    }
+}
diff --git a/src/main/java/organica/data/enchantment/AccuracyEnchantment.java b/src/main/java/organica/data/enchantment/AccuracyEnchantment.java
new file mode 100644
index 0000000000000000000000000000000000000000..fad1df4e954960d735713b64ab8b270bcc0499c1
--- /dev/null
+++ b/src/main/java/organica/data/enchantment/AccuracyEnchantment.java
@@ -0,0 +1,40 @@
+package organica.data.enchantment;
+
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.world.entity.EquipmentSlot;
+import organica.Organica;
+import organica.data.enchantment.etarget.OEnchantmentTarget;
+
+public class AccuracyEnchantment extends OEnchantment {
+    // Можно изменить на 0.5f, если чары окажутся слишком сильными.
+    public static float DIVERGENCE_MULTIPLIER = 0f;
+
+    public AccuracyEnchantment(Rarity weight) {
+        super(weight, OEnchantmentTarget.CROSSBOW_OR_BOW, EquipmentSlot.MAINHAND);
+    }
+
+    @Override
+    public int getMaxLevel() {
+        return 1;
+    }
+
+    @Override
+    public int getMinCost(int level) {
+        return 20;
+    }
+
+    @Override
+    public int getMaxCost(int level) {
+        return 50;
+    }
+
+    @Override
+    protected int descriptionLines() {
+        return 2;
+    }
+
+    @Override
+    public ResourceLocation getId() {
+        return Organica.id("accuracy");
+    }
+}
diff --git a/src/main/java/organica/data/enchantment/AntigravityEnchantment.java b/src/main/java/organica/data/enchantment/AntigravityEnchantment.java
new file mode 100644
index 0000000000000000000000000000000000000000..1595aec3b8e067614e1ce1b632cc691dc03c53d1
--- /dev/null
+++ b/src/main/java/organica/data/enchantment/AntigravityEnchantment.java
@@ -0,0 +1,42 @@
+package organica.data.enchantment;
+
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.world.entity.EquipmentSlot;
+import organica.Organica;
+import organica.data.enchantment.etarget.OEnchantmentTarget;
+
+public class AntigravityEnchantment extends OEnchantment {
+
+    public AntigravityEnchantment(Rarity weight) {
+        super(weight, OEnchantmentTarget.CROSSBOW_OR_BOW, EquipmentSlot.MAINHAND);
+    }
+
+    @Override
+    public int getMaxLevel() {
+        return 1;
+    }
+
+    @Override
+    public int getMinCost(int level) {
+        return 20;
+    }
+
+    @Override
+    public int getMaxCost(int level) {
+        return 50;
+    }
+
+    @Override
+    protected int descriptionLines() {
+        return 2;
+    }
+
+    public static int antigravityTime() {
+        return 5 * 20;
+    }
+
+    @Override
+    public ResourceLocation getId() {
+        return Organica.id("antigravity");
+    }
+}
diff --git a/src/main/java/organica/data/enchantment/BowPiercingEnchantment.java b/src/main/java/organica/data/enchantment/BowPiercingEnchantment.java
new file mode 100644
index 0000000000000000000000000000000000000000..51c94d4960bf3ceb363351eb352f02ebce4ee112
--- /dev/null
+++ b/src/main/java/organica/data/enchantment/BowPiercingEnchantment.java
@@ -0,0 +1,39 @@
+package organica.data.enchantment;
+
+import eu.pb4.polymer.core.api.other.PolymerEnchantment;
+import net.minecraft.Util;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.world.entity.EquipmentSlot;
+import net.minecraft.world.item.Rarity;
+import net.minecraft.world.item.enchantment.Enchantment;
+import net.minecraft.world.item.enchantment.EnchantmentCategory;
+import organica.Organica;
+import organica.data.item.Identifiable;
+
+public class BowPiercingEnchantment extends Enchantment implements Identifiable, PolymerEnchantment {
+
+    public BowPiercingEnchantment(Rarity weight) {
+        super(weight, EnchantmentCategory.BOW, new EquipmentSlot[]{EquipmentSlot.MAINHAND});
+        descriptionId = Util.makeDescriptionId("enchantment", new ResourceLocation("piercing"));
+    }
+
+    @Override
+    public int getMaxLevel() {
+        return 2;
+    }
+
+    @Override
+    public int getMinCost(int level) {
+        return 20 + 10 * (level - 1);
+    }
+
+    @Override
+    public int getMaxCost(int level) {
+        return this.getMinCost(level) + 30;
+    }
+
+    @Override
+    public ResourceLocation getId() {
+        return Organica.id("bow_piercing");
+    }
+}
diff --git a/src/main/java/organica/data/enchantment/BreakerEnchantment.java b/src/main/java/organica/data/enchantment/BreakerEnchantment.java
new file mode 100644
index 0000000000000000000000000000000000000000..f9c5f68506fb26e0d9ee407d3cbe4fd5642f3cee
--- /dev/null
+++ b/src/main/java/organica/data/enchantment/BreakerEnchantment.java
@@ -0,0 +1,58 @@
+package organica.data.enchantment;
+
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.EquipmentSlot;
+import net.minecraft.world.entity.LivingEntity;
+import net.minecraft.world.item.ArmorItem;
+import net.minecraft.world.item.enchantment.EnchantmentCategory;
+import organica.Organica;
+
+public class BreakerEnchantment extends OEnchantment {
+
+    public BreakerEnchantment(Rarity weight) {
+        super(weight, EnchantmentCategory.WEAPON, EquipmentSlot.MAINHAND);
+    }
+
+    @Override
+    public void doPostAttack(LivingEntity user, Entity target, int level) {
+        if (target instanceof LivingEntity livingTarget)
+            for (var slot : EquipmentSlot.values()) {
+                if (!slot.isArmor()) continue;
+                var stack = livingTarget.getItemBySlot(slot);
+                if (!stack.isEmpty() && stack.getItem() instanceof ArmorItem) {
+                    stack.hurtAndBreak(level, livingTarget, entity -> entity.broadcastBreakEvent(slot));
+                }
+            }
+    }
+
+    @Override
+    public int getMinLevel() {
+        return 1;
+    }
+
+    @Override
+    public int getMaxLevel() {
+        return 2;
+    }
+
+    @Override
+    public int getMinCost(int level) {
+        return 12 + 20 * (level - 1);
+    }
+
+    @Override
+    public int getMaxCost(int level) {
+        return this.getMinCost(level) + 50;
+    }
+
+    @Override
+    protected int descriptionLines() {
+        return 2;
+    }
+
+    @Override
+    public ResourceLocation getId() {
+        return Organica.id("breaker");
+    }
+}
diff --git a/src/main/java/organica/data/enchantment/CrossbowFlameEnchantment.java b/src/main/java/organica/data/enchantment/CrossbowFlameEnchantment.java
new file mode 100644
index 0000000000000000000000000000000000000000..cee98f7cfe9b7104e2a041302a20a1fd6cc14518
--- /dev/null
+++ b/src/main/java/organica/data/enchantment/CrossbowFlameEnchantment.java
@@ -0,0 +1,33 @@
+package organica.data.enchantment;
+
+import eu.pb4.polymer.core.api.other.PolymerEnchantment;
+import net.minecraft.Util;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.world.entity.EquipmentSlot;
+import net.minecraft.world.item.enchantment.Enchantment;
+import net.minecraft.world.item.enchantment.EnchantmentCategory;
+import organica.Organica;
+import organica.data.item.Identifiable;
+
+public class CrossbowFlameEnchantment extends Enchantment implements Identifiable, PolymerEnchantment {
+
+    public CrossbowFlameEnchantment(Rarity weight) {
+        super(weight, EnchantmentCategory.CROSSBOW, new EquipmentSlot[]{EquipmentSlot.MAINHAND});
+        descriptionId = Util.makeDescriptionId("enchantment", new ResourceLocation("flame"));
+    }
+
+    @Override
+    public int getMinCost(int level) {
+        return 20;
+    }
+
+    @Override
+    public int getMaxCost(int level) {
+        return 50;
+    }
+
+    @Override
+    public ResourceLocation getId() {
+        return Organica.id("crossbow_flame");
+    }
+}
diff --git a/src/main/java/organica/data/enchantment/DistanceEmpoweredEnchantment.java b/src/main/java/organica/data/enchantment/DistanceEmpoweredEnchantment.java
new file mode 100644
index 0000000000000000000000000000000000000000..076b9470f740ff01faeca66d66e9efd8561b7494
--- /dev/null
+++ b/src/main/java/organica/data/enchantment/DistanceEmpoweredEnchantment.java
@@ -0,0 +1,42 @@
+package organica.data.enchantment;
+
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.world.entity.EquipmentSlot;
+import organica.Organica;
+import organica.data.enchantment.etarget.OEnchantmentTarget;
+
+
+public class DistanceEmpoweredEnchantment extends OEnchantment {
+    public static double MAX_DAMAGE_ADDING_MULTIPLIER = 0.5;
+    public static int MIN_DISTANCE = 16;
+    public static int MAX_DISTANCE = 32;
+
+    public DistanceEmpoweredEnchantment(Rarity weight) {
+        super(weight, OEnchantmentTarget.CROSSBOW_OR_BOW, EquipmentSlot.MAINHAND);
+    }
+
+    @Override
+    public int getMaxLevel() {
+        return 1;
+    }
+
+    @Override
+    public int getMinCost(int level) {
+        return 20;
+    }
+
+    @Override
+    public int getMaxCost(int level) {
+        return 50;
+    }
+
+    @Override
+    protected int descriptionLines() {
+        return 2;
+    }
+
+    @Override
+    public ResourceLocation getId() {
+        return Organica.id("distance_empowered");
+    }
+}
diff --git a/src/main/java/organica/data/enchantment/ExtraShotEnchantment.java b/src/main/java/organica/data/enchantment/ExtraShotEnchantment.java
new file mode 100644
index 0000000000000000000000000000000000000000..5a44deec304caa025f806a72bfa29418c1aeed63
--- /dev/null
+++ b/src/main/java/organica/data/enchantment/ExtraShotEnchantment.java
@@ -0,0 +1,38 @@
+package organica.data.enchantment;
+
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.world.entity.EquipmentSlot;
+import net.minecraft.world.item.enchantment.EnchantmentCategory;
+import organica.Organica;
+
+public class ExtraShotEnchantment extends OEnchantment {
+
+    public ExtraShotEnchantment(Rarity weight) {
+        super(weight, EnchantmentCategory.CROSSBOW, EquipmentSlot.MAINHAND);
+    }
+
+    @Override
+    public int getMaxLevel() {
+        return 2;
+    }
+
+    @Override
+    public int getMinCost(int level) {
+        return 20 + 10 * (level - 1);
+    }
+
+    @Override
+    public int getMaxCost(int level) {
+        return this.getMinCost(level) + 30;
+    }
+
+    @Override
+    protected int descriptionLines() {
+        return 2;
+    }
+
+    @Override
+    public ResourceLocation getId() {
+        return Organica.id("extra_shot");
+    }
+}
diff --git a/src/main/java/organica/data/enchantment/FastFlightEnchantment.java b/src/main/java/organica/data/enchantment/FastFlightEnchantment.java
new file mode 100644
index 0000000000000000000000000000000000000000..4e878611a20edeab67034448b64719434a496271
--- /dev/null
+++ b/src/main/java/organica/data/enchantment/FastFlightEnchantment.java
@@ -0,0 +1,39 @@
+package organica.data.enchantment;
+
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.world.entity.EquipmentSlot;
+import organica.Organica;
+import organica.data.enchantment.etarget.OEnchantmentTarget;
+
+public class FastFlightEnchantment extends OEnchantment {
+    public static float SPEED_MULTIPLIER = 1.5f;
+
+    public FastFlightEnchantment(Rarity weight) {
+        super(weight, OEnchantmentTarget.CROSSBOW_OR_BOW, EquipmentSlot.MAINHAND);
+    }
+
+    @Override
+    public int getMaxLevel() {
+        return 1;
+    }
+
+    @Override
+    public int getMinCost(int level) {
+        return 20;
+    }
+
+    @Override
+    public int getMaxCost(int level) {
+        return 50;
+    }
+
+    @Override
+    protected int descriptionLines() {
+        return 2;
+    }
+
+    @Override
+    public ResourceLocation getId() {
+        return Organica.id("fast_flight");
+    }
+}
diff --git a/src/main/java/organica/data/enchantment/GrabEnchantment.java b/src/main/java/organica/data/enchantment/GrabEnchantment.java
new file mode 100644
index 0000000000000000000000000000000000000000..e973e50139d85d6c272b114a3cb1b47049f37b19
--- /dev/null
+++ b/src/main/java/organica/data/enchantment/GrabEnchantment.java
@@ -0,0 +1,38 @@
+package organica.data.enchantment;
+
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.world.entity.EquipmentSlot;
+import net.minecraft.world.item.enchantment.EnchantmentCategory;
+import organica.Organica;
+
+public class GrabEnchantment extends OEnchantment {
+
+    public GrabEnchantment(Rarity weight) {
+        super(weight, EnchantmentCategory.DIGGER, EquipmentSlot.MAINHAND);
+    }
+
+    @Override
+    public int getMaxLevel() {
+        return 1;
+    }
+
+    @Override
+    public int getMinCost(int level) {
+        return 20;
+    }
+
+    @Override
+    public int getMaxCost(int level) {
+        return 50;
+    }
+
+    @Override
+    protected int descriptionLines() {
+        return 2;
+    }
+
+    @Override
+    public ResourceLocation getId() {
+        return Organica.id("grab");
+    }
+}
diff --git a/src/main/java/organica/data/enchantment/LaminarityEnchantment.java b/src/main/java/organica/data/enchantment/LaminarityEnchantment.java
new file mode 100644
index 0000000000000000000000000000000000000000..3d14e7a99867b4847356b6f87dfe54d91a8170de
--- /dev/null
+++ b/src/main/java/organica/data/enchantment/LaminarityEnchantment.java
@@ -0,0 +1,38 @@
+package organica.data.enchantment;
+
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.world.entity.EquipmentSlot;
+import net.minecraft.world.item.enchantment.EnchantmentCategory;
+import organica.Organica;
+
+public class LaminarityEnchantment extends OEnchantment {
+
+    public LaminarityEnchantment(Rarity weight) {
+        super(weight, EnchantmentCategory.BOW, EquipmentSlot.MAINHAND);
+    }
+
+    @Override
+    public int getMaxLevel() {
+        return 1;
+    }
+
+    @Override
+    public int getMinCost(int level) {
+        return 20;
+    }
+
+    @Override
+    public int getMaxCost(int level) {
+        return 50;
+    }
+
+    @Override
+    protected int descriptionLines() {
+        return 2;
+    }
+
+    @Override
+    public ResourceLocation getId() {
+        return Organica.id("laminarity");
+    }
+}
diff --git a/src/main/java/organica/data/enchantment/OEnchantment.java b/src/main/java/organica/data/enchantment/OEnchantment.java
new file mode 100644
index 0000000000000000000000000000000000000000..bb8e8ade64aa3b41d5efe251faa15b537b7f8aac
--- /dev/null
+++ b/src/main/java/organica/data/enchantment/OEnchantment.java
@@ -0,0 +1,38 @@
+package organica.data.enchantment;
+
+import eu.pb4.polymer.core.api.other.PolymerEnchantment;
+import net.minecraft.network.chat.CommonComponents;
+import net.minecraft.network.chat.Component;
+import net.minecraft.world.entity.EquipmentSlot;
+import net.minecraft.world.item.enchantment.Enchantment;
+import net.minecraft.world.item.enchantment.EnchantmentCategory;
+import org.jetbrains.annotations.NotNull;
+import organica.data.OTexts;
+import organica.paper.data.TextTooltip;
+import organica.data.item.Identifiable;
+
+import java.util.ArrayList;
+import java.util.Collection;
+
+public abstract class OEnchantment extends Enchantment implements PolymerEnchantment, TextTooltip, Identifiable {
+    protected OEnchantment(Rarity weight, EnchantmentCategory type, EquipmentSlot... slots) {
+        super(weight, type, slots);
+    }
+
+    protected abstract int descriptionLines();
+
+    @Override
+    public @NotNull Collection<Component> tooltip() {
+        return tooltip(this, descriptionLines());
+    }
+
+    public static Collection<Component> tooltip(Enchantment enchantment, int lines) {
+        var tooltip = new ArrayList<Component>();
+        tooltip.add(Component.empty());
+        tooltip.add(OTexts.Tooltip.enchantmentTitle(enchantment));
+        for (int i = 0; i < lines; i++) {
+            tooltip.add(CommonComponents.space().append(OTexts.Tooltip.enchantmentDescription(enchantment, i + 1)));
+        }
+        return tooltip;
+    }
+}
diff --git a/src/main/java/organica/data/enchantment/OEnchantmentHelper.java b/src/main/java/organica/data/enchantment/OEnchantmentHelper.java
new file mode 100644
index 0000000000000000000000000000000000000000..a301e26ed6e37df92b6f6c70c378584e0f16888e
--- /dev/null
+++ b/src/main/java/organica/data/enchantment/OEnchantmentHelper.java
@@ -0,0 +1,18 @@
+package organica.data.enchantment;
+
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.MobType;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.enchantment.EnchantmentHelper;
+import net.minecraft.world.item.enchantment.Enchantments;
+
+public class OEnchantmentHelper {
+    // Дополнительный урон с «Пронзания» для сущностей под дождём и в воде.
+    public static float getAttackDamage(ItemStack stack, MobType group, Entity target) {
+        var attackDamage = EnchantmentHelper.getDamageBonus(stack, group);
+        if (target.isInWaterRainOrBubble()) {
+            return attackDamage + EnchantmentHelper.getItemEnchantmentLevel(Enchantments.IMPALING, stack) * 1.2f;
+        }
+        return attackDamage;
+    }
+}
diff --git a/src/main/java/organica/data/enchantment/OEnchantments.java b/src/main/java/organica/data/enchantment/OEnchantments.java
new file mode 100644
index 0000000000000000000000000000000000000000..4e064bae9332a81a15b508d834466764d1b66341
--- /dev/null
+++ b/src/main/java/organica/data/enchantment/OEnchantments.java
@@ -0,0 +1,45 @@
+package organica.data.enchantment;
+
+import eu.pb4.polymer.core.api.block.PolymerBlockUtils;
+import net.minecraft.core.Registry;
+import net.minecraft.core.registries.BuiltInRegistries;
+import net.minecraft.core.registries.Registries;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.world.item.enchantment.Enchantment;
+import net.minecraft.world.item.enchantment.EnchantmentHelper;
+import organica.data.item.Identifiable;
+
+public final class OEnchantments {
+    public static final OEnchantment BREAKER = registerIdentifiable(new BreakerEnchantment(Enchantment.Rarity.RARE));
+    public static final OEnchantment STEADINESS = registerIdentifiable(new SteadinessEnchantment(Enchantment.Rarity.RARE));
+
+    public static final OEnchantment LAMINARITY = registerIdentifiable(new LaminarityEnchantment(Enchantment.Rarity.RARE));
+    public static final OEnchantment ANTIGRAVITY = registerIdentifiable(new AntigravityEnchantment(Enchantment.Rarity.RARE));
+    public static final Enchantment BOW_PIERCING = registerIdentifiable(new BowPiercingEnchantment(Enchantment.Rarity.RARE));
+    public static final OEnchantment FAST_FLIGHT = registerIdentifiable(new FastFlightEnchantment(Enchantment.Rarity.RARE));
+    public static final OEnchantment ACCURACY = registerIdentifiable(new AccuracyEnchantment(Enchantment.Rarity.RARE));
+    public static final OEnchantment DISTANCE_EMPOWERED = registerIdentifiable(new DistanceEmpoweredEnchantment(Enchantment.Rarity.RARE));
+    public static final OEnchantment EXTRA_SHOT = registerIdentifiable(new ExtraShotEnchantment(Enchantment.Rarity.RARE));
+    public static final Enchantment CROSSBOW_FLAME = registerIdentifiable(new CrossbowFlameEnchantment(Enchantment.Rarity.RARE));
+    public static final OEnchantment RUN_AND_GUN = registerIdentifiable(new RunAndGunEnchantment(Enchantment.Rarity.RARE));
+
+    public static final OEnchantment TUNNEL_MINING = registerIdentifiable(new TunnelMiningEnchantment(Enchantment.Rarity.RARE));
+    public static final OEnchantment ACCELERATION = registerIdentifiable(new AccelerationEnchantment(Enchantment.Rarity.RARE));
+    public static final OEnchantment GRAB = registerIdentifiable(new GrabEnchantment(Enchantment.Rarity.RARE));
+    public static final OEnchantment SMELTING_TOUCH = registerIdentifiable(new SmeltingTouchEnchantment(Enchantment.Rarity.RARE));
+
+    private static <T extends Enchantment & Identifiable> T registerIdentifiable(T enchantment) {
+        return register(enchantment.getId(), enchantment);
+    }
+
+    private static <T extends Enchantment> T register(ResourceLocation id, T enchantment) {
+        return Registry.register(BuiltInRegistries.ENCHANTMENT, id, enchantment);
+    }
+
+    public static void init() {
+        PolymerBlockUtils.SERVER_SIDE_MINING_CHECK
+                .register((state, pos, player) -> EnchantmentHelper.getEnchantmentLevel(ACCELERATION, player) > 0);
+    }
+
+    private OEnchantments() {}
+}
diff --git a/src/main/java/organica/data/enchantment/RunAndGunEnchantment.java b/src/main/java/organica/data/enchantment/RunAndGunEnchantment.java
new file mode 100644
index 0000000000000000000000000000000000000000..62ee8b72ea19f2c1667a7c6c9c5d190b94c2c8b9
--- /dev/null
+++ b/src/main/java/organica/data/enchantment/RunAndGunEnchantment.java
@@ -0,0 +1,44 @@
+package organica.data.enchantment;
+
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.world.effect.MobEffectInstance;
+import net.minecraft.world.effect.MobEffects;
+import net.minecraft.world.entity.EquipmentSlot;
+import net.minecraft.world.entity.LivingEntity;
+import net.minecraft.world.item.enchantment.EnchantmentCategory;
+import organica.Organica;
+
+public class RunAndGunEnchantment extends OEnchantment {
+    public RunAndGunEnchantment(Rarity weight) {
+        super(weight, EnchantmentCategory.CROSSBOW, EquipmentSlot.MAINHAND);
+    }
+
+    public static void applyEffects(LivingEntity owner) {
+        owner.addEffect(new MobEffectInstance(MobEffects.MOVEMENT_SPEED, 5 * 20));
+    }
+
+    @Override
+    public int getMaxLevel() {
+        return 1;
+    }
+
+    @Override
+    public int getMinCost(int level) {
+        return 20;
+    }
+
+    @Override
+    public int getMaxCost(int level) {
+        return 50;
+    }
+
+    @Override
+    protected int descriptionLines() {
+        return 2;
+    }
+
+    @Override
+    public ResourceLocation getId() {
+        return Organica.id("run_and_gun");
+    }
+}
diff --git a/src/main/java/organica/data/enchantment/SmeltingTouchEnchantment.java b/src/main/java/organica/data/enchantment/SmeltingTouchEnchantment.java
new file mode 100644
index 0000000000000000000000000000000000000000..5bbf8eee3ba2571b187f178e2f008af4963de23f
--- /dev/null
+++ b/src/main/java/organica/data/enchantment/SmeltingTouchEnchantment.java
@@ -0,0 +1,38 @@
+package organica.data.enchantment;
+
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.world.entity.EquipmentSlot;
+import net.minecraft.world.item.enchantment.EnchantmentCategory;
+import organica.Organica;
+
+public class SmeltingTouchEnchantment extends OEnchantment {
+
+    public SmeltingTouchEnchantment(Rarity weight) {
+        super(weight, EnchantmentCategory.DIGGER, EquipmentSlot.MAINHAND);
+    }
+
+    @Override
+    public int getMaxLevel() {
+        return 1;
+    }
+
+    @Override
+    public int getMinCost(int level) {
+        return 20;
+    }
+
+    @Override
+    public int getMaxCost(int level) {
+        return 50;
+    }
+
+    @Override
+    protected int descriptionLines() {
+        return 2;
+    }
+
+    @Override
+    public ResourceLocation getId() {
+        return Organica.id("smelting_touch");
+    }
+}
diff --git a/src/main/java/organica/data/enchantment/SteadinessEnchantment.java b/src/main/java/organica/data/enchantment/SteadinessEnchantment.java
new file mode 100644
index 0000000000000000000000000000000000000000..864b5fdc6e7bd85826b2e5ae8acd46bf857c8516
--- /dev/null
+++ b/src/main/java/organica/data/enchantment/SteadinessEnchantment.java
@@ -0,0 +1,54 @@
+package organica.data.enchantment;
+
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.world.entity.EquipmentSlot;
+import net.minecraft.world.item.enchantment.Enchantment;
+import net.minecraft.world.item.enchantment.EnchantmentCategory;
+import net.minecraft.world.item.enchantment.Enchantments;
+import organica.Organica;
+
+public class SteadinessEnchantment extends OEnchantment {
+
+    public SteadinessEnchantment(Rarity weight) {
+        super(weight, EnchantmentCategory.WEAPON, EquipmentSlot.MAINHAND);
+    }
+
+    @Override
+    public int getMinLevel() {
+        return 1;
+    }
+
+    @Override
+    public int getMaxLevel() {
+        return 4;
+    }
+
+    @Override
+    public int getMinCost(int level) {
+        return 10 + 9 * (level - 1);
+    }
+
+    @Override
+    public int getMaxCost(int level) {
+        return this.getMinCost(level) + 25;
+    }
+
+    @Override
+    public boolean checkCompatibility(Enchantment other) {
+        return super.checkCompatibility(other) && other != Enchantments.KNOCKBACK;
+    }
+
+    public static double knockbackReductionFactor(int level) {
+        return Math.max((4 - level) / 4., 0);
+    }
+
+    @Override
+    protected int descriptionLines() {
+        return 2;
+    }
+
+    @Override
+    public ResourceLocation getId() {
+        return Organica.id("steadiness");
+    }
+}
diff --git a/src/main/java/organica/data/enchantment/TunnelMiningEnchantment.java b/src/main/java/organica/data/enchantment/TunnelMiningEnchantment.java
new file mode 100644
index 0000000000000000000000000000000000000000..cfbdc16e1d22379d88e4777f99f328fc30c23404
--- /dev/null
+++ b/src/main/java/organica/data/enchantment/TunnelMiningEnchantment.java
@@ -0,0 +1,38 @@
+package organica.data.enchantment;
+
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.world.entity.EquipmentSlot;
+import net.minecraft.world.item.enchantment.EnchantmentCategory;
+import organica.Organica;
+
+public class TunnelMiningEnchantment extends OEnchantment {
+
+    public TunnelMiningEnchantment(Rarity weight) {
+        super(weight, EnchantmentCategory.DIGGER, EquipmentSlot.MAINHAND);
+    }
+
+    @Override
+    public int getMaxLevel() {
+        return 1;
+    }
+
+    @Override
+    public int getMinCost(int level) {
+        return 20;
+    }
+
+    @Override
+    public int getMaxCost(int level) {
+        return 50;
+    }
+
+    @Override
+    protected int descriptionLines() {
+        return 2;
+    }
+
+    @Override
+    public ResourceLocation getId() {
+        return Organica.id("tunnel_mining");
+    }
+}
diff --git a/src/main/java/organica/data/enchantment/etarget/OEnchantmentTarget.java b/src/main/java/organica/data/enchantment/etarget/OEnchantmentTarget.java
new file mode 100644
index 0000000000000000000000000000000000000000..89dcb7d2f6386bbf63f0369235ad83fba78cd909
--- /dev/null
+++ b/src/main/java/organica/data/enchantment/etarget/OEnchantmentTarget.java
@@ -0,0 +1,15 @@
+package organica.data.enchantment.etarget;
+
+import net.minecraft.world.item.BowItem;
+import net.minecraft.world.item.CrossbowItem;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.enchantment.EnchantmentCategory;
+
+public class OEnchantmentTarget {
+    public static final EnchantmentCategory CROSSBOW_OR_BOW = EnchantmentCategory.register(new EnchantmentCategory() {
+        @Override
+        public boolean canEnchant(Item item) {
+            return item instanceof BowItem || item instanceof CrossbowItem;
+        }
+    });
+}
diff --git a/src/main/java/organica/data/item/Identifiable.java b/src/main/java/organica/data/item/Identifiable.java
new file mode 100644
index 0000000000000000000000000000000000000000..8a16e1f1e20b374b379cabcf8904114bfc17767c
--- /dev/null
+++ b/src/main/java/organica/data/item/Identifiable.java
@@ -0,0 +1,7 @@
+package organica.data.item;
+
+import net.minecraft.resources.ResourceLocation;
+
+public interface Identifiable {
+    ResourceLocation getId();
+}
diff --git a/src/main/java/organica/data/item/OItems.java b/src/main/java/organica/data/item/OItems.java
new file mode 100644
index 0000000000000000000000000000000000000000..ce52cea780ae3ac2d61ea14e7edd13b580078548
--- /dev/null
+++ b/src/main/java/organica/data/item/OItems.java
@@ -0,0 +1,251 @@
+package organica.data.item;
+
+//import eu.pb4.polymer.core.api.block.PolymerBlock;
+import eu.pb4.polymer.core.api.item.PolymerItemUtils;
+import net.minecraft.core.Registry;
+import net.minecraft.core.registries.BuiltInRegistries;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.world.food.FoodProperties;
+import net.minecraft.world.item.*;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.item.enchantment.EnchantmentHelper;
+import organica.paper.data.TextTooltip;
+import organica.data.item.armor.*;
+import organica.data.item.pickaxe.*;
+import organica.data.item.shield.*;
+import organica.data.item.weapon.bow.*;
+import organica.data.item.weapon.crossbow.*;
+import organica.data.item.weapon.melee.*;
+
+import static organica.Organica.id;
+
+
+public final class OItems {
+
+//    public static final BlockItem CARNELIAN_ORE = registerBlockItem(OBlocks.CARNELIAN_ORE, Items.STONE);
+//    public static final BlockItem DEEPSLATE_CARNELIAN_ORE = registerBlockItem(OBlocks.DEEPSLATE_CARNELIAN_ORE, Items.DEEPSLATE);
+//    public static final BlockItem CITRINE_ORE = registerBlockItem(OBlocks.CITRINE_ORE, Items.STONE);
+//    public static final BlockItem DEEPSLATE_CITRINE_ORE = registerBlockItem(OBlocks.DEEPSLATE_CITRINE_ORE, Items.DEEPSLATE);
+//    public static final BlockItem AVENTURINE_ORE = registerBlockItem(OBlocks.AVENTURINE_ORE, Items.STONE);
+//    public static final BlockItem DEEPSLATE_AVENTURINE_ORE = registerBlockItem(OBlocks.DEEPSLATE_AVENTURINE_ORE, Items.DEEPSLATE);
+//    public static final BlockItem HEMATITE_ORE = registerBlockItem(OBlocks.HEMATITE_ORE, Items.STONE);
+//    public static final BlockItem DEEPSLATE_HEMATITE_ORE = registerBlockItem(OBlocks.DEEPSLATE_HEMATITE_ORE, Items.DEEPSLATE);
+//    public static final BlockItem HACKMANITE_ORE = registerBlockItem(OBlocks.HACKMANITE_ORE, Items.STONE);
+//    public static final BlockItem DEEPSLATE_HACKMANITE_ORE = registerBlockItem(OBlocks.DEEPSLATE_HACKMANITE_ORE, Items.DEEPSLATE);
+//    public static final BlockItem RAW_HEMATITE_BLOCK = registerBlockItem(OBlocks.RAW_HEMATITE_BLOCK);
+//    public static final BlockItem CARNELIAN_BLOCK = registerBlockItem(OBlocks.CARNELIAN_BLOCK);
+//    public static final BlockItem CITRINE_BLOCK = registerBlockItem(OBlocks.CITRINE_BLOCK);
+//    public static final BlockItem AVENTURINE_BLOCK = registerBlockItem(OBlocks.AVENTURINE_BLOCK);
+//    public static final BlockItem HEMATITE_BLOCK = registerBlockItem(OBlocks.HEMATITE_BLOCK);
+//    public static final BlockItem HACKMANITE_BLOCK = registerBlockItem(OBlocks.HACKMANITE_BLOCK);
+
+    public static final Item CARNELIAN = registerMaterial("carnelian", Items.SCUTE);
+    public static final Item CITRINE_SHARDS = registerMaterial("citrine_shards", Items.NAUTILUS_SHELL);
+    public static final Item AVENTURINE = registerMaterial("aventurine", Items.HEART_OF_THE_SEA);
+    public static final Item AVENTURINE_PIECE = registerMaterial("aventurine_piece");
+    public static final Item RAW_HEMATITE = registerMaterial("raw_hematite");
+    public static final Item HEMATITE_INGOT = registerMaterial("hematite_ingot", Items.SHULKER_SHELL);
+    public static final Item HACKMANITE_CRYSTAL = registerMaterial("hackmanite_crystal", Items.POPPED_CHORUS_FRUIT);
+
+    public static final ArmorItem CARNELIAN_HELMET = registerIdentifiable(new CarnelianArmorItem(ArmorItem.Type.HELMET));
+    public static final ArmorItem CARNELIAN_CHESTPLATE = registerIdentifiable(new CarnelianArmorItem(ArmorItem.Type.CHESTPLATE));
+    public static final ArmorItem CARNELIAN_LEGGINGS = registerIdentifiable(new CarnelianArmorItem(ArmorItem.Type.LEGGINGS));
+    public static final ArmorItem CARNELIAN_BOOTS = registerIdentifiable(new CarnelianArmorItem(ArmorItem.Type.BOOTS));
+    public static final ArmorItem CITRINE_HELMET = registerIdentifiable(new CitrineArmorItem(ArmorItem.Type.HELMET, 0.15));
+    public static final ArmorItem CITRINE_CHESTPLATE = registerIdentifiable(new CitrineArmorItem(ArmorItem.Type.CHESTPLATE, 0.25));
+    public static final ArmorItem CITRINE_LEGGINGS = registerIdentifiable(new CitrineArmorItem(ArmorItem.Type.LEGGINGS, 0.215));
+    public static final ArmorItem CITRINE_BOOTS = registerIdentifiable(new CitrineArmorItem(ArmorItem.Type.BOOTS, 0.125));
+    public static final ArmorItem AVENTURINE_HELMET = registerIdentifiable(new AventurineArmorItem(ArmorItem.Type.HELMET));
+    public static final ArmorItem AVENTURINE_CHESTPLATE = registerIdentifiable(new AventurineArmorItem(ArmorItem.Type.CHESTPLATE));
+    public static final ArmorItem AVENTURINE_LEGGINGS = registerIdentifiable(new AventurineArmorItem(ArmorItem.Type.LEGGINGS));
+    public static final ArmorItem AVENTURINE_BOOTS = registerIdentifiable(new AventurineArmorItem(ArmorItem.Type.BOOTS));
+    public static final ArmorItem HEMATITE_HELMET = registerIdentifiable(new HematiteArmorItem(ArmorItem.Type.HELMET));
+    public static final ArmorItem HEMATITE_CHESTPLATE = registerIdentifiable(new HematiteArmorItem(ArmorItem.Type.CHESTPLATE));
+    public static final ArmorItem HEMATITE_LEGGINGS = registerIdentifiable(new HematiteArmorItem(ArmorItem.Type.LEGGINGS));
+    public static final ArmorItem HEMATITE_BOOTS = registerIdentifiable(new HematiteArmorItem(ArmorItem.Type.BOOTS));
+    public static final ArmorItem HACKMANITE_HELMET = registerIdentifiable(new HackmaniteArmorItem(ArmorItem.Type.HELMET, 0.45));
+    public static final ArmorItem HACKMANITE_CHESTPLATE = registerIdentifiable(new HackmaniteArmorItem(ArmorItem.Type.CHESTPLATE, 0.7));
+    public static final ArmorItem HACKMANITE_LEGGINGS = registerIdentifiable(new HackmaniteArmorItem(ArmorItem.Type.LEGGINGS, 0.6));
+    public static final ArmorItem HACKMANITE_BOOTS = registerIdentifiable(new HackmaniteArmorItem(ArmorItem.Type.BOOTS, 0.35));
+    public static final ArmorItem EMERALD_HELMET = registerIdentifiable(new EmeraldHelmetItem());
+    public static final ArmorItem ENCHANTED_EMERALD_HELMET = registerIdentifiable(new EnchantedEmeraldHelmetItem());
+
+    public static final Item IRON_SHIELD = registerIdentifiable(new IronShieldItem());
+    public static final Item CARNELIAN_SHIELD = registerIdentifiable(new CarnelianShieldItem());
+    public static final Item CITRINE_SHIELD = registerIdentifiable(new CitrineShieldItem());
+    public static final Item AVENTURINE_SHIELD = registerIdentifiable(new AventurineShieldItem());
+    public static final Item HEMATITE_SHIELD = registerIdentifiable(new HematiteShieldItem());
+    public static final Item HACKMANITE_SHIELD = registerIdentifiable(new HackmaniteShieldItem());
+
+    public static final Item IRON_TRIDENT = registerIdentifiable(new IronTridentItem());
+    public static final Item DIAMOND_TRIDENT = registerIdentifiable(new DiamondTridentItem());
+    public static final Item CARNELIAN_AXE = registerIdentifiable(new CarnelianAxeItem());
+    public static final Item CITRINE_SWORD = registerIdentifiable(new CitrineSwordItem());
+    public static final Item AVENTURINE_TRIDENT = registerIdentifiable(new AventurineTridentItem());
+    public static final Item HEMATITE_SWORD = registerIdentifiable(new HematiteSwordItem());
+    public static final Item HACKMANITE_SWORD = registerIdentifiable(new HackmaniteSwordItem());
+
+    public static final Item CARNELIAN_BOW = registerIdentifiable(new CarnelianBowItem());
+    public static final Item CITRINE_BOW = registerIdentifiable(new CitrineBowItem());
+    public static final Item AVENTURINE_BOW = registerIdentifiable(new AventurineBowItem());
+    public static final Item HEMATITE_BOW = registerIdentifiable(new HematiteBowItem());
+    public static final Item HACKMANITE_BOW = registerIdentifiable(new HackmaniteBowItem());
+
+    public static final Item CARNELIAN_CROSSBOW = registerIdentifiable(new CarnelianCrossbowItem());
+    public static final Item CITRINE_CROSSBOW = registerIdentifiable(new CitrineCrossbowItem());
+    public static final Item AVENTURINE_CROSSBOW = registerIdentifiable(new AventurineCrossbowItem());
+    public static final Item HEMATITE_CROSSBOW = registerIdentifiable(new HematiteCrossbowItem());
+    public static final Item HACKMANITE_CROSSBOW = registerIdentifiable(new HackmaniteCrossbowItem());
+
+    public static final Item CARNELIAN_PICKAXE = registerIdentifiable(new CarnelianPickaxeItem());
+    public static final Item CITRINE_PICKAXE = registerIdentifiable(new CitrinePickaxeItem());
+    public static final Item AVENTURINE_PICKAXE = registerIdentifiable(new AventurinePickaxeItem());
+    public static final Item HEMATITE_PICKAXE = registerIdentifiable(new HematitePickaxeItem());
+    public static final Item HACKMANITE_PICKAXE = registerIdentifiable(new HackmanitePickaxeItem());
+
+//    public static final Item BLOODY_APPLE = registerGoldenApple("bloody_apple", OFoodComponents.BLOODY_APPLE);
+//    public static final Item WOODY_APPLE = registerGoldenApple("woody_apple", OFoodComponents.WOODY_APPLE);
+//    public static final Item LUCKY_APPLE = registerGoldenApple("lucky_apple", OFoodComponents.LUCKY_APPLE);
+//
+//    public static final Item UPGRADE_SMITHING_TEMPLATE = registerIdentifiable(new UpgradeSmithingTemplateItem());
+//
+//    public static final Item WORLD_MAP = registerIdentifiable(new EmptyWorldMapItem());
+//    public static final Item FILLED_WORLD_MAP = registerIdentifiable(new FilledWorldMapItem());
+//
+//    public static final Item SUPPLY_BOX = registerIdentifiable(new SupplyBoxItem());
+
+    public static void init() {
+        PolymerItemUtils.ITEM_CHECK.register(stack -> {
+            // Прочность разрушаемых предметов
+            if (stack.isDamageableItem()) return true;
+
+            // Эффекты пищи, зелий, стрел
+            if (stack.isEdible()) return true;
+            if (stack.getItem() instanceof PotionItem) return true;
+            if (stack.getItem() instanceof TippedArrowItem) return true;
+
+            // Дополнительные описания (тотем бессмертия)
+            if (stack.getItem().tooltip() != null) return true;
+
+            // Постоянные чары
+            if (stack.getItem() instanceof PermanentEnchantmentContainer) return true;
+
+            // Изменённый урон у топоров
+            if (stack.getItem() instanceof AxeItem) return true;
+
+            // Характеристики инструмента
+            if (stack.getItem() instanceof TieredItem) return true;
+
+            // Характеристики щита
+            if (stack.getItem() instanceof OShieldItem) return true;
+
+            // «Неразрушаемый» для предметов я отрицательной прочностью
+            if (stack.getMaxDamage() < 0) return true;
+
+            // Описание чар
+            if (stack.getItem() instanceof EnchantedBookItem && EnchantedBookItem.getEnchantments(stack).stream()
+                    .anyMatch(element -> BuiltInRegistries.ENCHANTMENT
+                            .getOptional(EnchantmentHelper.getEnchantmentId((CompoundTag) element))
+                            .filter(e -> e instanceof TextTooltip)
+                            .isPresent())) return true;
+            return stack.getEnchantmentTags().stream()
+                    .anyMatch(element -> BuiltInRegistries.ENCHANTMENT
+                            .getOptional(EnchantmentHelper.getEnchantmentId((CompoundTag) element))
+                            .filter(e -> e instanceof TextTooltip)
+                            .isPresent());
+        });
+
+        modifyItemGroups();
+    }
+
+    @SuppressWarnings({"UnstableApiUsage", "CodeBlock2Expr"})
+    private static void modifyItemGroups() {
+//        ItemGroupEvents.modifyEntriesEvent(CreativeModeTabs.BUILDING_BLOCKS).register(entries -> {
+//            entries.addAfter(Items.NETHERITE_BLOCK,
+//                    CARNELIAN_BLOCK, CITRINE_BLOCK, AVENTURINE_BLOCK, HEMATITE_BLOCK, HACKMANITE_BLOCK);
+//        });
+//        ItemGroupEvents.modifyEntriesEvent(CreativeModeTabs.NATURAL_BLOCKS).register(entries -> {
+//            entries.addAfter(Items.DEEPSLATE_DIAMOND_ORE,
+//                    CARNELIAN_ORE, DEEPSLATE_CARNELIAN_ORE,
+//                    CITRINE_ORE, DEEPSLATE_CITRINE_ORE,
+//                    AVENTURINE_ORE, DEEPSLATE_AVENTURINE_ORE,
+//                    HEMATITE_ORE, DEEPSLATE_HEMATITE_ORE,
+//                    HACKMANITE_ORE, DEEPSLATE_HACKMANITE_ORE);
+//            entries.addAfter(Items.RAW_GOLD_BLOCK, RAW_HEMATITE_BLOCK);
+//        });
+//        ItemGroupEvents.modifyEntriesEvent(CreativeModeTabs.TOOLS_AND_UTILITIES).register(entries -> {
+//            entries.addAfter(Items.MAP, WORLD_MAP);
+//            entries.addAfter(Items.NETHERITE_HOE,
+//                    CARNELIAN_PICKAXE, CITRINE_PICKAXE, AVENTURINE_PICKAXE, HEMATITE_PICKAXE, HACKMANITE_PICKAXE);
+//        });
+//        ItemGroupEvents.modifyEntriesEvent(CreativeModeTabs.COMBAT).register(entries -> {
+//            entries.addAfter(Items.NETHERITE_SWORD, CITRINE_SWORD, HEMATITE_SWORD, HACKMANITE_SWORD);
+//            entries.addAfter(Items.NETHERITE_AXE, CARNELIAN_AXE);
+//            entries.addAfter(Items.TRIDENT, IRON_TRIDENT, DIAMOND_TRIDENT, AVENTURINE_TRIDENT);
+//            entries.addAfter(Items.NETHERITE_BOOTS,
+//                    CARNELIAN_HELMET, CARNELIAN_CHESTPLATE, CARNELIAN_LEGGINGS, CARNELIAN_BOOTS,
+//                    CITRINE_HELMET, CITRINE_CHESTPLATE, CITRINE_LEGGINGS, CITRINE_BOOTS,
+//                    AVENTURINE_HELMET, AVENTURINE_CHESTPLATE, AVENTURINE_LEGGINGS, AVENTURINE_BOOTS,
+//                    HEMATITE_HELMET, HEMATITE_CHESTPLATE, HEMATITE_LEGGINGS, HEMATITE_BOOTS,
+//                    HACKMANITE_HELMET, HACKMANITE_CHESTPLATE, HACKMANITE_LEGGINGS, HACKMANITE_BOOTS);
+//            entries.addAfter(Items.TURTLE_HELMET, EMERALD_HELMET, ENCHANTED_EMERALD_HELMET);
+//            entries.addAfter(Items.BOW,
+//                    CARNELIAN_BOW, CITRINE_BOW, AVENTURINE_BOW, HEMATITE_BOW, HACKMANITE_BOW);
+//            entries.addAfter(Items.CROSSBOW,
+//                    CARNELIAN_CROSSBOW, CITRINE_CROSSBOW, AVENTURINE_CROSSBOW, HEMATITE_CROSSBOW, HACKMANITE_CROSSBOW);
+//            entries.addAfter(Items.SHIELD, IRON_SHIELD,
+//                    CARNELIAN_SHIELD, CITRINE_SHIELD, AVENTURINE_SHIELD, HEMATITE_SHIELD, HACKMANITE_SHIELD);
+//        });
+//        ItemGroupEvents.modifyEntriesEvent(CreativeModeTabs.FOOD_AND_DRINKS).register(entries -> {
+//            entries.addAfter(Items.GOLDEN_APPLE, LUCKY_APPLE, WOODY_APPLE, BLOODY_APPLE);
+//        });
+//        ItemGroupEvents.modifyEntriesEvent(CreativeModeTabs.INGREDIENTS).register(entries -> {
+//            entries.addAfter(Items.RAW_GOLD, RAW_HEMATITE);
+//            entries.addAfter(Items.DIAMOND, CARNELIAN, CITRINE_SHARDS, HACKMANITE_CRYSTAL);
+//            entries.addAfter(Items.GOLD_INGOT, HEMATITE_INGOT, AVENTURINE_PIECE, AVENTURINE);
+//            entries.addAfter(Items.NETHERITE_UPGRADE_SMITHING_TEMPLATE, UPGRADE_SMITHING_TEMPLATE);
+//        });
+//        ItemGroupEvents.modifyEntriesEvent(CreativeModeTabs.OP_BLOCKS).register(entries -> {
+//            entries.add(SUPPLY_BOX);
+//        });
+    }
+
+//    private static Item registerGoldenApple(String path, FoodProperties foodComponent) {
+//        var settings = new Item.Properties()
+//                .rarity(Rarity.RARE)
+//                .food(foodComponent);
+//        return registerIdentifiable(new TexturedPolymerItem(settings, Items.GOLDEN_APPLE, id(path)));
+//    }
+
+    private static Item registerMaterial(String path) {
+        return registerMaterial(path, Items.SHULKER_SHELL);
+    }
+
+    // Позволяет указать другой виртуальный предмет для отображения
+    // корректной отделки на стойке для брони в кузнечном столе.
+    private static Item registerMaterial(String path, Item virtualItem) {
+        return registerIdentifiable(new TexturedPolymerItem(new Item.Properties(), virtualItem, id(path)));
+    }
+
+//    private static BlockItem registerBlockItem(Block block) {
+//        return registerBlockItem(block, ((PolymerBlock) block).getPolymerBlock(block.defaultBlockState()).asItem());
+//    }
+
+//    private static BlockItem registerBlockItem(Block block, Item virtualItem) {
+//        return registerIdentifiable(new TexturedPolymerBlockItem(block, new Item.Properties(), virtualItem, BuiltInRegistries.BLOCK.getId(block)));
+//    }
+
+    private static <T extends Item & Identifiable> T registerIdentifiable(T item) {
+        return register(item.getId(), item);
+    }
+
+    private static <T extends Item> T register(ResourceLocation id, T item) {
+        if (item instanceof BlockItem blockItem) {
+            blockItem.registerBlocks(Item.BY_BLOCK, item);
+        }
+        return Registry.register(BuiltInRegistries.ITEM, id, item);
+    }
+
+    private OItems() {}
+}
diff --git a/src/main/java/organica/data/item/PermanentEnchantmentContainer.java b/src/main/java/organica/data/item/PermanentEnchantmentContainer.java
new file mode 100644
index 0000000000000000000000000000000000000000..c2194d56355ec2be4fb3b0cacb884823efffa302
--- /dev/null
+++ b/src/main/java/organica/data/item/PermanentEnchantmentContainer.java
@@ -0,0 +1,11 @@
+package organica.data.item;
+
+import net.minecraft.world.item.enchantment.Enchantment;
+
+import java.util.Map;
+
+public interface PermanentEnchantmentContainer {
+
+    Map<Enchantment, Integer> permanentEnchantments();
+
+}
diff --git a/src/main/java/organica/data/item/TexturedPolymerItem.java b/src/main/java/organica/data/item/TexturedPolymerItem.java
new file mode 100644
index 0000000000000000000000000000000000000000..d2fb42c83c1bbdea3205254ac0f3f77595df603f
--- /dev/null
+++ b/src/main/java/organica/data/item/TexturedPolymerItem.java
@@ -0,0 +1,31 @@
+package organica.data.item;
+
+import eu.pb4.polymer.core.api.item.SimplePolymerItem;
+import eu.pb4.polymer.resourcepack.api.PolymerModelData;
+import eu.pb4.polymer.resourcepack.api.PolymerResourcePackUtils;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.ItemStack;
+import org.jetbrains.annotations.Nullable;
+
+public class TexturedPolymerItem extends SimplePolymerItem implements Identifiable {
+    private final ResourceLocation id;
+    private final PolymerModelData polymerModelData;
+
+    public TexturedPolymerItem(Item.Properties settings, Item polymerItem, ResourceLocation id) {
+        super(settings, polymerItem);
+        this.id = id;
+        this.polymerModelData = PolymerResourcePackUtils.requestModel(polymerItem, id.withPrefix("item/"));
+    }
+
+    @Override
+    public int getPolymerCustomModelData(ItemStack itemStack, @Nullable ServerPlayer player) {
+        return polymerModelData.value();
+    }
+
+    @Override
+    public ResourceLocation getId() {
+        return id;
+    }
+}
diff --git a/src/main/java/organica/data/item/armor/ArmorModels.java b/src/main/java/organica/data/item/armor/ArmorModels.java
new file mode 100644
index 0000000000000000000000000000000000000000..ecbbbaf81c1c6549ec9830af2c516c15d0a2ca5d
--- /dev/null
+++ b/src/main/java/organica/data/item/armor/ArmorModels.java
@@ -0,0 +1,21 @@
+package organica.data.item.armor;
+
+import eu.pb4.polymer.resourcepack.api.PolymerArmorModel;
+import eu.pb4.polymer.resourcepack.api.PolymerResourcePackUtils;
+import organica.Organica;
+
+public final class ArmorModels {
+    public static final PolymerArmorModel CARNELIAN = register("carnelian");
+    public static final PolymerArmorModel CITRINE = register("citrine");
+    public static final PolymerArmorModel AVENTURINE = register("aventurine");
+    public static final PolymerArmorModel HEMATITE = register("hematite");
+    public static final PolymerArmorModel HACKMANITE = register("hackmanite");
+    public static final PolymerArmorModel EMERALD = register("emerald");
+    public static final PolymerArmorModel ENCHANTED_EMERALD = register("enchanted_emerald");
+
+    private static PolymerArmorModel register(String path) {
+        return PolymerResourcePackUtils.requestArmor(Organica.id(path));
+    }
+
+    private ArmorModels() {}
+}
diff --git a/src/main/java/organica/data/item/armor/AventurineArmorItem.java b/src/main/java/organica/data/item/armor/AventurineArmorItem.java
new file mode 100644
index 0000000000000000000000000000000000000000..15450c73ef4100d1ae413f553d6d77cc726cc352
--- /dev/null
+++ b/src/main/java/organica/data/item/armor/AventurineArmorItem.java
@@ -0,0 +1,16 @@
+package organica.data.item.armor;
+
+import organica.data.item.armor.armorset.ArmorSets;
+import organica.data.item.armor.material.OArmorMaterials;
+
+public class AventurineArmorItem extends OArmorItem {
+    public AventurineArmorItem(Type type) {
+        super(
+                OArmorMaterials.AVENTURINE,
+                type,
+                new Properties(),
+                ArmorSets.AVENTURINE,
+                ArmorModels.AVENTURINE,
+                null);
+    }
+}
diff --git a/src/main/java/organica/data/item/armor/CarnelianArmorItem.java b/src/main/java/organica/data/item/armor/CarnelianArmorItem.java
new file mode 100644
index 0000000000000000000000000000000000000000..b3ad1a1f5e6b4f28017cc1747c52548ac65045c9
--- /dev/null
+++ b/src/main/java/organica/data/item/armor/CarnelianArmorItem.java
@@ -0,0 +1,16 @@
+package organica.data.item.armor;
+
+import organica.data.item.armor.armorset.ArmorSets;
+import organica.data.item.armor.material.OArmorMaterials;
+
+public class CarnelianArmorItem extends OArmorItem {
+    public CarnelianArmorItem(Type type) {
+        super(
+                OArmorMaterials.CARNELIAN,
+                type,
+                new Properties().fireResistant(),
+                ArmorSets.CARNELIAN,
+                ArmorModels.CARNELIAN,
+                null);
+    }
+}
diff --git a/src/main/java/organica/data/item/armor/CitrineArmorItem.java b/src/main/java/organica/data/item/armor/CitrineArmorItem.java
new file mode 100644
index 0000000000000000000000000000000000000000..aeab268dea6283c712f806f3b9425a24a6c0f567
--- /dev/null
+++ b/src/main/java/organica/data/item/armor/CitrineArmorItem.java
@@ -0,0 +1,23 @@
+package organica.data.item.armor;
+
+import net.minecraft.world.entity.ai.attributes.AttributeModifier;
+import net.minecraft.world.entity.ai.attributes.Attributes;
+import net.minecraft.world.item.Item;
+import organica.data.item.armor.armorset.ArmorSets;
+import organica.data.item.armor.material.OArmorMaterials;
+
+
+public class CitrineArmorItem extends OArmorItem {
+    public CitrineArmorItem(Type type, double attackSpeed) {
+        super(
+                OArmorMaterials.CITRINE,
+                type,
+                new Item.Properties(),
+                ArmorSets.CITRINE,
+                ArmorModels.CITRINE,
+                (attributeModifiers, uuid) -> {
+                    var modifier = new AttributeModifier(uuid, "Armor attack speed", attackSpeed, AttributeModifier.Operation.ADDITION);
+                    attributeModifiers.put(Attributes.ATTACK_SPEED, modifier);
+                });
+    }
+}
diff --git a/src/main/java/organica/data/item/armor/EmeraldHelmetItem.java b/src/main/java/organica/data/item/armor/EmeraldHelmetItem.java
new file mode 100644
index 0000000000000000000000000000000000000000..1feff391bfee7d0e69ecbb635ea31a61030aed4b
--- /dev/null
+++ b/src/main/java/organica/data/item/armor/EmeraldHelmetItem.java
@@ -0,0 +1,16 @@
+package organica.data.item.armor;
+
+import organica.data.item.armor.armorset.ArmorSets;
+import organica.data.item.armor.material.OArmorMaterials;
+
+public class EmeraldHelmetItem extends OArmorItem {
+    public EmeraldHelmetItem() {
+        super(
+                OArmorMaterials.EMERALD,
+                Type.HELMET,
+                new Properties(),
+                ArmorSets.EMERALD,
+                ArmorModels.EMERALD,
+                null);
+    }
+}
diff --git a/src/main/java/organica/data/item/armor/EnchantedEmeraldHelmetItem.java b/src/main/java/organica/data/item/armor/EnchantedEmeraldHelmetItem.java
new file mode 100644
index 0000000000000000000000000000000000000000..89cffe7ea34820579559a3ea40d4159132fd89f3
--- /dev/null
+++ b/src/main/java/organica/data/item/armor/EnchantedEmeraldHelmetItem.java
@@ -0,0 +1,23 @@
+package organica.data.item.armor;
+
+import net.minecraft.world.item.ItemStack;
+import organica.data.item.armor.armorset.ArmorSets;
+import organica.data.item.armor.material.OArmorMaterials;
+
+public class EnchantedEmeraldHelmetItem extends OArmorItem {
+    public EnchantedEmeraldHelmetItem() {
+        super(
+                OArmorMaterials.EMERALD_BLOCK,
+                Type.HELMET,
+                new Properties(),
+                ArmorSets.EMERALD_BLOCK,
+                ArmorModels.ENCHANTED_EMERALD,
+                null);
+    }
+
+    @Override
+    public boolean isFoil(ItemStack stack) {
+        return true;
+    }
+
+}
diff --git a/src/main/java/organica/data/item/armor/HackmaniteArmorItem.java b/src/main/java/organica/data/item/armor/HackmaniteArmorItem.java
new file mode 100644
index 0000000000000000000000000000000000000000..806caa8a0f61ba64269be5cc523b7632e4a4ee1d
--- /dev/null
+++ b/src/main/java/organica/data/item/armor/HackmaniteArmorItem.java
@@ -0,0 +1,21 @@
+package organica.data.item.armor;
+
+import net.minecraft.world.entity.ai.attributes.Attributes;
+import organica.data.item.armor.armorset.ArmorSets;
+import organica.data.item.armor.material.OArmorMaterials;
+import net.minecraft.world.entity.ai.attributes.AttributeModifier;
+
+public class HackmaniteArmorItem extends OArmorItem {
+    public HackmaniteArmorItem(Type type, double attackDamage) {
+        super(
+                OArmorMaterials.HACKMANITE,
+                type,
+                new Properties(),
+                ArmorSets.HACKMANITE,
+                ArmorModels.HACKMANITE,
+                (attributeModifiers, uuid) -> {
+                    var modifier = new AttributeModifier(uuid, "Armor attack damage", attackDamage, AttributeModifier.Operation.ADDITION);
+                    attributeModifiers.put(Attributes.ATTACK_DAMAGE, modifier);
+                });
+    }
+}
diff --git a/src/main/java/organica/data/item/armor/HematiteArmorItem.java b/src/main/java/organica/data/item/armor/HematiteArmorItem.java
new file mode 100644
index 0000000000000000000000000000000000000000..6b31186c21422444c09263332632a007bb732c6e
--- /dev/null
+++ b/src/main/java/organica/data/item/armor/HematiteArmorItem.java
@@ -0,0 +1,16 @@
+package organica.data.item.armor;
+
+import organica.data.item.armor.armorset.ArmorSets;
+import organica.data.item.armor.material.OArmorMaterials;
+
+public class HematiteArmorItem extends OArmorItem {
+    public HematiteArmorItem(Type type) {
+        super(
+                OArmorMaterials.HEMATITE,
+                type,
+                new Properties(),
+                ArmorSets.HEMATITE,
+                ArmorModels.HEMATITE,
+                null);
+    }
+}
diff --git a/src/main/java/organica/data/item/armor/OArmorItem.java b/src/main/java/organica/data/item/armor/OArmorItem.java
new file mode 100644
index 0000000000000000000000000000000000000000..29dd30e788ca6e775aba29bd505a92208afea60b
--- /dev/null
+++ b/src/main/java/organica/data/item/armor/OArmorItem.java
@@ -0,0 +1,113 @@
+package organica.data.item.armor;
+
+import com.google.common.collect.HashMultimap;
+import com.google.common.collect.Multimap;
+import eu.pb4.polymer.core.api.item.PolymerItem;
+import eu.pb4.polymer.resourcepack.api.PolymerArmorModel;
+import eu.pb4.polymer.resourcepack.api.PolymerModelData;
+import eu.pb4.polymer.resourcepack.api.PolymerResourcePackUtils;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.entity.EquipmentSlot;
+import net.minecraft.world.entity.ai.attributes.Attribute;
+import net.minecraft.world.entity.ai.attributes.AttributeModifier;
+import net.minecraft.world.entity.ai.attributes.Attributes;
+import net.minecraft.world.item.*;
+import org.jetbrains.annotations.Nullable;
+import organica.Organica;
+import organica.data.item.Identifiable;
+import organica.paper.data.item.armor.armorset.ArmorSet;
+
+import java.util.UUID;
+import java.util.function.BiConsumer;
+
+public class OArmorItem extends ArmorItem implements PolymerItem, Identifiable {
+    private final ResourceLocation id;
+    private final ArmorSet armorSet;
+    private final PolymerArmorModel polymerArmorModel;
+    private final Item polymerItem;
+    private final PolymerModelData polymerModelData;
+    private final Multimap<Attribute, AttributeModifier> attributeModifiers;
+
+    public OArmorItem(ArmorMaterial material, ArmorItem.Type type, Properties settings, ArmorSet armorSet, PolymerArmorModel polymerArmorModel,
+                      @Nullable BiConsumer<Multimap<Attribute, AttributeModifier>, UUID> extraAttributes) {
+        super(material, type, settings);
+        this.armorSet = armorSet;
+        this.polymerArmorModel = polymerArmorModel;
+        this.polymerItem = switch (type.getSlot()) {
+            case HEAD -> Items.LEATHER_HELMET;
+            case CHEST -> Items.LEATHER_CHESTPLATE;
+            case LEGS -> Items.LEATHER_LEGGINGS;
+            case FEET -> Items.LEATHER_BOOTS;
+            default -> throw new IllegalStateException("Unexpected value: " + type.getSlot());
+        };
+        this.id = Organica.id(polymerArmorModel.modelPath().getPath() + "_" + type.getName());
+        this.polymerModelData = PolymerResourcePackUtils.requestModel(polymerItem, id.withPrefix("item/"));
+        this.attributeModifiers = HashMultimap.create(super.getDefaultAttributeModifiers(type.getSlot()));
+        if (extraAttributes != null) {
+            var armorModifier = attributeModifiers.get(Attributes.ARMOR).stream().findFirst();
+            armorModifier.ifPresent(modifier -> extraAttributes.accept(attributeModifiers, modifier.getId()));
+        }
+    }
+
+    public ArmorSet getArmorSet() {
+        return armorSet;
+    }
+
+    @Override
+    public ResourceLocation getId() {
+        return id;
+    }
+
+    @Override
+    public Item getPolymerItem(ItemStack itemStack, @Nullable ServerPlayer player) {
+        return polymerItem;
+    }
+
+    @Override
+    public int getPolymerArmorColor(ItemStack itemStack, @Nullable ServerPlayer player) {
+        return polymerArmorModel.color();
+    }
+
+    @Override
+    public int getPolymerCustomModelData(ItemStack itemStack, @Nullable ServerPlayer player) {
+        return polymerModelData.value();
+    }
+
+    @Override
+    public Multimap<Attribute, AttributeModifier> getDefaultAttributeModifiers(EquipmentSlot slot) {
+        if (slot == this.type.getSlot()) {
+            return attributeModifiers;
+        }
+        return super.getDefaultAttributeModifiers(slot);
+    }
+
+    // Enchants an item with enchantments from its set.
+    @Override
+    public ItemStack getPolymerItemStack(ItemStack itemStack, TooltipFlag context, @Nullable ServerPlayer player) {
+        var resultStack = PolymerItem.super.getPolymerItemStack(itemStack, context, player);
+        if (player == null) return resultStack;
+
+        var nbt = itemStack.getOrCreateTag();
+        if (!nbt.contains(ArmorSet.ITEM_STACK_UUID)) return resultStack;
+        try {
+            var uuid = nbt.getUUID(ArmorSet.ITEM_STACK_UUID);
+            var armorSetPieces = player.getArmorSetPieces(armorSet);
+            player.getArmorSlots().forEach(armorStack -> {
+                var nbtArmor = armorStack.getOrCreateTag();
+                if (!nbtArmor.contains(ArmorSet.ITEM_STACK_UUID)) return;
+                try {
+                    var uuidArmor = nbtArmor.getUUID(ArmorSet.ITEM_STACK_UUID);
+                    if (!uuid.equals(uuidArmor)) return;
+
+                    armorSet.polymerEnchant(resultStack, armorSetPieces);
+                } catch (IllegalArgumentException ignored) {}
+            });
+        } catch (IllegalArgumentException ignored) {}
+        return resultStack;
+    }
+
+    public ArmorSet armorSet() {
+        return armorSet;
+    }
+}
diff --git a/src/main/java/organica/data/item/armor/armorset/ArmorSets.java b/src/main/java/organica/data/item/armor/armorset/ArmorSets.java
new file mode 100644
index 0000000000000000000000000000000000000000..ef5a46f745b0d772dbee41064ee6ce578f0af897
--- /dev/null
+++ b/src/main/java/organica/data/item/armor/armorset/ArmorSets.java
@@ -0,0 +1,25 @@
+package organica.data.item.armor.armorset;
+
+import net.fabricmc.fabric.api.entity.event.v1.ServerEntityWorldChangeEvents;
+import organica.paper.data.item.armor.armorset.ArmorSet;
+
+public final class ArmorSets {
+    public static final ArmorSet CARNELIAN = new CarnelianArmorSet();
+    public static final ArmorSet CITRINE = new CitrineArmorSet();
+    public static final ArmorSet AVENTURINE = new AventurineArmorSet();
+    public static final ArmorSet HEMATITE = new HematiteArmorSet();
+    public static final ArmorSet HACKMANITE = new HackmaniteArmorSet();
+
+    public static final ArmorSet EMERALD = new EmeraldArmorSet();
+    public static final ArmorSet EMERALD_BLOCK = new EmeraldBlockArmorSet();
+
+    public static void init() {
+        ServerEntityWorldChangeEvents.AFTER_PLAYER_CHANGE_WORLD.register((player, origin, destination) -> {
+            player.getArmorSets().forEach((armorSet, pieces) -> {
+                armorSet.onWorldChanged(player, pieces, origin, destination);
+            });
+        });
+    }
+
+    private ArmorSets() {}
+}
diff --git a/src/main/java/organica/data/item/armor/armorset/AventurineArmorSet.java b/src/main/java/organica/data/item/armor/armorset/AventurineArmorSet.java
new file mode 100644
index 0000000000000000000000000000000000000000..eb5b601970175273b6388dab2bcb1839a45212b6
--- /dev/null
+++ b/src/main/java/organica/data/item/armor/armorset/AventurineArmorSet.java
@@ -0,0 +1,84 @@
+package organica.data.item.armor.armorset;
+
+import net.minecraft.network.chat.Component;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.effect.MobEffects;
+import net.minecraft.world.entity.LivingEntity;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.enchantment.Enchantments;
+import org.jetbrains.annotations.NotNull;
+import organica.data.OTexts;
+import organica.paper.data.item.armor.armorset.ArmorSet;
+
+import java.util.Collection;
+import java.util.List;
+
+public class AventurineArmorSet extends ArmorSet {
+
+    @Override
+    public void onEquipped(LivingEntity entity, ItemStack stack, int pieces) {
+        createUuidNbt(stack);
+        switch (pieces) {
+            case 2 -> enableEffect(entity, MobEffects.CONDUIT_POWER);
+            case 3 -> {
+                if (!entity.getCombatTracker().wasRecentlyAttacked()) {
+                    enableEffect(entity, MobEffects.REGENERATION);
+                }
+            }
+        }
+        if (entity instanceof ServerPlayer player) {
+            player.containerMenu.sendAllDataToRemote();
+        }
+    }
+
+    @Override
+    public void onUnequipped(LivingEntity entity, int pieces) {
+        switch (pieces) {
+            case 1 -> disableEffect(entity, MobEffects.CONDUIT_POWER);
+            case 2 -> disableEffect(entity, MobEffects.REGENERATION);
+        }
+        if (entity instanceof ServerPlayer player) {
+            player.containerMenu.sendAllDataToRemote();
+        }
+    }
+
+    @Override
+    public void onEnterCombat(LivingEntity entity, int pieces) {
+        if (pieces >= 3) {
+            disableEffect(entity, MobEffects.REGENERATION);
+        }
+    }
+
+    @Override
+    public void onEndCombat(LivingEntity entity, int pieces) {
+        if (pieces >= 3) {
+            enableEffect(entity, MobEffects.REGENERATION);
+        }
+    }
+
+    @Override
+    public void polymerEnchant(ItemStack stack, int pieces) {
+        stack.enchant(Enchantments.AQUA_AFFINITY, 1);
+        if (pieces >= 3) {
+            stack.enchant(Enchantments.DEPTH_STRIDER, 2);
+        }
+    }
+
+    @Override
+    public @NotNull Collection<Component> tooltip() {
+        return List.of(
+                Component.empty(),
+                OTexts.Tooltip.pieces(1),
+                Component.literal(" ").append(OTexts.Tooltip.enchantment(Enchantments.AQUA_AFFINITY, 1)),
+
+                Component.empty(),
+                OTexts.Tooltip.pieces(2),
+                Component.literal(" ").append(OTexts.Tooltip.armorEffect(MobEffects.CONDUIT_POWER)),
+
+                Component.empty(),
+                OTexts.Tooltip.pieces(3),
+                Component.literal(" ").append(OTexts.Tooltip.enchantment(Enchantments.DEPTH_STRIDER, 2)),
+                Component.literal(" ").append(OTexts.Tooltip.outOfCombat()),
+                Component.literal("  ").append(OTexts.Tooltip.armorEffect(MobEffects.REGENERATION)));
+    }
+}
diff --git a/src/main/java/organica/data/item/armor/armorset/CarnelianArmorSet.java b/src/main/java/organica/data/item/armor/armorset/CarnelianArmorSet.java
new file mode 100644
index 0000000000000000000000000000000000000000..fd73af7093bbae0b4c75d29bbbff36656edd01ac
--- /dev/null
+++ b/src/main/java/organica/data/item/armor/armorset/CarnelianArmorSet.java
@@ -0,0 +1,70 @@
+package organica.data.item.armor.armorset;
+
+import net.minecraft.network.chat.Component;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.damagesource.DamageSource;
+import net.minecraft.world.effect.MobEffects;
+import net.minecraft.world.entity.LivingEntity;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.enchantment.Enchantments;
+import org.jetbrains.annotations.NotNull;
+import organica.data.OTexts;
+import organica.paper.data.item.armor.armorset.ArmorSet;
+
+import java.util.Collection;
+import java.util.List;
+
+public class CarnelianArmorSet extends ArmorSet {
+
+    @Override
+    public void onEquipped(LivingEntity entity, ItemStack stack, int pieces) {
+        if (pieces == 3) {
+            enableEffect(entity, MobEffects.FIRE_RESISTANCE);
+            if (entity.level().dimensionType().ultraWarm()) {
+                enableEffect(entity, MobEffects.MOVEMENT_SPEED);
+            }
+        }
+    }
+
+    @Override
+    public void onUnequipped(LivingEntity entity, int pieces) {
+        if (pieces == 2) {
+            disableEffect(entity, MobEffects.FIRE_RESISTANCE);
+            disableEffect(entity, MobEffects.MOVEMENT_SPEED);
+        }
+    }
+
+    @Override
+    public int getProtectionAmount(LivingEntity entity, int pieces, DamageSource source) {
+        if (pieces == 2) {
+            return Enchantments.FIRE_PROTECTION.getDamageProtection(4, source);
+        }
+        return super.getProtectionAmount(entity, pieces, source);
+    }
+
+    @Override
+    public void onWorldChanged(LivingEntity entity, int pieces, ServerLevel origin, ServerLevel destination) {
+        // to Nether
+        if (destination.dimensionType().ultraWarm() && !origin.dimensionType().ultraWarm()) {
+            enableEffect(entity, MobEffects.MOVEMENT_SPEED);
+        }
+        // to Overworld
+        if (!destination.dimensionType().ultraWarm() && origin.dimensionType().ultraWarm()) {
+            disableEffect(entity, MobEffects.MOVEMENT_SPEED);
+        }
+    }
+
+    @Override
+    public @NotNull Collection<Component> tooltip() {
+        return List.of(
+                Component.empty(),
+                OTexts.Tooltip.pieces(2),
+                Component.literal(" ").append(OTexts.Tooltip.enchantment(Enchantments.FIRE_PROTECTION, 4)),
+
+                Component.empty(),
+                OTexts.Tooltip.pieces(3),
+                Component.literal(" ").append(OTexts.Tooltip.armorEffect(MobEffects.FIRE_RESISTANCE)),
+                Component.literal(" ").append(OTexts.Tooltip.outOfCombat()),
+                Component.literal("  ").append(OTexts.Tooltip.carnelianInTheNether(OTexts.Tooltip.armorEffect(MobEffects.MOVEMENT_SPEED))));
+    }
+}
diff --git a/src/main/java/organica/data/item/armor/armorset/CitrineArmorSet.java b/src/main/java/organica/data/item/armor/armorset/CitrineArmorSet.java
new file mode 100644
index 0000000000000000000000000000000000000000..f9b0d248245d56aa18b64c72529e3b525a786a84
--- /dev/null
+++ b/src/main/java/organica/data/item/armor/armorset/CitrineArmorSet.java
@@ -0,0 +1,43 @@
+package organica.data.item.armor.armorset;
+
+import net.minecraft.network.chat.Component;
+import net.minecraft.world.effect.MobEffects;
+import net.minecraft.world.entity.LivingEntity;
+import net.minecraft.world.item.ItemStack;
+import org.jetbrains.annotations.NotNull;
+import organica.data.OTexts;
+import organica.paper.data.item.armor.armorset.ArmorSet;
+
+import java.util.Collection;
+import java.util.List;
+
+public class CitrineArmorSet extends ArmorSet {
+
+    @Override
+    public void onEquipped(LivingEntity entity, ItemStack stack, int pieces) {
+        switch (pieces) {
+            case 2 -> enableEffect(entity, MobEffects.NIGHT_VISION);
+            case 3 -> enableEffect(entity, MobEffects.DIG_SPEED);
+        }
+    }
+
+    @Override
+    public void onUnequipped(LivingEntity entity, int pieces) {
+        switch (pieces) {
+            case 1 -> disableEffect(entity, MobEffects.NIGHT_VISION);
+            case 2 -> disableEffect(entity, MobEffects.DIG_SPEED);
+        }
+    }
+
+    @Override
+    public @NotNull Collection<Component> tooltip() {
+        return List.of(
+                Component.empty(),
+                OTexts.Tooltip.pieces(2),
+                Component.literal(" ").append(OTexts.Tooltip.armorEffect(MobEffects.NIGHT_VISION)),
+
+                Component.empty(),
+                OTexts.Tooltip.pieces(3),
+                Component.literal(" ").append(OTexts.Tooltip.armorEffect(MobEffects.DIG_SPEED)));
+    }
+}
diff --git a/src/main/java/organica/data/item/armor/armorset/EmeraldArmorSet.java b/src/main/java/organica/data/item/armor/armorset/EmeraldArmorSet.java
new file mode 100644
index 0000000000000000000000000000000000000000..aac1996531923f104fc8be5373cef7f83d768da7
--- /dev/null
+++ b/src/main/java/organica/data/item/armor/armorset/EmeraldArmorSet.java
@@ -0,0 +1,37 @@
+package organica.data.item.armor.armorset;
+
+import net.minecraft.network.chat.Component;
+import net.minecraft.world.effect.MobEffects;
+import net.minecraft.world.entity.LivingEntity;
+import net.minecraft.world.item.ItemStack;
+import org.jetbrains.annotations.NotNull;
+import organica.data.OTexts;
+import organica.paper.data.item.armor.armorset.ArmorSet;
+
+import java.util.Collection;
+import java.util.List;
+
+public class EmeraldArmorSet extends ArmorSet {
+
+    @Override
+    public void onEquipped(LivingEntity entity, ItemStack stack, int pieces) {
+        if (pieces == 1) {
+            enableEffect(entity, MobEffects.HERO_OF_THE_VILLAGE, 3);
+        }
+    }
+
+    @Override
+    public void onUnequipped(LivingEntity entity, int pieces) {
+        if (pieces == 0) {
+            disableEffect(entity, MobEffects.HERO_OF_THE_VILLAGE);
+        }
+    }
+
+    @Override
+    public @NotNull Collection<Component> tooltip() {
+        return List.of(
+                Component.empty(),
+                OTexts.Tooltip.pieces(1),
+                Component.literal(" ").append(OTexts.Tooltip.armorEffect(MobEffects.HERO_OF_THE_VILLAGE, 3)));
+    }
+}
diff --git a/src/main/java/organica/data/item/armor/armorset/EmeraldBlockArmorSet.java b/src/main/java/organica/data/item/armor/armorset/EmeraldBlockArmorSet.java
new file mode 100644
index 0000000000000000000000000000000000000000..3f2cc12d53032e5c0f0e0209bcb5ea326d7306b9
--- /dev/null
+++ b/src/main/java/organica/data/item/armor/armorset/EmeraldBlockArmorSet.java
@@ -0,0 +1,45 @@
+package organica.data.item.armor.armorset;
+
+import net.minecraft.network.chat.Component;
+import net.minecraft.world.damagesource.DamageSource;
+import net.minecraft.world.effect.MobEffects;
+import net.minecraft.world.entity.LivingEntity;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.enchantment.Enchantments;
+import org.jetbrains.annotations.NotNull;
+import organica.data.OTexts;
+import organica.paper.data.item.armor.armorset.ArmorSet;
+
+import java.util.Collection;
+import java.util.List;
+
+public class EmeraldBlockArmorSet extends ArmorSet {
+
+    @Override
+    public void onEquipped(LivingEntity entity, ItemStack stack, int pieces) {
+        if (pieces == 1) {
+            enableEffect(entity, MobEffects.HERO_OF_THE_VILLAGE, 5);
+        }
+    }
+
+    @Override
+    public void onUnequipped(LivingEntity entity, int pieces) {
+        if (pieces == 0) {
+            disableEffect(entity, MobEffects.HERO_OF_THE_VILLAGE);
+        }
+    }
+
+    @Override
+    public int getProtectionAmount(LivingEntity entity, int pieces, DamageSource source) {
+        return Enchantments.PROJECTILE_PROTECTION.getDamageProtection(5, source);
+    }
+
+    @Override
+    public @NotNull Collection<Component> tooltip() {
+        return List.of(
+                Component.empty(),
+                OTexts.Tooltip.pieces(1),
+                Component.literal(" ").append(OTexts.Tooltip.armorEffect(MobEffects.HERO_OF_THE_VILLAGE, 5)),
+                Component.literal(" ").append(OTexts.Tooltip.enchantment(Enchantments.PROJECTILE_PROTECTION, 5)));
+    }
+}
diff --git a/src/main/java/organica/data/item/armor/armorset/HackmaniteArmorSet.java b/src/main/java/organica/data/item/armor/armorset/HackmaniteArmorSet.java
new file mode 100644
index 0000000000000000000000000000000000000000..761132b045487dc845f57fcb0e59e49f724a313b
--- /dev/null
+++ b/src/main/java/organica/data/item/armor/armorset/HackmaniteArmorSet.java
@@ -0,0 +1,64 @@
+package organica.data.item.armor.armorset;
+
+import net.minecraft.network.chat.Component;
+import net.minecraft.world.damagesource.DamageSource;
+import net.minecraft.world.entity.EquipmentSlot;
+import net.minecraft.world.entity.LivingEntity;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.enchantment.Enchantments;
+import org.jetbrains.annotations.NotNull;
+import organica.data.effect.OStatusEffects;
+import organica.paper.data.item.armor.armorset.ArmorSet;
+
+import java.util.Collection;
+import java.util.List;
+
+import static organica.data.OTexts.Tooltip.*;
+
+public class HackmaniteArmorSet extends ArmorSet {
+
+    @Override
+    public void onEquipped(LivingEntity entity, ItemStack stack, int pieces) {
+        if (pieces == 3) {
+            enableEffect(entity, OStatusEffects.BLAST_RESISTANCE);
+        }
+    }
+
+    @Override
+    public void onUnequipped(LivingEntity entity, int pieces) {
+        if (pieces == 2) {
+            disableEffect(entity, OStatusEffects.BLAST_RESISTANCE);
+        }
+    }
+
+    @Override
+    public int getProtectionAmount(LivingEntity entity, int pieces, DamageSource source) {
+        if (pieces >= 2) {
+            return Enchantments.BLAST_PROTECTION.getDamageProtection(7, source);
+        }
+        return super.getProtectionAmount(entity, pieces, source);
+    }
+
+    @Override
+    public @NotNull Collection<Component> tooltip() {
+        return List.of(
+                Component.empty(),
+                pieces(1),
+                Component.literal(" ").append(slot(EquipmentSlot.FEET)),
+                Component.literal("  ").append(enchantment(Enchantments.FROST_WALKER, 2)),
+
+                Component.empty(),
+                pieces(2),
+                Component.literal(" ").append(enchantment(Enchantments.BLAST_PROTECTION, 7)),
+
+                Component.empty(),
+                pieces(3),
+                Component.literal(" ").append(armorEffect(OStatusEffects.BLAST_RESISTANCE)),
+
+                Component.empty(),
+                effectTitle(OStatusEffects.BLAST_RESISTANCE),
+                Component.literal(" ").append(effectDescription(OStatusEffects.BLAST_RESISTANCE, 1)),
+                Component.literal(" ").append(effectDescription(OStatusEffects.BLAST_RESISTANCE, 2)),
+                Component.literal(" ").append(effectDescription(OStatusEffects.BLAST_RESISTANCE, 3)));
+    }
+}
diff --git a/src/main/java/organica/data/item/armor/armorset/HematiteArmorSet.java b/src/main/java/organica/data/item/armor/armorset/HematiteArmorSet.java
new file mode 100644
index 0000000000000000000000000000000000000000..b94ac4b88482119e6789bd4e86b103194160e77a
--- /dev/null
+++ b/src/main/java/organica/data/item/armor/armorset/HematiteArmorSet.java
@@ -0,0 +1,115 @@
+package organica.data.item.armor.armorset;
+
+import com.google.common.collect.HashMultimap;
+import com.google.common.collect.Multimap;
+import net.minecraft.network.chat.Component;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.effect.MobEffects;
+import net.minecraft.world.entity.EquipmentSlot;
+import net.minecraft.world.entity.LivingEntity;
+import net.minecraft.world.entity.ai.attributes.Attribute;
+import net.minecraft.world.entity.ai.attributes.AttributeModifier;
+import net.minecraft.world.entity.ai.attributes.Attributes;
+import net.minecraft.world.item.ArmorItem;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.enchantment.Enchantments;
+import org.jetbrains.annotations.NotNull;
+import organica.data.effect.OStatusEffects;
+import organica.paper.data.item.armor.armorset.ArmorSet;
+
+import java.util.Collection;
+import java.util.List;
+import java.util.UUID;
+
+import static organica.data.OTexts.Tooltip.*;
+
+public class HematiteArmorSet extends ArmorSet {
+    private final Multimap<Attribute, AttributeModifier> speedModifiers = HashMultimap.create();
+    private final Multimap<Attribute, AttributeModifier> underwaterSpeedModifiers = HashMultimap.create();
+
+    public HematiteArmorSet() {
+        {
+            var uuid = UUID.fromString("7BEA6CF1-057B-4E8C-B08B-79A4FC6D3680");
+            var modifier = new AttributeModifier(uuid, "Hematite set movement speed", .065, AttributeModifier.Operation.ADDITION);
+            speedModifiers.put(Attributes.MOVEMENT_SPEED, modifier);
+        }
+        {
+            var uuid = UUID.fromString("DBEDF87D-7CD3-4554-8A16-E4597A0FF3A3");
+            var modifier = new AttributeModifier(uuid, "Hematite set underwater movement speed", -.03, AttributeModifier.Operation.ADDITION);
+            underwaterSpeedModifiers.put(Attributes.MOVEMENT_SPEED, modifier);
+        }
+    }
+
+    @Override
+    public void onEquipped(LivingEntity entity, ItemStack stack, int pieces) {
+        createUuidNbt(stack);
+        if (pieces == 2) {
+            enableEffect(entity, OStatusEffects.LIGHTWEIGHT);
+        } else if (pieces >= 3 && entity instanceof ServerPlayer player) {
+            if (pieces == 3) {
+                player.resetSentInfo();
+                player.getAttributes().addTransientAttributeModifiers(speedModifiers);
+                if (player.isInWater()) {
+                    player.getAttributes().addTransientAttributeModifiers(underwaterSpeedModifiers);
+                }
+                enableEffect(entity, MobEffects.INVISIBILITY);
+            }
+            player.containerMenu.sendAllDataToRemote();
+        }
+    }
+
+    @Override
+    public void onUnequipped(LivingEntity entity, int pieces) {
+        if (pieces == 1) {
+            disableEffect(entity, OStatusEffects.LIGHTWEIGHT);
+        } else if (pieces >= 2 && entity instanceof ServerPlayer player) {
+            if (pieces == 2) {
+                player.resetSentInfo();
+                player.getAttributes().removeAttributeModifiers(speedModifiers);
+                player.getAttributes().removeAttributeModifiers(underwaterSpeedModifiers);
+                disableEffect(entity, MobEffects.INVISIBILITY);
+            }
+            player.containerMenu.sendAllDataToRemote();
+        }
+    }
+
+    @Override
+    public void onTouchingWaterChanged(LivingEntity entity, int pieces) {
+        if (pieces >= 3) {
+            if (entity.isInWater()) {
+                entity.getAttributes().addTransientAttributeModifiers(underwaterSpeedModifiers);
+            } else entity.getAttributes().removeAttributeModifiers(underwaterSpeedModifiers);
+        }
+    }
+
+    @Override
+    public void polymerEnchant(ItemStack stack, int pieces) {
+        var item = stack.getItem();
+        if (pieces >= 3) {
+            stack.enchant(Enchantments.DEPTH_STRIDER, 2);
+            if (item instanceof ArmorItem armorItem && armorItem.getEquipmentSlot().equals(EquipmentSlot.LEGS)) {
+                stack.enchant(Enchantments.SWIFT_SNEAK, 10);
+            }
+        }
+    }
+
+    @Override
+    public @NotNull Collection<Component> tooltip() {
+        return List.of(
+                Component.empty(),
+                pieces(2),
+                Component.literal(" ").append(armorEffect(OStatusEffects.LIGHTWEIGHT)),
+
+                Component.empty(),
+                pieces(3),
+                Component.literal(" ").append(armorEffect(MobEffects.INVISIBILITY)),
+                Component.literal(" ").append(hematiteIncreasedSpeed()),
+                Component.literal(" ").append(hematiteDisabledSprint()),
+                Component.literal(" ").append(slot(EquipmentSlot.LEGS)),
+                Component.literal("  ").append(enchantment(Enchantments.SWIFT_SNEAK, 10)),
+
+                Component.empty(),
+                effectTitle(OStatusEffects.LIGHTWEIGHT),
+                Component.literal(" ").append(effectDescription(OStatusEffects.LIGHTWEIGHT, 1)));
+    }
+}
diff --git a/src/main/java/organica/data/item/armor/material/OArmorMaterials.java b/src/main/java/organica/data/item/armor/material/OArmorMaterials.java
new file mode 100644
index 0000000000000000000000000000000000000000..0d4c73858f4b5b65312b2c49ecf515b8bf229a97
--- /dev/null
+++ b/src/main/java/organica/data/item/armor/material/OArmorMaterials.java
@@ -0,0 +1,116 @@
+package organica.data.item.armor.material;
+
+import com.chocohead.mm.api.ClassTinkerers;
+import com.google.common.base.Suppliers;
+import net.minecraft.world.item.ArmorItem;
+import net.minecraft.world.item.ArmorMaterial;
+import net.minecraft.world.item.ArmorMaterials;
+import net.minecraft.sounds.SoundEvents;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.item.crafting.Ingredient;
+import organica.data.item.OItems;
+
+import java.util.EnumMap;
+
+public class OArmorMaterials {
+    public static final ArmorMaterial CARNELIAN = ArmorMaterials.register(
+            "carnelian",
+            15,
+            new EnumMap<>(ArmorItem.Type.class) {{
+                put(ArmorItem.Type.BOOTS, 3);
+                put(ArmorItem.Type.LEGGINGS, 6);
+                put(ArmorItem.Type.CHESTPLATE, 8);
+                put(ArmorItem.Type.HELMET, 3);
+            }},
+            15,
+            SoundEvents.ARMOR_EQUIP_DIAMOND,
+            2,
+            0,
+            () -> Ingredient.of(OItems.CARNELIAN)
+    );
+    public static final ArmorMaterial CITRINE = ArmorMaterials.register(
+            "citrine",
+            18,
+            new EnumMap<>(ArmorItem.Type.class) {{
+                put(ArmorItem.Type.BOOTS, 3);
+                put(ArmorItem.Type.LEGGINGS, 5);
+                put(ArmorItem.Type.CHESTPLATE, 7);
+                put(ArmorItem.Type.HELMET, 3);
+            }},
+            10,
+            SoundEvents.ARMOR_EQUIP_DIAMOND,
+            2,
+            0,
+            () -> Ingredient.of(OItems.CITRINE_SHARDS)
+    );
+    public static final ArmorMaterial AVENTURINE = ArmorMaterials.register(
+            "aventurine",
+            16,
+            new EnumMap<>(ArmorItem.Type.class) {{
+                put(ArmorItem.Type.BOOTS, 3);
+                put(ArmorItem.Type.LEGGINGS, 6);
+                put(ArmorItem.Type.CHESTPLATE, 7);
+                put(ArmorItem.Type.HELMET, 3);
+            }},
+            10,
+            SoundEvents.ARMOR_EQUIP_DIAMOND,
+            2,
+            0,
+            () -> Ingredient.of(OItems.AVENTURINE)
+    );
+    public static final ArmorMaterial HEMATITE = ArmorMaterials.register(
+            "hematite",
+            19,
+            new EnumMap<>(ArmorItem.Type.class) {{
+                put(ArmorItem.Type.BOOTS, 3);
+                put(ArmorItem.Type.LEGGINGS, 6);
+                put(ArmorItem.Type.CHESTPLATE, 7);
+                put(ArmorItem.Type.HELMET, 3);
+            }},
+            20,
+            SoundEvents.ARMOR_EQUIP_DIAMOND,
+            2,
+            0,
+            () -> Ingredient.of(OItems.HEMATITE_INGOT)
+    );
+    public static final ArmorMaterial HACKMANITE = ArmorMaterials.register(
+            "hackmanite",
+            17,
+            new EnumMap<>(ArmorItem.Type.class) {{
+                put(ArmorItem.Type.BOOTS, 3);
+                put(ArmorItem.Type.LEGGINGS, 6);
+                put(ArmorItem.Type.CHESTPLATE, 7);
+                put(ArmorItem.Type.HELMET, 3);
+            }},
+            10,
+            SoundEvents.ARMOR_EQUIP_DIAMOND,
+            2,
+            0,
+            () -> Ingredient.of(OItems.HACKMANITE_CRYSTAL)
+    );
+    public static final ArmorMaterial EMERALD = ArmorMaterials.register(
+            "emerald",
+            25,
+            new EnumMap<>(ArmorItem.Type.class) {{
+                put(ArmorItem.Type.HELMET, 3);
+            }},
+            9,
+            SoundEvents.ARMOR_EQUIP_DIAMOND,
+            0,
+            0,
+            () -> Ingredient.of(Items.EMERALD)
+    );
+    public static final ArmorMaterial EMERALD_BLOCK = ArmorMaterials.register(
+            "emerald_block",
+            25,
+            new EnumMap<>(ArmorItem.Type.class) {{
+                put(ArmorItem.Type.HELMET, 4);
+            }},
+            9,
+            SoundEvents.ARMOR_EQUIP_DIAMOND,
+            3,
+            0,
+            () -> Ingredient.of(Items.EMERALD_BLOCK)
+    );
+    
+}
diff --git a/src/main/java/organica/data/item/pickaxe/AventurinePickaxeItem.java b/src/main/java/organica/data/item/pickaxe/AventurinePickaxeItem.java
new file mode 100644
index 0000000000000000000000000000000000000000..92a5f83db4aea833deee84d833f3144a502f4f65
--- /dev/null
+++ b/src/main/java/organica/data/item/pickaxe/AventurinePickaxeItem.java
@@ -0,0 +1,23 @@
+package organica.data.item.pickaxe;
+
+import net.minecraft.world.item.enchantment.Enchantment;
+import net.minecraft.world.item.enchantment.Enchantments;
+import organica.Organica;
+import organica.data.enchantment.OEnchantments;
+import organica.data.item.PermanentEnchantmentContainer;
+import organica.data.item.pickaxe.material.OToolMaterials;
+
+import java.util.Map;
+
+public class AventurinePickaxeItem extends TexturedPolymerPickaxeItem implements PermanentEnchantmentContainer {
+    public AventurinePickaxeItem() {
+        super(OToolMaterials.AVENTURINE, 1, -2.8f, Organica.id("aventurine_pickaxe"), new Properties());
+    }
+
+    @Override
+    public Map<Enchantment, Integer> permanentEnchantments() {
+        return Map.of(
+                Enchantments.SILK_TOUCH, 1,
+                OEnchantments.TUNNEL_MINING, 1);
+    }
+}
diff --git a/src/main/java/organica/data/item/pickaxe/CarnelianPickaxeItem.java b/src/main/java/organica/data/item/pickaxe/CarnelianPickaxeItem.java
new file mode 100644
index 0000000000000000000000000000000000000000..6ce7e24203d1847b2d0df031054b5c922f7278ad
--- /dev/null
+++ b/src/main/java/organica/data/item/pickaxe/CarnelianPickaxeItem.java
@@ -0,0 +1,20 @@
+package organica.data.item.pickaxe;
+
+import net.minecraft.world.item.enchantment.Enchantment;
+import organica.Organica;
+import organica.data.enchantment.OEnchantments;
+import organica.data.item.PermanentEnchantmentContainer;
+import organica.data.item.pickaxe.material.OToolMaterials;
+
+import java.util.Map;
+
+public class CarnelianPickaxeItem extends TexturedPolymerPickaxeItem implements PermanentEnchantmentContainer {
+    public CarnelianPickaxeItem() {
+        super(OToolMaterials.CARNELIAN, 1, -2.8f, Organica.id("carnelian_pickaxe"), new Properties());
+    }
+
+    @Override
+    public Map<Enchantment, Integer> permanentEnchantments() {
+        return Map.of(OEnchantments.SMELTING_TOUCH, 1);
+    }
+}
diff --git a/src/main/java/organica/data/item/pickaxe/CitrinePickaxeItem.java b/src/main/java/organica/data/item/pickaxe/CitrinePickaxeItem.java
new file mode 100644
index 0000000000000000000000000000000000000000..c31833598a365d8bffcc2c894f1c4ee12828542e
--- /dev/null
+++ b/src/main/java/organica/data/item/pickaxe/CitrinePickaxeItem.java
@@ -0,0 +1,20 @@
+package organica.data.item.pickaxe;
+
+import net.minecraft.world.item.enchantment.Enchantment;
+import organica.Organica;
+import organica.data.enchantment.OEnchantments;
+import organica.data.item.PermanentEnchantmentContainer;
+import organica.data.item.pickaxe.material.OToolMaterials;
+
+import java.util.Map;
+
+public class CitrinePickaxeItem extends TexturedPolymerPickaxeItem implements PermanentEnchantmentContainer {
+    public CitrinePickaxeItem() {
+        super(OToolMaterials.CITRINE, 1, -2.8f, Organica.id("citrine_pickaxe"), new Properties().durability(-1));
+    }
+
+    @Override
+    public Map<Enchantment, Integer> permanentEnchantments() {
+        return Map.of(OEnchantments.ACCELERATION, 1);
+    }
+}
diff --git a/src/main/java/organica/data/item/pickaxe/HackmanitePickaxeItem.java b/src/main/java/organica/data/item/pickaxe/HackmanitePickaxeItem.java
new file mode 100644
index 0000000000000000000000000000000000000000..6e71a8be5de2689a6367b6c38fec07ef650a1231
--- /dev/null
+++ b/src/main/java/organica/data/item/pickaxe/HackmanitePickaxeItem.java
@@ -0,0 +1,23 @@
+package organica.data.item.pickaxe;
+
+import net.minecraft.world.item.enchantment.Enchantment;
+import net.minecraft.world.item.enchantment.Enchantments;
+import organica.Organica;
+import organica.data.enchantment.OEnchantments;
+import organica.data.item.PermanentEnchantmentContainer;
+import organica.data.item.pickaxe.material.OToolMaterials;
+
+import java.util.Map;
+
+public class HackmanitePickaxeItem extends TexturedPolymerPickaxeItem implements PermanentEnchantmentContainer {
+    public HackmanitePickaxeItem() {
+        super(OToolMaterials.HACKMANITE, 1, -2.8f, Organica.id("hackmanite_pickaxe"), new Properties());
+    }
+
+    @Override
+    public Map<Enchantment, Integer> permanentEnchantments() {
+        return Map.of(
+                Enchantments.BLOCK_FORTUNE, 1,
+                OEnchantments.GRAB, 1);
+    }
+}
diff --git a/src/main/java/organica/data/item/pickaxe/HematitePickaxeItem.java b/src/main/java/organica/data/item/pickaxe/HematitePickaxeItem.java
new file mode 100644
index 0000000000000000000000000000000000000000..1997ac0f49394539f8896261f967e63da107a5ed
--- /dev/null
+++ b/src/main/java/organica/data/item/pickaxe/HematitePickaxeItem.java
@@ -0,0 +1,20 @@
+package organica.data.item.pickaxe;
+
+import net.minecraft.world.item.enchantment.Enchantment;
+import organica.Organica;
+import organica.data.enchantment.OEnchantments;
+import organica.data.item.PermanentEnchantmentContainer;
+import organica.data.item.pickaxe.material.OToolMaterials;
+
+import java.util.Map;
+
+public class HematitePickaxeItem extends TexturedPolymerPickaxeItem implements PermanentEnchantmentContainer {
+    public HematitePickaxeItem() {
+        super(OToolMaterials.HEMATITE, 1, -2.8f, Organica.id("hematite_pickaxe"), new Properties());
+    }
+
+    @Override
+    public Map<Enchantment, Integer> permanentEnchantments() {
+        return Map.of(OEnchantments.GRAB, 1);
+    }
+}
diff --git a/src/main/java/organica/data/item/pickaxe/TexturedPolymerPickaxeItem.java b/src/main/java/organica/data/item/pickaxe/TexturedPolymerPickaxeItem.java
new file mode 100644
index 0000000000000000000000000000000000000000..e429d2a5d802320e5a3f1a3293da6b1987f2a4e2
--- /dev/null
+++ b/src/main/java/organica/data/item/pickaxe/TexturedPolymerPickaxeItem.java
@@ -0,0 +1,37 @@
+package organica.data.item.pickaxe;
+
+import eu.pb4.polymer.core.api.item.PolymerItem;
+import eu.pb4.polymer.resourcepack.api.PolymerModelData;
+import eu.pb4.polymer.resourcepack.api.PolymerResourcePackUtils;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.item.*;
+import org.jetbrains.annotations.Nullable;
+import organica.data.item.Identifiable;
+
+public class TexturedPolymerPickaxeItem extends PickaxeItem implements PolymerItem, Identifiable {
+    private final ResourceLocation id;
+    private final PolymerModelData polymerModelData;
+
+    public TexturedPolymerPickaxeItem(Tier toolMaterial, int attackDamage, float attackSpeed, ResourceLocation id, Properties settings) {
+        super(toolMaterial, attackDamage, attackSpeed, settings);
+        this.id = id;
+        this.polymerModelData = PolymerResourcePackUtils.requestModel(Items.NETHERITE_PICKAXE, id.withPrefix("item/"));
+    }
+
+    @Override
+    public Item getPolymerItem(ItemStack itemStack, @Nullable ServerPlayer player) {
+        return Items.NETHERITE_PICKAXE;
+    }
+
+    @Override
+    public ResourceLocation getId() {
+        return id;
+    }
+
+    @Override
+    public int getPolymerCustomModelData(ItemStack itemStack, @Nullable ServerPlayer player) {
+        return polymerModelData.value();
+    }
+
+}
diff --git a/src/main/java/organica/data/item/pickaxe/material/OToolMaterials.java b/src/main/java/organica/data/item/pickaxe/material/OToolMaterials.java
new file mode 100644
index 0000000000000000000000000000000000000000..984e34771f587e2b801b0de3668e23fd0b528f68
--- /dev/null
+++ b/src/main/java/organica/data/item/pickaxe/material/OToolMaterials.java
@@ -0,0 +1,21 @@
+package organica.data.item.pickaxe.material;
+
+import net.fabricmc.yarn.constants.MiningLevels;
+import net.minecraft.world.item.Tier;
+import net.minecraft.world.item.Tiers;
+import net.minecraft.world.item.crafting.Ingredient;
+import organica.data.item.OItems;
+
+public class OToolMaterials {
+    public static final Tier CARNELIAN = Tiers.register(
+            MiningLevels.IRON, 600, 7, 3, 12, () -> Ingredient.of(OItems.CARNELIAN));
+    public static final Tier CITRINE = Tiers.register(
+            MiningLevels.WOOD, 600, 7, 3, 12, () -> Ingredient.of(OItems.CITRINE_SHARDS));
+    public static final Tier AVENTURINE = Tiers.register(
+            MiningLevels.IRON, 600, 6, 3, 12, () -> Ingredient.of(OItems.CARNELIAN));
+    public static final Tier HEMATITE = Tiers.register(
+            MiningLevels.DIAMOND, 600, 9, 3, 12, () -> Ingredient.of(OItems.HEMATITE_INGOT));
+    public static final Tier HACKMANITE = Tiers.register(
+            MiningLevels.IRON, 600, 7, 3, 15, () -> Ingredient.of(OItems.HACKMANITE_CRYSTAL));
+
+}
diff --git a/src/main/java/organica/data/item/shield/AventurineShieldItem.java b/src/main/java/organica/data/item/shield/AventurineShieldItem.java
new file mode 100644
index 0000000000000000000000000000000000000000..a8e56dd066fc23dbaff023dd4d2f8bfb71d28424
--- /dev/null
+++ b/src/main/java/organica/data/item/shield/AventurineShieldItem.java
@@ -0,0 +1,27 @@
+package organica.data.item.shield;
+
+import net.minecraft.network.chat.Component;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.effect.MobEffectInstance;
+import net.minecraft.world.effect.MobEffects;
+import net.minecraft.world.item.ItemStack;
+import organica.data.OTexts;
+import organica.data.item.armor.material.OArmorMaterials;
+
+import java.util.List;
+
+public class AventurineShieldItem extends OShieldItem {
+    public AventurineShieldItem() {
+        super(OArmorMaterials.AVENTURINE, 150, 40f, 30f, 2 * 20, 3 * 20);
+    }
+
+    @Override
+    protected void trigger(ServerPlayer player) {
+        player.addEffect(new MobEffectInstance(MobEffects.ABSORPTION, 20 * 20, 0));
+    }
+
+    @Override
+    protected void triggerTooltip(List<Component> tooltip, ItemStack stack) {
+        tooltip.add(Component.literal(" ").append(OTexts.Tooltip.effect(MobEffects.ABSORPTION, 0, 20 * 20)));
+    }
+}
diff --git a/src/main/java/organica/data/item/shield/CarnelianShieldItem.java b/src/main/java/organica/data/item/shield/CarnelianShieldItem.java
new file mode 100644
index 0000000000000000000000000000000000000000..1a5f8ac1754a513d1c8fcd3a88f6c7f4b4bbd61d
--- /dev/null
+++ b/src/main/java/organica/data/item/shield/CarnelianShieldItem.java
@@ -0,0 +1,40 @@
+package organica.data.item.shield;
+
+import net.minecraft.network.chat.Component;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.entity.EntitySelector;
+import net.minecraft.world.entity.LivingEntity;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.phys.AABB;
+import net.minecraft.world.phys.Vec3;
+import organica.data.OTexts;
+import organica.data.item.armor.material.OArmorMaterials;
+
+import java.util.List;
+
+public class CarnelianShieldItem extends OShieldItem {
+    private final static int ACTIVATE_RADIUS = 5;
+
+    public CarnelianShieldItem() {
+        super(OArmorMaterials.CARNELIAN, 150, 40f, 20f, 2 * 20, 3 * 20);
+    }
+
+    @Override
+    protected void trigger(ServerPlayer player) {
+        var box = AABB.unitCubeFromLowerCorner(player.position()).inflate(ACTIVATE_RADIUS);
+        var entities = player.level().getEntitiesOfClass(LivingEntity.class, box, EntitySelector.NO_SPECTATORS);
+        for (var entity : entities) {
+            if (entity.equals(player)) continue;
+            if (entity.distanceToSqr(player) > ACTIVATE_RADIUS * ACTIVATE_RADIUS) continue;
+            var vec = entity.position().vectorTo(player.position()).normalize();
+            vec = new Vec3(vec.x, 0, vec.z);
+            if (vec.dot(player.getViewVector(1f)) >= 0) continue;
+            entity.setSecondsOnFire(6);
+        }
+    }
+
+    @Override
+    protected void triggerTooltip(List<Component> tooltip, ItemStack stack) {
+        tooltip.add(Component.literal(" ").append(OTexts.Tooltip.carnelianIgnitesEntitiesInFront()));
+    }
+}
diff --git a/src/main/java/organica/data/item/shield/CitrineShieldItem.java b/src/main/java/organica/data/item/shield/CitrineShieldItem.java
new file mode 100644
index 0000000000000000000000000000000000000000..76148e2f05bb5e8a86c301188cac062fc40dc1d6
--- /dev/null
+++ b/src/main/java/organica/data/item/shield/CitrineShieldItem.java
@@ -0,0 +1,32 @@
+package organica.data.item.shield;
+
+import net.minecraft.network.chat.Component;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.effect.MobEffectInstance;
+import net.minecraft.world.item.ItemStack;
+import organica.data.OTexts;
+import organica.data.effect.OStatusEffects;
+import organica.data.item.armor.material.OArmorMaterials;
+
+import java.util.List;
+
+public class CitrineShieldItem extends OShieldItem {
+    public CitrineShieldItem() {
+        super(OArmorMaterials.CITRINE, 150, 30f, 30f, 20, 20);
+    }
+
+    @Override
+    protected void trigger(ServerPlayer player) {
+        player.addEffect(new MobEffectInstance(OStatusEffects.IMMORTALITY, 2 * 20, 0));
+    }
+
+    @Override
+    protected void triggerTooltip(List<Component> tooltip, ItemStack stack) {
+        tooltip.add(Component.literal(" ").append(OTexts.Tooltip.effect(OStatusEffects.IMMORTALITY, 0, 2 * 20)));
+
+        tooltip.add(Component.empty());
+        tooltip.add(OTexts.Tooltip.effectTitle(OStatusEffects.IMMORTALITY));
+        tooltip.add(Component.literal(" ").append(OTexts.Tooltip.effectDescription(OStatusEffects.IMMORTALITY, 1)));
+        tooltip.add(Component.literal(" ").append(OTexts.Tooltip.effectDescription(OStatusEffects.IMMORTALITY, 2)));
+    }
+}
diff --git a/src/main/java/organica/data/item/shield/HackmaniteShieldItem.java b/src/main/java/organica/data/item/shield/HackmaniteShieldItem.java
new file mode 100644
index 0000000000000000000000000000000000000000..5dd87001ff494786f537338bf27bc3d59799d9ba
--- /dev/null
+++ b/src/main/java/organica/data/item/shield/HackmaniteShieldItem.java
@@ -0,0 +1,47 @@
+package organica.data.item.shield;
+
+import net.minecraft.network.chat.Component;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.entity.EntitySelector;
+import net.minecraft.world.entity.LivingEntity;
+import net.minecraft.world.entity.ai.attributes.Attributes;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.level.Explosion;
+import net.minecraft.world.phys.AABB;
+import net.minecraft.world.phys.Vec3;
+import organica.data.OTexts;
+import organica.data.item.armor.material.OArmorMaterials;
+
+import java.util.List;
+
+public class HackmaniteShieldItem extends OShieldItem {
+    private final static int ACTIVATE_RADIUS = 4;
+    private final static double VELOCITY_MULTIPLIER = 3;
+
+    public HackmaniteShieldItem() {
+        super(OArmorMaterials.HACKMANITE, 150, 35f, 35f, 3 * 20, 4 * 20);
+    }
+
+    @Override
+    protected void trigger(ServerPlayer player) {
+        var box = AABB.unitCubeFromLowerCorner(player.position()).inflate(ACTIVATE_RADIUS);
+        var entities = player.level().getEntitiesOfClass(LivingEntity.class, box, EntitySelector.NO_SPECTATORS);
+        for (var entity : entities) {
+            if (entity.equals(player)) continue;
+            var squaredDistance = entity.distanceToSqr(player);
+            if (squaredDistance > ACTIVATE_RADIUS * ACTIVATE_RADIUS) continue;
+            var motionVec = player.getEyePosition().vectorTo(entity.getEyePosition()).normalize().scale(VELOCITY_MULTIPLIER);
+            motionVec = new Vec3(motionVec.x, 1, motionVec.z);
+            var exposure = Explosion.getSeenPercent(player.getEyePosition(), entity);
+            var resistance = entity.getAttributeValue(Attributes.KNOCKBACK_RESISTANCE);
+            var distanceMultiplier = (1 - Math.sqrt(squaredDistance) / ACTIVATE_RADIUS) * exposure * (1 - resistance);
+            entity.setDeltaMovement(entity.getDeltaMovement().add(motionVec.scale(distanceMultiplier)));
+            entity.hurtMarked = true;
+        }
+    }
+
+    @Override
+    protected void triggerTooltip(List<Component> tooltip, ItemStack stack) {
+        tooltip.add(Component.literal(" ").append(OTexts.Tooltip.hackmaniteKnocksBackEntitiesAround()));
+    }
+}
diff --git a/src/main/java/organica/data/item/shield/HematiteShieldItem.java b/src/main/java/organica/data/item/shield/HematiteShieldItem.java
new file mode 100644
index 0000000000000000000000000000000000000000..cf5cc6abf9ff6037f3fcbc35288758d6a37437b8
--- /dev/null
+++ b/src/main/java/organica/data/item/shield/HematiteShieldItem.java
@@ -0,0 +1,27 @@
+package organica.data.item.shield;
+
+import net.minecraft.network.chat.Component;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.effect.MobEffectInstance;
+import net.minecraft.world.effect.MobEffects;
+import net.minecraft.world.item.ItemStack;
+import organica.data.OTexts;
+import organica.data.item.armor.material.OArmorMaterials;
+
+import java.util.List;
+
+public class HematiteShieldItem extends OShieldItem {
+    public HematiteShieldItem() {
+        super(OArmorMaterials.HEMATITE, 150, 25f, 20f, 3 * 20, 4 * 20);
+    }
+
+    @Override
+    protected void trigger(ServerPlayer player) {
+        player.addEffect(new MobEffectInstance(MobEffects.MOVEMENT_SPEED, 4 * 20, 1));
+    }
+
+    @Override
+    protected void triggerTooltip(List<Component> tooltip, ItemStack stack) {
+        tooltip.add(Component.literal(" ").append(OTexts.Tooltip.effect(MobEffects.MOVEMENT_SPEED, 1, 4 * 20)));
+    }
+}
diff --git a/src/main/java/organica/data/item/shield/IronShieldItem.java b/src/main/java/organica/data/item/shield/IronShieldItem.java
new file mode 100644
index 0000000000000000000000000000000000000000..8b1ca5f3fd89d9e0f819908d832ee7ee1470328a
--- /dev/null
+++ b/src/main/java/organica/data/item/shield/IronShieldItem.java
@@ -0,0 +1,10 @@
+package organica.data.item.shield;
+
+
+import net.minecraft.world.item.ArmorMaterials;
+
+public class IronShieldItem extends OShieldItem {
+    public IronShieldItem() {
+        super(ArmorMaterials.IRON, 150, 30f, -1f, 2 * 20, 5 * 20);
+    }
+}
diff --git a/src/main/java/organica/data/item/shield/OShieldItem.java b/src/main/java/organica/data/item/shield/OShieldItem.java
new file mode 100644
index 0000000000000000000000000000000000000000..152f3a3c0d31c82d3253ffe9304e2d087ed44cdd
--- /dev/null
+++ b/src/main/java/organica/data/item/shield/OShieldItem.java
@@ -0,0 +1,124 @@
+package organica.data.item.shield;
+
+import eu.pb4.polymer.core.api.item.PolymerItem;
+import eu.pb4.polymer.resourcepack.api.PolymerModelData;
+import eu.pb4.polymer.resourcepack.api.PolymerResourcePackUtils;
+import net.minecraft.Util;
+import net.minecraft.network.chat.Component;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.item.*;
+import net.minecraft.world.level.Level;
+import org.jetbrains.annotations.Nullable;
+import organica.Organica;
+import organica.data.OTexts;
+import organica.data.item.Identifiable;
+
+import java.util.List;
+
+public abstract class OShieldItem extends ShieldItem implements PolymerItem, Identifiable {
+    private final ResourceLocation id;
+    private final PolymerModelData polymerModelData;
+    private final ArmorMaterial material;
+    private final float maxResource;
+    private final float absorbedDamageToTrigger;
+    private final int regenerationCooldown;
+    private final int disablingDuration;
+
+    public static final String ABSORBED_DAMAGE_KEY = "AbsorbedDamage";
+    public static final String LAST_ABSORPTION_KEY = "LastAbsorption";
+
+    public static final int SECONDS_BEFORE_ABSORPTION_REDUCTION = 30;
+
+    public OShieldItem(ArmorMaterial material, int durability, float maxResource, float absorbedDamageToTrigger, int regenerationCooldown, int disablingDuration) {
+        super(new Item.Properties().durability(durability));
+        this.material = material;
+        this.id = Organica.id(material.getName() + "_shield");
+        this.polymerModelData = PolymerResourcePackUtils.requestModel(Items.SHIELD, id.withPrefix("item/"));
+
+        this.maxResource = maxResource;
+        this.absorbedDamageToTrigger = absorbedDamageToTrigger;
+        this.regenerationCooldown = regenerationCooldown;
+        this.disablingDuration = disablingDuration;
+    }
+
+    @Override
+    public ResourceLocation getId() {
+        return id;
+    }
+
+    public float getMaxResource() {
+        return maxResource;
+    }
+
+    public int getRegenerationCooldown() {
+        return regenerationCooldown;
+    }
+
+    public int getDisablingDuration() {
+        return disablingDuration;
+    }
+
+    public float getAbsorbedDamageToTrigger() {
+        return absorbedDamageToTrigger;
+    }
+
+    public static void absorb(ItemStack stack, float damage, ServerPlayer player) {
+        if (!(stack.getItem() instanceof OShieldItem item)) return;
+        var nbt = stack.getOrCreateTag();
+        var absorbedDamage = getAbsorbedDamage(stack);
+        absorbedDamage += damage;
+        if (absorbedDamage >= item.absorbedDamageToTrigger) {
+            absorbedDamage -= item.absorbedDamageToTrigger;
+            item.trigger(player);
+        }
+        nbt.putFloat(ABSORBED_DAMAGE_KEY, absorbedDamage);
+        nbt.putLong(LAST_ABSORPTION_KEY, Util.getEpochMillis());
+    }
+
+    public static float getAbsorbedDamage(ItemStack stack) {
+        var nbt = stack.getTag();
+        if (nbt == null) return 0;
+        var absorbedDamage = nbt.getFloat(ABSORBED_DAMAGE_KEY);
+        var sub = Util.getEpochMillis() - nbt.getLong(LAST_ABSORPTION_KEY) - SECONDS_BEFORE_ABSORPTION_REDUCTION * 1000;
+        return sub > 0 ? Math.max(absorbedDamage - (float) (sub / 1000), 0) : absorbedDamage;
+    }
+
+    protected void trigger(ServerPlayer player) {}
+
+    protected void triggerTooltip(List<Component> tooltip, ItemStack stack) {}
+
+    @Override
+    public void appendHoverText(ItemStack stack, @Nullable Level world, List<Component> tooltip, TooltipFlag context) {
+        tooltip.add(Component.empty());
+        tooltip.add(OTexts.Tooltip.maxResource(maxResource));
+        tooltip.add(OTexts.Tooltip.regenerationCooldown(regenerationCooldown));
+        tooltip.add(OTexts.Tooltip.disablingDuration(disablingDuration));
+
+        if (absorbedDamageToTrigger > 0) {
+            tooltip.add(Component.empty());
+            tooltip.add(OTexts.Tooltip.absorbedDamageToTrigger(absorbedDamageToTrigger));
+            triggerTooltip(tooltip, stack);
+        }
+    }
+
+    @Override
+    public boolean isValidRepairItem(ItemStack stack, ItemStack ingredient) {
+        return material.getRepairIngredient().test(ingredient);
+    }
+
+    @Override
+    public int getPolymerCustomModelData(ItemStack itemStack, @Nullable ServerPlayer player) {
+        return polymerModelData.value();
+    }
+
+    @Override
+    public String getDescriptionId(ItemStack stack) {
+        return this.getDescriptionId();
+    }
+
+    @Override
+    public Item getPolymerItem(ItemStack itemStack, @Nullable ServerPlayer player) {
+        return Items.SHIELD;
+    }
+}
diff --git a/src/main/java/organica/data/item/weapon/bow/AventurineBowItem.java b/src/main/java/organica/data/item/weapon/bow/AventurineBowItem.java
new file mode 100644
index 0000000000000000000000000000000000000000..13e348c7753cbd45752e018172ed7b18d58691d9
--- /dev/null
+++ b/src/main/java/organica/data/item/weapon/bow/AventurineBowItem.java
@@ -0,0 +1,22 @@
+package organica.data.item.weapon.bow;
+
+import net.minecraft.world.item.enchantment.Enchantment;
+import net.minecraft.world.item.enchantment.Enchantments;
+import organica.Organica;
+import organica.data.enchantment.OEnchantments;
+import organica.data.item.PermanentEnchantmentContainer;
+
+import java.util.Map;
+
+public class AventurineBowItem extends TexturedPolymerBowItem implements PermanentEnchantmentContainer {
+    public AventurineBowItem() {
+        super(Organica.id("aventurine_bow"), 384, new Properties());
+    }
+
+    @Override
+    public Map<Enchantment, Integer> permanentEnchantments() {
+        return Map.of(
+                Enchantments.INFINITY_ARROWS, 1,
+                OEnchantments.LAMINARITY, 1);
+    }
+}
diff --git a/src/main/java/organica/data/item/weapon/bow/CarnelianBowItem.java b/src/main/java/organica/data/item/weapon/bow/CarnelianBowItem.java
new file mode 100644
index 0000000000000000000000000000000000000000..24044c1bd482f9e2c2f1ab60138ccd94448e8284
--- /dev/null
+++ b/src/main/java/organica/data/item/weapon/bow/CarnelianBowItem.java
@@ -0,0 +1,20 @@
+package organica.data.item.weapon.bow;
+
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.enchantment.Enchantment;
+import net.minecraft.world.item.enchantment.Enchantments;
+import organica.Organica;
+import organica.data.item.PermanentEnchantmentContainer;
+
+import java.util.Map;
+
+public class CarnelianBowItem extends TexturedPolymerBowItem implements PermanentEnchantmentContainer {
+    public CarnelianBowItem() {
+        super(Organica.id("carnelian_bow"), 384, new Item.Properties());
+    }
+
+    @Override
+    public Map<Enchantment, Integer> permanentEnchantments() {
+        return Map.of(Enchantments.FLAMING_ARROWS, 1);
+    }
+}
diff --git a/src/main/java/organica/data/item/weapon/bow/CitrineBowItem.java b/src/main/java/organica/data/item/weapon/bow/CitrineBowItem.java
new file mode 100644
index 0000000000000000000000000000000000000000..01262de6673bf0907bf90e27a72cec0265def211
--- /dev/null
+++ b/src/main/java/organica/data/item/weapon/bow/CitrineBowItem.java
@@ -0,0 +1,21 @@
+package organica.data.item.weapon.bow;
+
+import net.minecraft.world.item.enchantment.Enchantment;
+import organica.Organica;
+import organica.data.enchantment.OEnchantments;
+import organica.data.item.PermanentEnchantmentContainer;
+
+import java.util.Map;
+
+public class CitrineBowItem extends TexturedPolymerBowItem implements PermanentEnchantmentContainer {
+    public CitrineBowItem() {
+        super(Organica.id("citrine_bow"), 384, new Properties());
+    }
+
+    @Override
+    public Map<Enchantment, Integer> permanentEnchantments() {
+        return Map.of(
+                OEnchantments.FAST_FLIGHT, 1,
+                OEnchantments.ACCURACY, 1);
+    }
+}
diff --git a/src/main/java/organica/data/item/weapon/bow/HackmaniteBowItem.java b/src/main/java/organica/data/item/weapon/bow/HackmaniteBowItem.java
new file mode 100644
index 0000000000000000000000000000000000000000..0bec400698761da932b663c6151e0ff80ef0e7dc
--- /dev/null
+++ b/src/main/java/organica/data/item/weapon/bow/HackmaniteBowItem.java
@@ -0,0 +1,23 @@
+package organica.data.item.weapon.bow;
+
+import net.minecraft.world.item.enchantment.Enchantment;
+import organica.Organica;
+import organica.data.item.PermanentEnchantmentContainer;
+
+import java.util.Map;
+
+import static organica.data.enchantment.OEnchantments.*;
+
+public class HackmaniteBowItem extends TexturedPolymerBowItem implements PermanentEnchantmentContainer {
+    public HackmaniteBowItem() {
+        super(Organica.id("hackmanite_bow"), 384, new Properties());
+    }
+
+    @Override
+    public Map<Enchantment, Integer> permanentEnchantments() {
+        return Map.of(
+                DISTANCE_EMPOWERED, 1,
+                BOW_PIERCING, 1,
+                ANTIGRAVITY, 1);
+    }
+}
diff --git a/src/main/java/organica/data/item/weapon/bow/HematiteBowItem.java b/src/main/java/organica/data/item/weapon/bow/HematiteBowItem.java
new file mode 100644
index 0000000000000000000000000000000000000000..91e63fb520b9b7922a66f31be63dba163f351e07
--- /dev/null
+++ b/src/main/java/organica/data/item/weapon/bow/HematiteBowItem.java
@@ -0,0 +1,23 @@
+package organica.data.item.weapon.bow;
+
+import net.minecraft.world.item.enchantment.Enchantment;
+import net.minecraft.world.item.enchantment.Enchantments;
+import organica.Organica;
+import organica.data.enchantment.OEnchantments;
+import organica.data.item.PermanentEnchantmentContainer;
+
+import java.util.Map;
+
+
+public class HematiteBowItem extends TexturedPolymerBowItem implements PermanentEnchantmentContainer {
+    public HematiteBowItem() {
+        super(Organica.id("hematite_bow"), 384, new Properties());
+    }
+
+    @Override
+    public Map<Enchantment, Integer> permanentEnchantments() {
+        return Map.of(
+                Enchantments.PUNCH_ARROWS, 2,
+                OEnchantments.ACCURACY, 1);
+    }
+}
diff --git a/src/main/java/organica/data/item/weapon/bow/TexturedPolymerBowItem.java b/src/main/java/organica/data/item/weapon/bow/TexturedPolymerBowItem.java
new file mode 100644
index 0000000000000000000000000000000000000000..4fadebcb4694bc2e96bbe6ed502d48bed7297a6f
--- /dev/null
+++ b/src/main/java/organica/data/item/weapon/bow/TexturedPolymerBowItem.java
@@ -0,0 +1,39 @@
+package organica.data.item.weapon.bow;
+
+import eu.pb4.polymer.core.api.item.PolymerItem;
+import eu.pb4.polymer.resourcepack.api.PolymerModelData;
+import eu.pb4.polymer.resourcepack.api.PolymerResourcePackUtils;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.item.BowItem;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.Items;
+import org.jetbrains.annotations.Nullable;
+import organica.data.item.Identifiable;
+
+public class TexturedPolymerBowItem extends BowItem implements PolymerItem, Identifiable {
+    private final ResourceLocation id;
+    private final PolymerModelData polymerModelData;
+
+    public TexturedPolymerBowItem(ResourceLocation id, int maxDamage, Item.Properties settings) {
+        super(settings.durability(maxDamage));
+        this.id = id;
+        this.polymerModelData = PolymerResourcePackUtils.requestModel(Items.BOW, id.withPrefix("item/"));
+    }
+
+    @Override
+    public Item getPolymerItem(ItemStack itemStack, @Nullable ServerPlayer player) {
+        return Items.BOW;
+    }
+
+    @Override
+    public ResourceLocation getId() {
+        return id;
+    }
+
+    @Override
+    public int getPolymerCustomModelData(ItemStack itemStack, @Nullable ServerPlayer player) {
+        return polymerModelData.value();
+    }
+}
diff --git a/src/main/java/organica/data/item/weapon/crossbow/AventurineCrossbowItem.java b/src/main/java/organica/data/item/weapon/crossbow/AventurineCrossbowItem.java
new file mode 100644
index 0000000000000000000000000000000000000000..7d5d159d03b11e08a0eb1b3199c123e1f50a30df
--- /dev/null
+++ b/src/main/java/organica/data/item/weapon/crossbow/AventurineCrossbowItem.java
@@ -0,0 +1,21 @@
+package organica.data.item.weapon.crossbow;
+
+import net.minecraft.world.item.enchantment.Enchantment;
+import organica.Organica;
+import organica.data.enchantment.OEnchantments;
+import organica.data.item.PermanentEnchantmentContainer;
+
+import java.util.Map;
+
+public class AventurineCrossbowItem extends TexturedPolymerCrossbowItem implements PermanentEnchantmentContainer {
+    public AventurineCrossbowItem() {
+        super(Organica.id("aventurine_crossbow"), 465, new Properties());
+    }
+
+    @Override
+    public Map<Enchantment, Integer> permanentEnchantments() {
+        return Map.of(
+                OEnchantments.EXTRA_SHOT, 1,
+                OEnchantments.ACCURACY, 1);
+    }
+}
diff --git a/src/main/java/organica/data/item/weapon/crossbow/CarnelianCrossbowItem.java b/src/main/java/organica/data/item/weapon/crossbow/CarnelianCrossbowItem.java
new file mode 100644
index 0000000000000000000000000000000000000000..f424f7939b357e20a442ef726b3519f46864c9dd
--- /dev/null
+++ b/src/main/java/organica/data/item/weapon/crossbow/CarnelianCrossbowItem.java
@@ -0,0 +1,20 @@
+package organica.data.item.weapon.crossbow;
+
+import net.minecraft.world.item.enchantment.Enchantment;
+import organica.Organica;
+import organica.data.item.PermanentEnchantmentContainer;
+
+import java.util.Map;
+
+import organica.data.enchantment.OEnchantments;
+
+public class CarnelianCrossbowItem extends TexturedPolymerCrossbowItem implements PermanentEnchantmentContainer {
+    public CarnelianCrossbowItem() {
+        super(Organica.id("carnelian_crossbow"), 465, new Properties());
+    }
+
+    @Override
+    public Map<Enchantment, Integer> permanentEnchantments() {
+        return Map.of(OEnchantments.CROSSBOW_FLAME, 1);
+    }
+}
diff --git a/src/main/java/organica/data/item/weapon/crossbow/CitrineCrossbowItem.java b/src/main/java/organica/data/item/weapon/crossbow/CitrineCrossbowItem.java
new file mode 100644
index 0000000000000000000000000000000000000000..51d947b434806b616c747e5018ce5b270b2f11a5
--- /dev/null
+++ b/src/main/java/organica/data/item/weapon/crossbow/CitrineCrossbowItem.java
@@ -0,0 +1,22 @@
+package organica.data.item.weapon.crossbow;
+
+import net.minecraft.world.item.enchantment.Enchantment;
+import net.minecraft.world.item.enchantment.Enchantments;
+import organica.Organica;
+import organica.data.enchantment.OEnchantments;
+import organica.data.item.PermanentEnchantmentContainer;
+
+import java.util.Map;
+
+public class CitrineCrossbowItem extends TexturedPolymerCrossbowItem implements PermanentEnchantmentContainer {
+    public CitrineCrossbowItem() {
+        super(Organica.id("citrine_crossbow"), 465, new Properties());
+    }
+
+    @Override
+    public Map<Enchantment, Integer> permanentEnchantments() {
+        return Map.of(
+                OEnchantments.FAST_FLIGHT, 1,
+                Enchantments.QUICK_CHARGE, 2);
+    }
+}
diff --git a/src/main/java/organica/data/item/weapon/crossbow/HackmaniteCrossbowItem.java b/src/main/java/organica/data/item/weapon/crossbow/HackmaniteCrossbowItem.java
new file mode 100644
index 0000000000000000000000000000000000000000..b4d6471c5cf003adda29d82e0f77a1c0c7f569d7
--- /dev/null
+++ b/src/main/java/organica/data/item/weapon/crossbow/HackmaniteCrossbowItem.java
@@ -0,0 +1,23 @@
+package organica.data.item.weapon.crossbow;
+
+import net.minecraft.world.item.enchantment.Enchantment;
+import net.minecraft.world.item.enchantment.Enchantments;
+import organica.Organica;
+import organica.data.enchantment.OEnchantments;
+import organica.data.item.PermanentEnchantmentContainer;
+
+import java.util.Map;
+
+public class HackmaniteCrossbowItem extends TexturedPolymerCrossbowItem implements PermanentEnchantmentContainer {
+    public HackmaniteCrossbowItem() {
+        super(Organica.id("hackmanite_crossbow"), 465, new Properties());
+    }
+
+    @Override
+    public Map<Enchantment, Integer> permanentEnchantments() {
+        return Map.of(
+                OEnchantments.DISTANCE_EMPOWERED, 1,
+                Enchantments.PIERCING, 1,
+                OEnchantments.ANTIGRAVITY, 1);
+    }
+}
diff --git a/src/main/java/organica/data/item/weapon/crossbow/HematiteCrossbowItem.java b/src/main/java/organica/data/item/weapon/crossbow/HematiteCrossbowItem.java
new file mode 100644
index 0000000000000000000000000000000000000000..2bcce671da7881a182238d6f7bdf5c7e86bc7db1
--- /dev/null
+++ b/src/main/java/organica/data/item/weapon/crossbow/HematiteCrossbowItem.java
@@ -0,0 +1,21 @@
+package organica.data.item.weapon.crossbow;
+
+import net.minecraft.world.item.enchantment.Enchantment;
+import organica.Organica;
+import organica.data.enchantment.OEnchantments;
+import organica.data.item.PermanentEnchantmentContainer;
+
+import java.util.Map;
+
+public class HematiteCrossbowItem extends TexturedPolymerCrossbowItem implements PermanentEnchantmentContainer {
+    public HematiteCrossbowItem() {
+        super(Organica.id("hematite_crossbow"), 465, new Properties());
+    }
+
+    @Override
+    public Map<Enchantment, Integer> permanentEnchantments() {
+        return Map.of(
+                OEnchantments.RUN_AND_GUN, 1,
+                OEnchantments.ACCURACY, 1);
+    }
+}
diff --git a/src/main/java/organica/data/item/weapon/crossbow/TexturedPolymerCrossbowItem.java b/src/main/java/organica/data/item/weapon/crossbow/TexturedPolymerCrossbowItem.java
new file mode 100644
index 0000000000000000000000000000000000000000..18efe5a953fbc70f7ea9c357b7a7cd169ba67832
--- /dev/null
+++ b/src/main/java/organica/data/item/weapon/crossbow/TexturedPolymerCrossbowItem.java
@@ -0,0 +1,39 @@
+package organica.data.item.weapon.crossbow;
+
+import eu.pb4.polymer.core.api.item.PolymerItem;
+import eu.pb4.polymer.resourcepack.api.PolymerModelData;
+import eu.pb4.polymer.resourcepack.api.PolymerResourcePackUtils;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.item.CrossbowItem;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.Items;
+import org.jetbrains.annotations.Nullable;
+import organica.data.item.Identifiable;
+
+public class TexturedPolymerCrossbowItem extends CrossbowItem implements PolymerItem, Identifiable {
+    private final ResourceLocation id;
+    private final PolymerModelData polymerModelData;
+
+    public TexturedPolymerCrossbowItem(ResourceLocation id, int maxDamage, Properties settings) {
+        super(settings.stacksTo(1).durability(maxDamage));
+        this.id = id;
+        this.polymerModelData = PolymerResourcePackUtils.requestModel(Items.CROSSBOW, id.withPrefix("item/"));
+    }
+
+    @Override
+    public Item getPolymerItem(ItemStack itemStack, @Nullable ServerPlayer player) {
+        return Items.CROSSBOW;
+    }
+
+    @Override
+    public ResourceLocation getId() {
+        return id;
+    }
+
+    @Override
+    public int getPolymerCustomModelData(ItemStack itemStack, @Nullable ServerPlayer player) {
+        return polymerModelData.value();
+    }
+}
diff --git a/src/main/java/organica/data/item/weapon/melee/AventurineTridentItem.java b/src/main/java/organica/data/item/weapon/melee/AventurineTridentItem.java
new file mode 100644
index 0000000000000000000000000000000000000000..1fda94baec27dbc86e90cd819de3701b9ad0b7c8
--- /dev/null
+++ b/src/main/java/organica/data/item/weapon/melee/AventurineTridentItem.java
@@ -0,0 +1,23 @@
+package organica.data.item.weapon.melee;
+
+import net.minecraft.world.item.enchantment.Enchantment;
+import net.minecraft.world.item.enchantment.Enchantments;
+import organica.Organica;
+import organica.data.item.PermanentEnchantmentContainer;
+
+import java.util.Map;
+
+public class AventurineTridentItem extends TexturedPolymerTridentItem implements PermanentEnchantmentContainer {
+
+    public AventurineTridentItem() {
+        super(7, -2.9f, 250, Organica.id("aventurine_trident"), new Properties());
+    }
+
+    @Override
+    public Map<Enchantment, Integer> permanentEnchantments() {
+        return Map.of(
+                Enchantments.LOYALTY, 1,
+                Enchantments.IMPALING, 2,
+                Enchantments.CHANNELING, 1);
+    }
+}
diff --git a/src/main/java/organica/data/item/weapon/melee/CarnelianAxeItem.java b/src/main/java/organica/data/item/weapon/melee/CarnelianAxeItem.java
new file mode 100644
index 0000000000000000000000000000000000000000..b33ed6dee2806b06bce5aaf9696532a92f9964cc
--- /dev/null
+++ b/src/main/java/organica/data/item/weapon/melee/CarnelianAxeItem.java
@@ -0,0 +1,51 @@
+package organica.data.item.weapon.melee;
+
+import eu.pb4.polymer.core.api.item.PolymerItem;
+import eu.pb4.polymer.resourcepack.api.PolymerModelData;
+import eu.pb4.polymer.resourcepack.api.PolymerResourcePackUtils;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.item.AxeItem;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.item.enchantment.Enchantment;
+import net.minecraft.world.item.enchantment.Enchantments;
+import org.jetbrains.annotations.Nullable;
+import organica.Organica;
+import organica.data.item.Identifiable;
+import organica.data.item.PermanentEnchantmentContainer;
+import organica.data.item.pickaxe.material.OToolMaterials;
+
+import java.util.Map;
+
+public class CarnelianAxeItem extends AxeItem implements PolymerItem, Identifiable, PermanentEnchantmentContainer {
+    private final ResourceLocation id;
+    private final PolymerModelData polymerModelData;
+
+    public CarnelianAxeItem() {
+        super(OToolMaterials.CARNELIAN, 6f, -3.1f, new Properties());
+        this.id = Organica.id("carnelian_axe");
+        this.polymerModelData = PolymerResourcePackUtils.requestModel(Items.NETHERITE_AXE, id.withPrefix("item/"));
+    }
+
+    @Override
+    public Map<Enchantment, Integer> permanentEnchantments() {
+        return Map.of(Enchantments.FIRE_ASPECT, 1);
+    }
+
+    @Override
+    public Item getPolymerItem(ItemStack itemStack, @Nullable ServerPlayer player) {
+        return Items.NETHERITE_AXE;
+    }
+
+    @Override
+    public ResourceLocation getId() {
+        return id;
+    }
+
+    @Override
+    public int getPolymerCustomModelData(ItemStack itemStack, @Nullable ServerPlayer player) {
+        return polymerModelData.value();
+    }
+}
diff --git a/src/main/java/organica/data/item/weapon/melee/CitrineSwordItem.java b/src/main/java/organica/data/item/weapon/melee/CitrineSwordItem.java
new file mode 100644
index 0000000000000000000000000000000000000000..5acc23af7f35d312b60d67095b5ad254622e8574
--- /dev/null
+++ b/src/main/java/organica/data/item/weapon/melee/CitrineSwordItem.java
@@ -0,0 +1,11 @@
+package organica.data.item.weapon.melee;
+
+import net.minecraft.world.item.Item;
+import organica.Organica;
+import organica.data.item.pickaxe.material.OToolMaterials;
+
+public class CitrineSwordItem extends TexturedPolymerSwordItem {
+    public CitrineSwordItem() {
+        super(OToolMaterials.CITRINE, 3, -2f, Organica.id("citrine_sword"), new Item.Properties());
+    }
+}
diff --git a/src/main/java/organica/data/item/weapon/melee/DiamondTridentItem.java b/src/main/java/organica/data/item/weapon/melee/DiamondTridentItem.java
new file mode 100644
index 0000000000000000000000000000000000000000..3f1a4b05150548e2bfd6256e426c49114540a02c
--- /dev/null
+++ b/src/main/java/organica/data/item/weapon/melee/DiamondTridentItem.java
@@ -0,0 +1,9 @@
+package organica.data.item.weapon.melee;
+
+import organica.Organica;
+
+public class DiamondTridentItem extends TexturedPolymerTridentItem {
+    public DiamondTridentItem() {
+        super(7, -2.9f, 250, Organica.id("diamond_trident"), new Properties());
+    }
+}
diff --git a/src/main/java/organica/data/item/weapon/melee/HackmaniteSwordItem.java b/src/main/java/organica/data/item/weapon/melee/HackmaniteSwordItem.java
new file mode 100644
index 0000000000000000000000000000000000000000..1f459f550ff4de9ce28214a7eb74f8d737879f5f
--- /dev/null
+++ b/src/main/java/organica/data/item/weapon/melee/HackmaniteSwordItem.java
@@ -0,0 +1,22 @@
+package organica.data.item.weapon.melee;
+
+import net.minecraft.world.item.enchantment.Enchantment;
+import organica.Organica;
+import organica.data.enchantment.OEnchantments;
+import organica.data.item.PermanentEnchantmentContainer;
+import organica.data.item.pickaxe.material.OToolMaterials;
+
+import java.util.Map;
+
+public class HackmaniteSwordItem extends TexturedPolymerSwordItem implements PermanentEnchantmentContainer {
+    public HackmaniteSwordItem() {
+        super(OToolMaterials.HACKMANITE, 3, -2.4f, Organica.id("hackmanite_sword"), new Properties());
+    }
+
+    @Override
+    public Map<Enchantment, Integer> permanentEnchantments() {
+        return Map.of(
+                OEnchantments.STEADINESS, 2,
+                OEnchantments.BREAKER, 1);
+    }
+}
diff --git a/src/main/java/organica/data/item/weapon/melee/HematiteSwordItem.java b/src/main/java/organica/data/item/weapon/melee/HematiteSwordItem.java
new file mode 100644
index 0000000000000000000000000000000000000000..a2a7ab2eb575427d4541aeb97fbe8db59748e6d4
--- /dev/null
+++ b/src/main/java/organica/data/item/weapon/melee/HematiteSwordItem.java
@@ -0,0 +1,22 @@
+package organica.data.item.weapon.melee;
+
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.enchantment.Enchantment;
+import net.minecraft.world.item.enchantment.Enchantments;
+import organica.Organica;
+import organica.data.item.PermanentEnchantmentContainer;
+import organica.data.item.pickaxe.material.OToolMaterials;
+
+import java.util.Map;
+
+
+public class HematiteSwordItem extends TexturedPolymerSwordItem implements PermanentEnchantmentContainer {
+    public HematiteSwordItem() {
+        super(OToolMaterials.HEMATITE, 3, -2.4f, Organica.id("hematite_sword"), new Item.Properties());
+    }
+
+    @Override
+    public Map<Enchantment, Integer> permanentEnchantments() {
+        return Map.of(Enchantments.KNOCKBACK, 3);
+    }
+}
diff --git a/src/main/java/organica/data/item/weapon/melee/IronTridentItem.java b/src/main/java/organica/data/item/weapon/melee/IronTridentItem.java
new file mode 100644
index 0000000000000000000000000000000000000000..d08e46ab3e5866b5c094f8ce9aa77f214a8d088a
--- /dev/null
+++ b/src/main/java/organica/data/item/weapon/melee/IronTridentItem.java
@@ -0,0 +1,10 @@
+package organica.data.item.weapon.melee;
+
+import net.minecraft.world.item.Item;
+import organica.Organica;
+
+public class IronTridentItem extends TexturedPolymerTridentItem {
+    public IronTridentItem() {
+        super(5, -2.9f, 90, Organica.id("iron_trident"), new Item.Properties());
+    }
+}
diff --git a/src/main/java/organica/data/item/weapon/melee/TexturedPolymerSwordItem.java b/src/main/java/organica/data/item/weapon/melee/TexturedPolymerSwordItem.java
new file mode 100644
index 0000000000000000000000000000000000000000..df934da2e9fe27cff20c3ea7c2ba17413ad98ee5
--- /dev/null
+++ b/src/main/java/organica/data/item/weapon/melee/TexturedPolymerSwordItem.java
@@ -0,0 +1,36 @@
+package organica.data.item.weapon.melee;
+
+import eu.pb4.polymer.core.api.item.PolymerItem;
+import eu.pb4.polymer.resourcepack.api.PolymerModelData;
+import eu.pb4.polymer.resourcepack.api.PolymerResourcePackUtils;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.item.*;
+import org.jetbrains.annotations.Nullable;
+import organica.data.item.Identifiable;
+
+public class TexturedPolymerSwordItem extends SwordItem implements PolymerItem, Identifiable {
+    private final ResourceLocation id;
+    private final PolymerModelData polymerModelData;
+
+    public TexturedPolymerSwordItem(Tier toolMaterial, int attackDamage, float attackSpeed, ResourceLocation id, Item.Properties settings) {
+        super(toolMaterial, attackDamage, attackSpeed, settings);
+        this.id = id;
+        this.polymerModelData = PolymerResourcePackUtils.requestModel(Items.NETHERITE_SWORD, id.withPrefix("item/"));
+    }
+
+    @Override
+    public Item getPolymerItem(ItemStack itemStack, @Nullable ServerPlayer player) {
+        return Items.NETHERITE_SWORD;
+    }
+
+    @Override
+    public ResourceLocation getId() {
+        return id;
+    }
+
+    @Override
+    public int getPolymerCustomModelData(ItemStack itemStack, @Nullable ServerPlayer player) {
+        return polymerModelData.value();
+    }
+}
diff --git a/src/main/java/organica/data/item/weapon/melee/TexturedPolymerTridentItem.java b/src/main/java/organica/data/item/weapon/melee/TexturedPolymerTridentItem.java
new file mode 100644
index 0000000000000000000000000000000000000000..3bcb99991b5775f5711ce317076fa71fa344c776
--- /dev/null
+++ b/src/main/java/organica/data/item/weapon/melee/TexturedPolymerTridentItem.java
@@ -0,0 +1,61 @@
+package organica.data.item.weapon.melee;
+
+import com.google.common.collect.ImmutableMultimap;
+import com.google.common.collect.Multimap;
+import eu.pb4.polymer.core.api.item.PolymerItem;
+import eu.pb4.polymer.resourcepack.api.PolymerModelData;
+import eu.pb4.polymer.resourcepack.api.PolymerResourcePackUtils;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.entity.EquipmentSlot;
+import net.minecraft.world.entity.ai.attributes.Attribute;
+import net.minecraft.world.entity.ai.attributes.AttributeModifier;
+import net.minecraft.world.entity.ai.attributes.Attributes;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.item.TridentItem;
+import org.jetbrains.annotations.Nullable;
+import organica.data.item.Identifiable;
+
+public class TexturedPolymerTridentItem extends TridentItem implements PolymerItem, Identifiable {
+    private final ResourceLocation id;
+    private final PolymerModelData polymerModelData;
+    private final Multimap<Attribute, AttributeModifier> attributeModifiers;
+    private final int throwAttackDamage;
+
+    public TexturedPolymerTridentItem(int attackDamage, float attackSpeed, int maxDamage, ResourceLocation id, Item.Properties settings) {
+        super(settings.durability(maxDamage));
+        this.id = id;
+        this.throwAttackDamage = attackDamage;
+        this.polymerModelData = PolymerResourcePackUtils.requestModel(Items.TRIDENT, id.withPrefix("item/"));
+        this.attributeModifiers = new ImmutableMultimap.Builder<Attribute, AttributeModifier>()
+                .put(Attributes.ATTACK_DAMAGE, new AttributeModifier(BASE_ATTACK_DAMAGE_UUID, "Tool modifier", attackDamage, AttributeModifier.Operation.ADDITION))
+                .put(Attributes.ATTACK_SPEED, new AttributeModifier(BASE_ATTACK_SPEED_UUID, "Tool modifier", attackSpeed, AttributeModifier.Operation.ADDITION))
+                .build();
+    }
+
+    @Override
+    public Multimap<Attribute, AttributeModifier> getDefaultAttributeModifiers(EquipmentSlot slot) {
+        return slot == EquipmentSlot.MAINHAND ? this.attributeModifiers : super.getDefaultAttributeModifiers(slot);
+    }
+
+    @Override
+    public Item getPolymerItem(ItemStack itemStack, @Nullable ServerPlayer player) {
+        return Items.TRIDENT;
+    }
+
+    @Override
+    public ResourceLocation getId() {
+        return id;
+    }
+
+    @Override
+    public int getPolymerCustomModelData(ItemStack itemStack, @Nullable ServerPlayer player) {
+        return polymerModelData.value();
+    }
+
+    public int throwAttackDamage() {
+        return throwAttackDamage;
+    }
+}
diff --git a/src/main/java/organica/mixin/data/item/ArmorMixin.java b/src/main/java/organica/mixin/data/item/ArmorMixin.java
new file mode 100644
index 0000000000000000000000000000000000000000..c0aab43f78b6af3445c80450aa293a0d50734ce1
--- /dev/null
+++ b/src/main/java/organica/mixin/data/item/ArmorMixin.java
@@ -0,0 +1,100 @@
+package organica.mixin.data.item;
+
+import net.minecraft.tags.DamageTypeTags;
+import net.minecraft.world.entity.EquipmentSlot;
+import net.minecraft.world.entity.LivingEntity;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.enchantment.EnchantmentHelper;
+import net.minecraft.world.item.enchantment.Enchantments;
+import org.bukkit.event.EventHandler;
+import org.bukkit.event.EventPriority;
+import org.bukkit.event.Listener;
+import org.bukkit.event.entity.FoodLevelChangeEvent;
+import org.bukkit.plugin.java.JavaPlugin;
+import organica.data.effect.OStatusEffects;
+import organica.data.item.OItems;
+import organica.data.item.armor.OArmorItem;
+import organica.data.item.armor.armorset.ArmorSets;
+import organica.paper.api.entity.EnchantmentHelperEvents;
+import organica.paper.api.entity.LivingEntityEvents;
+
+public class ArmorMixin implements Listener {
+
+    public static void init(JavaPlugin plugin) {
+        EnchantmentHelperEvents.HAS_AQUA_AFFINITY.register(entity -> {
+            return entity.getArmorSetPieces(ArmorSets.AVENTURINE) >= 1;
+        });
+        EnchantmentHelperEvents.GET_DEPTH_STRIDER.register(entity -> {
+            if (entity.getArmorSetPieces(ArmorSets.AVENTURINE) >= 3) {
+                return Math.max(2, EnchantmentHelper.getEnchantmentLevel(Enchantments.DEPTH_STRIDER, entity));
+            } else if (entity.getArmorSetPieces(ArmorSets.HEMATITE) >= 3) {
+                return Math.max(2, EnchantmentHelper.getEnchantmentLevel(Enchantments.DEPTH_STRIDER, entity));
+            }
+            return 0;
+        });
+        EnchantmentHelperEvents.GET_ENCHANTMENT_LEVEL.register((enchantment, entity) -> {
+            if (enchantment.equals(Enchantments.FROST_WALKER)) {
+                if (entity.getArmorSetPieces(ArmorSets.HACKMANITE) > 0) {
+                    for (ItemStack stack : entity.getArmorSlots()) {
+                        if (stack.getItem().equals(OItems.HACKMANITE_BOOTS)) {
+                            return 2;
+                        }
+                    }
+                }
+            }
+            return 0;
+        });
+        LivingEntityEvents.HANDLE_EQUIPMENT_CHANGE.register((entity, equipmentChanges) -> {
+            equipmentChanges.forEach((slot, stack) -> {
+                if (slot.getType() != EquipmentSlot.Type.ARMOR) return;
+
+                var syncedStack = entity.getLastArmorItem(slot);
+                var item = stack.getItem();
+                var syncedItem = syncedStack.getItem();
+                if (item.equals(syncedItem)) return;
+
+                if (item instanceof OArmorItem armorItem) {
+                    var armorSet = armorItem.getArmorSet();
+                    var newPieces = entity.armorSets.compute(armorSet, (__, pieces) -> {
+                        if (pieces == null) pieces = 0;
+                        else if (pieces >= 4) return 4;
+                        return pieces + 1;
+                    });
+                    armorSet.onEquipped(entity, stack, newPieces);
+                }
+                if (syncedItem instanceof OArmorItem syncedArmorItem) {
+                    var armorSet = syncedArmorItem.getArmorSet();
+                    var newPieces = entity.armorSets.compute(armorSet, (__, pieces) -> {
+                        if (pieces == null || pieces <= 0) return 0;
+                        return pieces - 1;
+                    });
+                    armorSet.onUnequipped(entity, newPieces);
+                }
+            });
+        });
+        LivingEntityEvents.IS_INVULNERABLE_TO.register((entity, damageSource) -> {
+            if (damageSource.is(DamageTypeTags.IS_EXPLOSION)) {
+                if (entity.hasEffect(OStatusEffects.BLAST_RESISTANCE) && !entity.isBlastResistanceDisabled()) {
+                    entity.triggerBlastResistance();
+                    return true;
+                }
+            } else if (damageSource.is(DamageTypeTags.IS_FALL)) {
+                if (entity.hasEffect(OStatusEffects.LIGHTWEIGHT)) {
+                    return true;
+                }
+            }
+            return false;
+        });
+
+        plugin.getServer().getPluginManager().registerEvents(new ArmorMixin(), plugin);
+    }
+
+    @EventHandler(priority = EventPriority.HIGHEST)
+    public void on(FoodLevelChangeEvent e) {
+        LivingEntity livingEntity = (LivingEntity) e.getEntity().getHandle();
+        if(livingEntity.getArmorSetPieces(ArmorSets.HEMATITE) >= 3) {
+            if(e.getFoodLevel() < 6) e.setFoodLevel(6);
+        }
+    }
+
+}
diff --git a/src/main/java/organica/mixin/data/item/TooltipMixin.java b/src/main/java/organica/mixin/data/item/TooltipMixin.java
new file mode 100644
index 0000000000000000000000000000000000000000..2977692ce5aedf57d9b692169a3521a7df26aa5f
--- /dev/null
+++ b/src/main/java/organica/mixin/data/item/TooltipMixin.java
@@ -0,0 +1,123 @@
+package organica.mixin.data.item;
+
+import net.minecraft.ChatFormatting;
+import net.minecraft.core.registries.BuiltInRegistries;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.network.chat.CommonComponents;
+import net.minecraft.network.chat.Component;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.world.effect.MobEffectInstance;
+import net.minecraft.world.effect.MobEffects;
+import net.minecraft.world.entity.EquipmentSlot;
+import net.minecraft.world.entity.ai.attributes.Attribute;
+import net.minecraft.world.entity.ai.attributes.AttributeModifier;
+import net.minecraft.world.entity.ai.attributes.Attributes;
+import net.minecraft.world.food.FoodProperties;
+import net.minecraft.world.item.EnchantedBookItem;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.PotionItem;
+import net.minecraft.world.item.TieredItem;
+import net.minecraft.world.item.enchantment.Enchantment;
+import net.minecraft.world.item.enchantment.EnchantmentHelper;
+import net.minecraft.world.item.enchantment.Enchantments;
+import organica.data.OTexts;
+import organica.data.item.PermanentEnchantmentContainer;
+import organica.data.item.armor.OArmorItem;
+import organica.paper.api.entity.StatusEffectEvents;
+import organica.paper.api.item.ItemEvents;
+import organica.paper.api.item.ItemStackEvents;
+import organica.paper.api.item.PotionUtilsEvents;
+import organica.paper.data.TextTooltip;
+
+import java.util.LinkedHashSet;
+import java.util.Map;
+
+public class TooltipMixin {
+
+    public static void init() {
+        ItemEvents.APPEND_HOVER_TEXT.register((stack, world, tooltip, context) -> {
+            // Описание эффектов пищи
+            FoodProperties foodProperties = stack.getItem().getFoodProperties();
+            if (foodProperties != null) {
+                for (var pair : foodProperties.getEffects()) {
+                    var effect = pair.getFirst();
+                    var chance = pair.getSecond();
+                    tooltip.add(OTexts.Tooltip.effect(effect, 1f, chance));
+                }
+            }
+        });
+        ItemEvents.APPEND_HOVER_TEXT.register((stack, world, tooltip, context) -> {
+            // Дополнительные описания предметов (тотем бессмертия)
+            var itemTooltip = stack.getItem().tooltip();
+            if (itemTooltip != null) {
+                tooltip.addAll(itemTooltip);
+            }
+        });
+        ItemStackEvents.GET_TOOLTIP_AFTER_ADDITIONAL.register((stack, player, tooltip, context) -> {
+            // Постоянные чары
+            if (stack.getItem() instanceof PermanentEnchantmentContainer item) {
+                item.permanentEnchantments().forEach((ench, lvl) -> tooltip.add(OTexts.Tooltip.permanentEnchantment(ench, lvl)));
+            }
+        });
+        ItemStackEvents.GET_TOOLTIP_AFTER_MODIFIERS.register((stack, player, tooltip, context) -> {
+            // Эффекты комплекта брони и характеристики инструмента
+            // Описания чар
+            // «Неразрушаемый» для предметов я отрицательной прочностью
+            if (stack.getItem() instanceof OArmorItem item) {
+                tooltip.addAll(item.armorSet().tooltip());
+            }
+            else if (stack.getItem() instanceof TieredItem tool) {
+                var material = tool.getTier();
+                var speedMultiplier = material.getSpeed();
+                var efficiency = EnchantmentHelper.getItemEnchantmentLevel(Enchantments.BLOCK_EFFICIENCY, stack);
+                if (efficiency > 0) speedMultiplier += efficiency * efficiency + 1;
+                tooltip.add(CommonComponents.space().append(OTexts.Tooltip.miningSpeed(speedMultiplier)));
+                tooltip.add(CommonComponents.space().append(OTexts.Tooltip.miningLevel(material.getLevel())));
+            }
+
+            var set = new LinkedHashSet<Enchantment>();
+            if (stack.getItem() instanceof PermanentEnchantmentContainer item)
+                set.addAll(item.permanentEnchantments().keySet());
+            for (var element : stack.getEnchantmentTags())
+                BuiltInRegistries.ENCHANTMENT
+                        .getOptional(EnchantmentHelper.getEnchantmentId((CompoundTag) element))
+                        .ifPresent(set::add);
+            if (stack.getItem() instanceof EnchantedBookItem)
+                for (var element : EnchantedBookItem.getEnchantments(stack))
+                    BuiltInRegistries.ENCHANTMENT
+                            .getOptional(EnchantmentHelper.getEnchantmentId((CompoundTag) element))
+                            .ifPresent(set::add);
+            for (var enchantment : set)
+                if (enchantment instanceof TextTooltip)
+                    tooltip.addAll(((TextTooltip) enchantment).tooltip());
+
+            if (stack.getItem().getMaxDamage() < 0 && (stack.getTag() == null || !stack.getTag().getBoolean(ItemStack.TAG_UNBREAKABLE))) {
+                tooltip.add(Component.translatable("item.unbreakable").withStyle(ChatFormatting.BLUE));
+            }
+        });
+        ItemStackEvents.GET_TOOLTIP_AFTER_CAN_PLACE_ON.register((stack, player, tooltip, context) -> {
+            // Прочность
+            if (stack.isDamageableItem() && (stack.getTag() == null || !stack.getTag().getBoolean(ItemStack.TAG_UNBREAKABLE))) {
+                var max = stack.getMaxDamage();
+                var current = max - stack.getDamageValue();
+                tooltip.add(OTexts.Tooltip.durability(current, max));
+            }
+        });
+        PotionUtilsEvents.REPLACE_POTION_TOOLTIP_EFFECTS.register((statusEffects, tooltip, durationMultiplier, tickRate) -> {
+            // Добавляет сердца в описания эффектов исцеления
+            for (MobEffectInstance instance : statusEffects) {
+                tooltip.add(OTexts.Tooltip.effect(instance, durationMultiplier, 1f));
+            }
+            return true;
+        });
+        StatusEffectEvents.MODIFY_KEY.register(key -> {
+            // Из-за того, что Instant Health используется для «Взрывостойкости»,
+            // необходимо вернуть старое название в подсказки к предметам.
+            if (key != null && key.toString().equals("minecraft:instant_health")) {
+                return new ResourceLocation("instant_health.for_tooltip");
+            }
+            return key;
+        });
+    }
+
+}
diff --git a/src/main/java/organica/paper/api/entity/EnchantmentHelperEvents.java b/src/main/java/organica/paper/api/entity/EnchantmentHelperEvents.java
new file mode 100644
index 0000000000000000000000000000000000000000..6cbf8d02195ad96cc67322b9f48dd7513c1b58dd
--- /dev/null
+++ b/src/main/java/organica/paper/api/entity/EnchantmentHelperEvents.java
@@ -0,0 +1,51 @@
+package organica.paper.api.entity;
+
+import net.fabricmc.fabric.api.event.Event;
+import net.fabricmc.fabric.api.event.EventFactory;
+import net.minecraft.world.damagesource.DamageSource;
+import net.minecraft.world.entity.LivingEntity;
+import net.minecraft.world.item.enchantment.Enchantment;
+
+public class EnchantmentHelperEvents {
+
+    public static final Event<HasAquaAffinity> HAS_AQUA_AFFINITY = EventFactory.createArrayBacked(HasAquaAffinity.class, callbacks -> (entity) -> {
+        for (var callback : callbacks) {
+            if(callback.hasAquaAffinity(entity)) return true;
+        }
+        return false;
+    });
+
+    @FunctionalInterface
+    public interface HasAquaAffinity {
+        boolean hasAquaAffinity(LivingEntity entity);
+    }
+
+    public static final Event<GetDepthStrider> GET_DEPTH_STRIDER = EventFactory.createArrayBacked(GetDepthStrider.class, callbacks -> (entity) -> {
+        int maxLevel = 0;
+        for (var callback : callbacks) {
+            int level = callback.getDepthStrider(entity);
+            if(level > maxLevel) maxLevel = level;
+        }
+        return maxLevel;
+    });
+
+    @FunctionalInterface
+    public interface GetDepthStrider {
+        int getDepthStrider(LivingEntity entity);
+    }
+
+    public static final Event<GetEnchantmentLevel> GET_ENCHANTMENT_LEVEL = EventFactory.createArrayBacked(GetEnchantmentLevel.class, callbacks -> (enchantment, entity) -> {
+        int maxLevel = 0;
+        for (var callback : callbacks) {
+            int level = callback.getEnchantmentLevel(enchantment, entity);
+            if(level > maxLevel) maxLevel = level;
+        }
+        return maxLevel;
+    });
+
+    @FunctionalInterface
+    public interface GetEnchantmentLevel {
+        int getEnchantmentLevel(Enchantment enchantment, LivingEntity entity);
+    }
+
+}
diff --git a/src/main/java/organica/paper/api/entity/LivingEntityEvents.java b/src/main/java/organica/paper/api/entity/LivingEntityEvents.java
new file mode 100644
index 0000000000000000000000000000000000000000..a982c82b4af756171f4b5518e6aa0e30d9f1fb76
--- /dev/null
+++ b/src/main/java/organica/paper/api/entity/LivingEntityEvents.java
@@ -0,0 +1,37 @@
+package organica.paper.api.entity;
+
+import net.fabricmc.fabric.api.event.Event;
+import net.fabricmc.fabric.api.event.EventFactory;
+import net.minecraft.world.damagesource.DamageSource;
+import net.minecraft.world.entity.EquipmentSlot;
+import net.minecraft.world.entity.LivingEntity;
+import net.minecraft.world.item.ItemStack;
+
+import java.util.Map;
+
+public class LivingEntityEvents {
+
+    public static final Event<HandleEquipmentChange> HANDLE_EQUIPMENT_CHANGE = EventFactory.createArrayBacked(HandleEquipmentChange.class, callbacks -> (entity, equipmentChanges) -> {
+        for (HandleEquipmentChange callback : callbacks) {
+            callback.handleEquipmentChange(entity, equipmentChanges);
+        }
+    });
+
+    @FunctionalInterface
+    public interface HandleEquipmentChange {
+        void handleEquipmentChange(LivingEntity entity, Map<EquipmentSlot, ItemStack> equipmentChanges);
+    }
+
+    public static final Event<IsInvulnerableTo> IS_INVULNERABLE_TO = EventFactory.createArrayBacked(IsInvulnerableTo.class, callbacks -> (entity, damageSource) -> {
+        for (IsInvulnerableTo callback : callbacks) {
+            if(callback.isInvulnerableTo(entity, damageSource)) return true;
+        }
+        return false;
+    });
+
+    @FunctionalInterface
+    public interface IsInvulnerableTo {
+        boolean isInvulnerableTo(LivingEntity entity, DamageSource damageSource);
+    }
+
+}
diff --git a/src/main/java/organica/paper/api/entity/StatusEffectEvents.java b/src/main/java/organica/paper/api/entity/StatusEffectEvents.java
new file mode 100644
index 0000000000000000000000000000000000000000..181754b2208ab64a940302d6ab7430f8323eba4c
--- /dev/null
+++ b/src/main/java/organica/paper/api/entity/StatusEffectEvents.java
@@ -0,0 +1,21 @@
+package organica.paper.api.entity;
+
+import net.fabricmc.fabric.api.event.Event;
+import net.fabricmc.fabric.api.event.EventFactory;
+import net.minecraft.resources.ResourceLocation;
+
+public class StatusEffectEvents {
+
+    public static final Event<ModifyKey> MODIFY_KEY = EventFactory.createArrayBacked(ModifyKey.class, callbacks -> (key) -> {
+        for (ModifyKey callback : callbacks) {
+            key = callback.modifyKey(key);
+        }
+        return key;
+    });
+
+    @FunctionalInterface
+    public interface ModifyKey {
+        ResourceLocation modifyKey(ResourceLocation key);
+    }
+
+}
diff --git a/src/main/java/organica/paper/api/item/ItemEvents.java b/src/main/java/organica/paper/api/item/ItemEvents.java
new file mode 100644
index 0000000000000000000000000000000000000000..9ee53ef34c991465dbcecd20e5f9a0a14bc41b02
--- /dev/null
+++ b/src/main/java/organica/paper/api/item/ItemEvents.java
@@ -0,0 +1,30 @@
+package organica.paper.api.item;
+
+import net.fabricmc.fabric.api.event.Event;
+import net.fabricmc.fabric.api.event.EventFactory;
+import net.minecraft.network.chat.Component;
+import net.minecraft.world.entity.EquipmentSlot;
+import net.minecraft.world.entity.LivingEntity;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.TooltipFlag;
+import net.minecraft.world.level.Level;
+
+import javax.annotation.Nullable;
+import java.util.List;
+import java.util.Map;
+
+public class ItemEvents {
+
+    public static final Event<AppendHoverText> APPEND_HOVER_TEXT = EventFactory.createArrayBacked(AppendHoverText.class, callbacks -> (stack, world, tooltip, context) -> {
+        for (AppendHoverText callback : callbacks) {
+            callback.appendHoverText(stack, world, tooltip, context);
+        }
+    });
+
+    @FunctionalInterface
+    public interface AppendHoverText {
+        void appendHoverText(ItemStack stack, @Nullable Level world, List<Component> tooltip, TooltipFlag context);
+    }
+
+}
diff --git a/src/main/java/organica/paper/api/item/ItemStackEvents.java b/src/main/java/organica/paper/api/item/ItemStackEvents.java
new file mode 100644
index 0000000000000000000000000000000000000000..eb16f22e42b4b44c0aec76b8fbaf8fb146f59826
--- /dev/null
+++ b/src/main/java/organica/paper/api/item/ItemStackEvents.java
@@ -0,0 +1,43 @@
+package organica.paper.api.item;
+
+import net.fabricmc.fabric.api.event.Event;
+import net.fabricmc.fabric.api.event.EventFactory;
+import net.minecraft.network.chat.Component;
+import net.minecraft.world.effect.MobEffectInstance;
+import net.minecraft.world.entity.player.Player;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.TooltipFlag;
+import net.minecraft.world.level.Level;
+
+import javax.annotation.Nullable;
+import java.util.List;
+
+public class ItemStackEvents {
+
+    // ItemStack.TooltipPart.ADDITIONAL
+    public static final Event<GetTooltipLines> GET_TOOLTIP_AFTER_ADDITIONAL = EventFactory.createArrayBacked(GetTooltipLines.class, callbacks -> (stack, player, tooltip, context) -> {
+        for (GetTooltipLines callback : callbacks) {
+            callback.getTooltipLines(stack, player, tooltip, context);
+        }
+    });
+
+    // ItemStack.TooltipPart.MODIFIERS
+    public static final Event<GetTooltipLines> GET_TOOLTIP_AFTER_MODIFIERS = EventFactory.createArrayBacked(GetTooltipLines.class, callbacks -> (stack, player, tooltip, context) -> {
+        for (GetTooltipLines callback : callbacks) {
+            callback.getTooltipLines(stack, player, tooltip, context);
+        }
+    });
+
+    // ItemStack.TooltipPart.CAN_PLACE
+    public static final Event<GetTooltipLines> GET_TOOLTIP_AFTER_CAN_PLACE_ON = EventFactory.createArrayBacked(GetTooltipLines.class, callbacks -> (stack, player, tooltip, context) -> {
+        for (GetTooltipLines callback : callbacks) {
+            callback.getTooltipLines(stack, player, tooltip, context);
+        }
+    });
+
+    @FunctionalInterface
+    public interface GetTooltipLines {
+        void getTooltipLines(ItemStack stack, @Nullable Player player, List<Component> tooltip, TooltipFlag context);
+    }
+
+}
diff --git a/src/main/java/organica/paper/api/item/PotionUtilsEvents.java b/src/main/java/organica/paper/api/item/PotionUtilsEvents.java
new file mode 100644
index 0000000000000000000000000000000000000000..0ec7bed7e20f5fc4e9d81e9e1d59f8f0bff4c898
--- /dev/null
+++ b/src/main/java/organica/paper/api/item/PotionUtilsEvents.java
@@ -0,0 +1,26 @@
+package organica.paper.api.item;
+
+import net.fabricmc.fabric.api.event.Event;
+import net.fabricmc.fabric.api.event.EventFactory;
+import net.minecraft.network.chat.Component;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.world.effect.MobEffectInstance;
+
+import java.util.List;
+
+public class PotionUtilsEvents {
+
+    public static final Event<ReplacePotionTooltipLines> REPLACE_POTION_TOOLTIP_EFFECTS = EventFactory.createArrayBacked(ReplacePotionTooltipLines.class, callbacks -> (statusEffects, tooltip, durationMultiplier, tickRate) -> {
+        boolean replace = false;
+        for (ReplacePotionTooltipLines callback : callbacks) {
+            replace = replace || callback.replaceTooltipLines(statusEffects, tooltip, durationMultiplier, tickRate);
+        }
+        return replace;
+    });
+
+    @FunctionalInterface
+    public interface ReplacePotionTooltipLines {
+        boolean replaceTooltipLines(List<MobEffectInstance> statusEffects, List<Component> tooltip, float durationMultiplier, float tickRate);
+    }
+
+}
diff --git a/src/main/java/organica/paper/data/TextTooltip.java b/src/main/java/organica/paper/data/TextTooltip.java
new file mode 100644
index 0000000000000000000000000000000000000000..002025f8eb339ac93b7e041c4940a04f28c5ac46
--- /dev/null
+++ b/src/main/java/organica/paper/data/TextTooltip.java
@@ -0,0 +1,10 @@
+package organica.paper.data;
+
+import net.minecraft.network.chat.Component;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Collection;
+
+public interface TextTooltip {
+    @NotNull Collection<Component> tooltip();
+}
diff --git a/src/main/java/organica/paper/data/item/armor/armorset/ArmorSet.java b/src/main/java/organica/paper/data/item/armor/armorset/ArmorSet.java
new file mode 100644
index 0000000000000000000000000000000000000000..93f402eb6c9836f2aff29a6e3aa74dd200d3394b
--- /dev/null
+++ b/src/main/java/organica/paper/data/item/armor/armorset/ArmorSet.java
@@ -0,0 +1,72 @@
+package organica.paper.data.item.armor.armorset;
+
+import net.minecraft.network.chat.Component;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.damagesource.DamageSource;
+import net.minecraft.world.effect.MobEffect;
+import net.minecraft.world.effect.MobEffectInstance;
+import net.minecraft.world.entity.LivingEntity;
+import net.minecraft.world.item.ItemStack;
+import org.jetbrains.annotations.NotNull;
+import organica.paper.data.TextTooltip;
+
+import java.util.Collection;
+import java.util.List;
+import java.util.UUID;
+
+public class ArmorSet implements TextTooltip {
+    public static final String ITEM_STACK_UUID = "Organica$ArmorItemStackUUID";
+
+    public static void enableEffect(LivingEntity entity, MobEffect statusEffect) {
+        enableEffect(entity, statusEffect, 0);
+    }
+
+    public static void enableEffect(LivingEntity entity, MobEffect statusEffect, int amplifier) {
+        var effect = entity.getEffect(statusEffect);
+        if (effect == null || !effect.isAmbient() || effect.isVisible()) {
+            entity.addEffect(new MobEffectInstance(statusEffect, Integer.MAX_VALUE, amplifier, true, false, true));
+        }
+    }
+
+    public static void disableEffect(LivingEntity entity, MobEffect statusEffect) {
+        var effect = entity.getEffect(statusEffect);
+        if (effect != null && effect.isAmbient() && !effect.isVisible()) {
+            effect.setDuration(1);
+        }
+    }
+
+    protected void createUuidNbt(ItemStack stack) {
+        var nbt = stack.getOrCreateTag();
+        if (!nbt.contains(ITEM_STACK_UUID)) {
+            nbt.putUUID(ITEM_STACK_UUID, UUID.randomUUID());
+        }
+    }
+
+    public void tick(LivingEntity entity, int pieces) {}
+
+    /**@implNote
+     * Может срабатывать несколько раз до {@link ArmorSet#onUnequipped(LivingEntity, int)}.
+     * Например, при загрузке чанка с сущностью в броне или при присоединении игрока.*/
+    public void onEquipped(LivingEntity entity, ItemStack stack, int pieces) {}
+
+    public void onUnequipped(LivingEntity entity, int pieces) {}
+
+    public void onEnterCombat(LivingEntity entity, int pieces) {}
+
+    public void onEndCombat(LivingEntity entity, int pieces) {}
+
+    public void onWorldChanged(LivingEntity entity, int pieces, ServerLevel origin, ServerLevel destination) {}
+
+    public void onTouchingWaterChanged(LivingEntity entity, int pieces) {}
+
+    public int getProtectionAmount(LivingEntity entity, int pieces, DamageSource source) {
+        return 0;
+    }
+
+    public void polymerEnchant(ItemStack stack, int pieces) {}
+
+    @Override
+    public @NotNull Collection<Component> tooltip() {
+        return List.of();
+    }
+}
